<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Book List</title>
    <url>/2021/05/09/Book-List/</url>
    <content><![CDATA[<h2 id="图书清单"><a href="#图书清单" class="headerlink" title="图书清单"></a>图书清单</h2><a id="more"></a>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统导论</p>
<p>现代操作系统</p>
<p>深入理解计算机操作系统</p>
<p>操作系统-精髓与设计原理</p>
<p>编译原理</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>计算机网络-谢希仁</p>
<p>网络是怎样连接的</p>
<p>图解http</p>
<p>HTTP权威指南</p>
<p>Wireshark网络分析就是这么简单</p>
<p>Wireshark网络分析的艺术</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>计算机网络-自顶向下方法</p>
<p>TCP/IP详解 卷1：协议</p>
<p>TCP/IP详解 卷2：实现</p>
<p>TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议</p>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>算法</p>
<p>算法图解</p>
<p>算法导论</p>
<p>程序员代码面试指南</p>
<p>labuladong的算法小抄</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h4><p>Linux命令行大全<br>Linux 系统命令及Shell脚本</p>
<h4 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h4><p>精通Linux<br>Linux程序设计<br>Raspberry Pi入门指南</p>
<h4 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h4><p>高性能Linux服务器运维实战<br>跟老男孩学Linux运维</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库:"></a>关系型数据库:</h4><h5 id="My-SQL"><a href="#My-SQL" class="headerlink" title="My SQL"></a>My SQL</h5><p>SQL必知必会</p>
<p>SQL入门经典</p>
<p>MySQL技术内幕:SQL编程</p>
<p>高性能的MySQL</p>
<p>前金良方:MySQL性能优化金字塔法则</p>
<p>MySQL技术大全</p>
<h4 id="非关系性数据库："><a href="#非关系性数据库：" class="headerlink" title="非关系性数据库："></a>非关系性数据库：</h4><h5 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h5><p>MongoDB权威指南</p>
<p>MongoDB实战</p>
<p>深入学习MongoDB</p>
<h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>Redis开发与运维</p>
<p>Redis设计与实现</p>
<p>Redis 深度历险核心原理与应用实践</p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>垃圾回收的算法与实现</p>
<p>深入分析gcc</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka权威指南</p>
<p>深入理解Kafka：核心设计与实践原理</p>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>Elasticsearch: The Definitive Guide</p>
<p>Elasticsearch in Action</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h4><p>Think Python</p>
<p>Head First Python</p>
<p>Learn Python The Hard Way</p>
<p>Python学习手册</p>
<p>Python编程：从入门到实战</p>
<p>Python编程：入门到实践</p>
<h4 id="进阶-2"><a href="#进阶-2" class="headerlink" title="进阶"></a>进阶</h4><p>Python Cookbook</p>
<p>Python源码剖析</p>
<p>流畅的Python</p>
<p>Python高性能编程</p>
<p>编写高质量代码：改善Python程序的91个建议</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="入门-3"><a href="#入门-3" class="headerlink" title="入门"></a>入门</h4><p>Java核心技术·卷 I（原书第11版） : 基础知识</p>
<p>Java核心技术·卷 I（原书第11版） : 高级特性</p>
<p>Effective Java</p>
<h4 id="进阶-3"><a href="#进阶-3" class="headerlink" title="进阶"></a>进阶</h4><p>重学Java设计模式</p>
<p>Java编程思想 </p>
<p>深入理解Java虚拟机</p>
<p>Java并发编程实战</p>
<p>Clean Code</p>
<p>Java并发编程实战</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>第一行代码:Android</p>
<p>打造高质量Android应用</p>
<h3 id="GoLang"><a href="#GoLang" class="headerlink" title="GoLang"></a>GoLang</h3><h4 id="入门-4"><a href="#入门-4" class="headerlink" title="入门"></a>入门</h4><p>go语言程序设计</p>
<p>Go语言趣学指南</p>
<p>Go语言实战</p>
<p>Go语言并发之道</p>
<h4 id="进阶-4"><a href="#进阶-4" class="headerlink" title="进阶"></a>进阶</h4><p>Go语言编程之旅:一起用go做项目</p>
<p>Go语言学习笔记</p>
<p>Go Web 编程</p>
<p>Go专家编程</p>
<p>Go语言实战(Go in Action)</p>
<p>Go语言高级编程</p>
<h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>GO语言高并发与微服务实战</p>
<h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><p><strong>Python 网络爬虫从入门到实践</strong></p>
<p><strong>Python3网络爬虫开发实战</strong></p>
<p><strong>Python3反爬虫原理与绕过实战</strong></p>
<h4 id="进阶-5"><a href="#进阶-5" class="headerlink" title="进阶"></a>进阶</h4><p><strong>Android安全攻防权威指南</strong></p>
<p><strong>Android应用安全和逆向分析</strong></p>
<p><strong>Android软件安全权威指南</strong></p>
<p><strong>IDA PRO 权威指南</strong></p>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="通识类"><a href="#通识类" class="headerlink" title="通识类"></a>通识类</h4><blockquote>
<p>认识数据分析</p>
<p>构建数据分析思维</p>
<p>练就数据分析能力</p>
</blockquote>
<p><strong>深入浅出数据分析</strong></p>
<p><strong>精益数据分析</strong></p>
<p><strong>数学之美</strong></p>
<h4 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h4><p><strong>统计学</strong></p>
<p><strong>深入浅出统计学</strong></p>
<p><strong>赤裸裸的统计学</strong></p>
<p><strong>统计学七支柱</strong></p>
<p>统计学习方法-李航</p>
<h4 id="实践类"><a href="#实践类" class="headerlink" title="实践类"></a>实践类</h4><blockquote>
<p>what do?    How do?    Why do?</p>
</blockquote>
<h5 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h5><p><strong>谁说菜鸟不会数据分析</strong></p>
<p><strong>Excel数据分析思维、技术、与实践</strong></p>
<p><strong>对比Excel轻松学习数据分析</strong></p>
<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><p><strong>Python数据分析</strong></p>
<p><strong>利用Python进行数据分析</strong></p>
<p><strong>Python金融大数据分析</strong></p>
<p><strong>Python数据分析实战</strong></p>
<h5 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h5><p><strong>用图表说话</strong></p>
<p><strong>Excel图表之道</strong></p>
<h4 id="数据分析技术的应用"><a href="#数据分析技术的应用" class="headerlink" title="数据分析技术的应用"></a>数据分析技术的应用</h4><p>Python数据分析与数据化运营</p>
<p>数据挖掘与数据化运营实战</p>
<p>社交网站的数据挖掘与分析</p>
<h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><p>数据挖掘-概念与技术</p>
<p>数据挖掘导论</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><h4 id="入门-5"><a href="#入门-5" class="headerlink" title="入门"></a>入门</h4><p>深度学习的数学</p>
<p>深度学习入门</p>
<p>Python深度学习</p>
<p>深度学习</p>
<p>动手学习深度学习</p>
<h4 id="进阶-6"><a href="#进阶-6" class="headerlink" title="进阶"></a>进阶</h4><p>深度学习进阶</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习(西瓜书)-周志华</p>
<p>统计学习方法-李航</p>
<p>Patten Recongnition and Machine Learning</p>
<p>统计自然语言处理</p>
<h3 id="运维-1"><a href="#运维-1" class="headerlink" title="运维"></a>运维</h3><p>Python自动化运维</p>
<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><h4 id="入门-6"><a href="#入门-6" class="headerlink" title="入门"></a>入门</h4><p>第一本Docker书</p>
<h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><h4 id="入门-7"><a href="#入门-7" class="headerlink" title="入门"></a>入门</h4><p>每天五分钟玩转Kubernetes</p>
<blockquote>
<p>内容简洁实用，核心观点点到即止。适合小白入门。</p>
</blockquote>
<p>再也不踩坑的Kubernetes</p>
<blockquote>
<p>各种环境搭建如Redis集群、RabbitMQ等。适合当工具书</p>
</blockquote>
<p>Kubernetes权威指南</p>
<blockquote>
<p>书是经典，但大而全。入门绝非最好的选择。或许更适合当Kubernetes的百科全书</p>
</blockquote>
<h4 id="进阶-7"><a href="#进阶-7" class="headerlink" title="进阶"></a>进阶</h4><p>Kubernetes进阶实战</p>
<p>Kubernetes网络权威指南</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>持续更新…</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Array</title>
    <url>/2020/11/21/Golang-Array/</url>
    <content><![CDATA[<h2 id="Array-数组-的介绍"><a href="#Array-数组-的介绍" class="headerlink" title="Array(数组)的介绍"></a>Array(数组)的介绍</h2><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：<br><a id="more"></a></p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [数组数量]数组类型</span><br></pre></td></tr></table></figure>
<p>//数组的长度必须是常量，并且长度是数组类型的一部分。<br>// 一旦定义，长度不能变。 [1]int和[2]int是不同的两种类型。<br>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> a [<span class="number">1</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> b [<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">	a = b </span><br><span class="line"><span class="comment">//  cannot use b (type [2]int) as type [1]int in assignment</span></span><br><span class="line"><span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Array-数组-的定义"><a href="#Array-数组-的定义" class="headerlink" title="Array(数组)的定义"></a>Array(数组)的定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	definitionPart1()</span><br><span class="line">	definitionPart2()</span><br><span class="line">	definitionPart3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表来设置数组元素的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line">	<span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;              <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">	<span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">	fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">	fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">	fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> cityArray = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">	fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">	fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">	fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定索引值的方式来初始化数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart3</span><span class="params">()</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-数组-的定义遍历"><a href="#Array-数组-的定义遍历" class="headerlink" title="Array(数组)的定义遍历"></a>Array(数组)的定义遍历</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 方法1：for循环遍历</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		fmt.Println(a[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法2：for range遍历</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Println(index, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多维数组-嵌套数组"><a href="#多维数组-嵌套数组" class="headerlink" title="多维数组(嵌套数组)"></a>多维数组(嵌套数组)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;长沙&quot;</span>,</span><br><span class="line">		&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">	fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">	b := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">	fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Map</title>
    <url>/2020/11/21/Golang-Map/</url>
    <content><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现map</p>
<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是<code>引用类型</code>，必须<code>初始化</code>才能使用。<br><a id="more"></a></p>
<h2 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化定义</span></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyType:表示键的类型。map可以嵌套map，可以是key 也是是value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ValueType:表示键对应的值的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>类型的变量默认初始值为<span class="literal">nil</span>，需要使用<span class="built_in">make</span>()函数来分配内存。语法为：</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">  key1:value1</span><br><span class="line">  key2:value2</span><br><span class="line">  key4:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">a[<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;male&quot;</span></span><br><span class="line">a[<span class="string">&quot;year&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a:&quot;</span>, a)               <span class="comment">// a: map[name:Payne sex:male year:20]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a[&#x27;sex&#x27;]:&quot;</span>, a[<span class="string">&quot;sex&quot;</span>]) <span class="comment">// a[&#x27;sex&#x27;]: male</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Type of a:%T\n&quot;</span>, a)      <span class="comment">// Type of a:map[string]string</span></span><br><span class="line"></span><br><span class="line">b := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sex&quot;</span>:  <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Year&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b:&quot;</span>, b)               <span class="comment">// b: map[Name:Tim Sex:male Year:20]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b[&#x27;sex&#x27;]:&quot;</span>, b[<span class="string">&quot;Sex&quot;</span>]) <span class="comment">// b[&#x27;sex&#x27;]: male</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of b:%T&quot;</span>, b)   <span class="comment">// Type of b:map[string]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 value可以为任意接受值。而 ok 必须写</span></span><br></pre></td></tr></table></figure>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">value, ok := c[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(value, ok)     <span class="comment">// Tom true</span></span><br><span class="line"></span><br><span class="line">value, ok := c[<span class="string">&quot;name5&quot;</span>]</span><br><span class="line">fmt.Println(value, ok)     <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(value) <span class="comment">// Tom</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只遍历key</span></span><br><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(d + <span class="string">&quot;,&quot;</span>)  <span class="comment">// name1,name2,name3,name4,</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">// 只遍历value</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(v + <span class="string">&quot;,&quot;</span>)  <span class="comment">// Tom,Tim,Payne,John,</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历key value</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(k, <span class="string">&quot;:&quot;</span>, v, <span class="string">&quot; &quot;</span>)   <span class="comment">// name2:Tim name3:Payne name4:John name1:Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br><span class="line"><span class="comment">// map:表示要删除键值对的map</span></span><br><span class="line"><span class="comment">// key:表示要删除的键值对</span></span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">v1, ok := f[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(v1, ok)  <span class="comment">// Tom true</span></span><br><span class="line"><span class="built_in">delete</span>(f, <span class="string">&quot;name1&quot;</span>)</span><br><span class="line">v2, ok := f[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(v2, ok)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mapSlice := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line"> <span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line"> mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;payne&quot;</span></span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;cs&quot;</span></span><br><span class="line"> <span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index:0 value:map[]</span></span><br><span class="line"><span class="comment">// index:1 value:map[]</span></span><br><span class="line"><span class="comment">// index:2 value:map[]</span></span><br><span class="line"><span class="comment">// after init</span></span><br><span class="line"><span class="comment">// index:0 value:map[address:cs name:payne password:123456]</span></span><br><span class="line"><span class="comment">// index:1 value:map[]</span></span><br><span class="line"><span class="comment">// index:2 value:map[]</span></span><br></pre></td></tr></table></figure>
<h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sliceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"> fmt.Println(sliceMap)</span><br><span class="line"> fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line"> sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[]</span></span><br><span class="line"><span class="comment">// after init</span></span><br><span class="line"><span class="comment">// map[中国:[北京 上海]]</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以map理解为key-value的容器，里面可包含基本数据类型\Map,不包含Array。包含sclice</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Defer详解</title>
    <url>/2020/11/21/Golang-Defer%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="defer触发时机"><a href="#defer触发时机" class="headerlink" title="defer触发时机"></a>defer触发时机</h2><blockquote>
<p>A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.</p>
</blockquote>
<p>Go官方文档中对defer的执行时机做了阐述，分别是。</p>
<ul>
<li>包裹defer的函数返回时</li>
<li>包裹defer的函数执行到末尾时        </li>
<li>所在的goroutine发生panic时<a id="more"></a>
<h2 id="defer执行顺序"><a href="#defer执行顺序" class="headerlink" title="defer执行顺序"></a>defer执行顺序</h2></li>
</ul>
<p>当一个方法中有多个defer时， defer会将要延迟执行的方法“压栈”，当defer被触发时，将所有“压栈”的方法“出栈”并执行。所以defer的执行顺序是LIFO的。</p>
<p>执行顺序如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规执行</span></span><br><span class="line"></span><br><span class="line">语句1 -&gt; 语句2 -&gt; 语句3 -&gt; 语句4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在语句2，语句3中添加defer后执行顺序如下</span></span><br><span class="line"></span><br><span class="line">语句1 -&gt; 语句4 -&gt; 语句3(带defer) -&gt; 语句2(带defer) </span><br></pre></td></tr></table></figure>
<h2 id="defer示例"><a href="#defer示例" class="headerlink" title="defer示例"></a>defer示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;start&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line">	fmt.Print(<span class="string">&quot;processing1&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line">	fmt.Print(<span class="string">&quot;processing2&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line">	fmt.Print(<span class="string">&quot;end&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有defer：start  -&gt; processing1  -&gt;  processing2  -&gt; end </li>
<li>processing1、processing2 加入defer：start  -&gt; end  -&gt; processing2  -&gt; processing1</li>
</ul>
<h2 id="defer使用规则"><a href="#defer使用规则" class="headerlink" title="defer使用规则"></a>defer使用规则</h2><h3 id="defer会实时解析参数"><a href="#defer会实时解析参数" class="headerlink" title="defer会实时解析参数"></a>defer会实时解析参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	i ++</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是因为虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量(i)在defer被声明的时候，就已经确定其确定的值了</p>
</blockquote>
<h3 id="defer的类栈执行"><a href="#defer的类栈执行" class="headerlink" title="defer的类栈执行"></a>defer的类栈执行</h3><blockquote>
<p>栈：先入后出</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> f1()</span><br><span class="line">	f2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2\1</span></span><br></pre></td></tr></table></figure>
<h3 id="defer可以读取有名返回值"><a href="#defer可以读取有名返回值" class="headerlink" title="defer可以读取有名返回值"></a>defer可以读取有名返回值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(c())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢…)。<br>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p>
</blockquote>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-匿名函数与闭包</title>
    <url>/2020/11/21/Golang-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="什么是匿名函数"><a href="#什么是匿名函数" class="headerlink" title="什么是匿名函数"></a>什么是匿名函数</h3><p>没有名字的函数，由于函数中不可定义<code>有名字</code>的函数，所有出现匿名函数，匿名函数常使用于函数中定义函数<br><a id="more"></a></p>
<h3 id="匿名函数的定义"><a href="#匿名函数的定义" class="headerlink" title="匿名函数的定义"></a>匿名函数的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span> <span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中参数、返回值视情况酌情加入</p>
</blockquote>
<p>简单的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f1(<span class="number">2</span>, <span class="number">2</span>))   <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(f2(<span class="number">2</span>, <span class="number">2</span>))   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>f1:普通的函数有参数、返回值。直接使用<code>f1()</code>调用即可</p>
<p>f2:匿名函数，有参数，有返回值。变量f2,为函数类型，使用<code>f2()</code>可调用</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。<code>闭包=函数+引用环境</code>。 示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f1()(<span class="number">1</span>, <span class="number">2</span>)) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以简单理解为函数里面包含函数(多为匿名函数)</p>
</blockquote>
<h3 id="深入理解闭包"><a href="#深入理解闭包" class="headerlink" title="深入理解闭包"></a>深入理解闭包</h3><p>闭包常常与作用域之间的关系慎密，首先让我们回顾一下作用域，作用域的范围由上到下分为这几种：</p>
<ul>
<li>全局：即全局均可调用，当在函数中调用修改后并不会直接影响</li>
<li>函数作用域：仅在此函数中进行有效</li>
<li>代码块作用域：仅在此代码块中有效，用完即释放。且外部访问不到此变量(常量)</li>
</ul>
<blockquote>
<p>除全局外，二者均是相对的概念，不必过于拘泥。</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>一旦进行嵌套的，很多朋友就会懵，那么我们进行几个case来尝试一下。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		x += y</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := f1()</span><br><span class="line">	fmt.Println(f(<span class="number">11</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">22</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">33</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">44</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">55</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11,33,66,110,165</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		x += y</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := f2(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(f(<span class="number">21</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">22</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">23</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">24</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
</blockquote>
<h3 id="装饰器函数"><a href="#装饰器函数" class="headerlink" title="装饰器函数"></a>装饰器函数</h3><p>学其他语言的同学，一定听说过甚至使用过<code>装饰器</code>。那让我们使用golang来实现装饰器的这个功能，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorator</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The start Time: %s\n&quot;</span>, time.Now())</span><br><span class="line">	f()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The end Time: %s\n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hw</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//fmt.Println(f1()(1, 2))</span></span><br><span class="line">	Decorator(Hw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入效果如下：</p>
<p>The start Time: 2020-11-17 19:24:23.969042 +0800 CST m=+0.000082415<br>helloWorld<br>The end Time: 2020-11-17 19:24:43.974545 +0800 CST m=+20.005388822</p>
</blockquote>
<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境(变量作用域)</code></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-接口(interface)</title>
    <url>/2020/11/26/Golang-%E6%8E%A5%E5%8F%A3-interface/</url>
    <content><![CDATA[<p><strong>接口是一种类型</strong></p>
<p>最初的<code>int</code>、<code>string</code>、<code>bool</code>,再到稍微复杂的<code>Array</code>、<code>Map</code>、<code>Slice</code>。他们都称之为基础数据类型，以及到多维度符合类型的<code>结构体</code>。以及今日咱们所需要学习的<code>接口</code>。</p>
<p>在Go语言编程中，Go(强类型语言)，也就是说必须是一种具体的类型，当我们需要只关注能调用它的什么方法，而不关注它是什么类型,该怎么办呢？</p>
<p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。<br><a id="jump_1"></p>
<h4 id="疑问：只关心调用的函数，而不关注其类型"><a href="#疑问：只关心调用的函数，而不关注其类型" class="headerlink" title="疑问：只关心调用的函数，而不关注其类型"></a>疑问：只关心调用的函数，而不关注其类型</h4><p>&lt;/a&gt;<br><a id="more"></a><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就要speak</span></span><br><span class="line">	x.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span>，参数列表<span class="number">2</span> ... ) (返回值列表<span class="number">1</span>,返回值列表<span class="number">2</span> ...)</span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">1</span>，参数列表<span class="number">2</span> ...) (返回值列表<span class="number">1</span>,返回值列表<span class="number">2</span> ...)</span><br><span class="line">   	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
</blockquote>
<p>那么为了解决以上<a href="#jump_1">问题</a>，我们可以定义接口。实现如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> speak <span class="keyword">interface</span> &#123;</span><br><span class="line">	speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体person的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体dog 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s speak)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line">	s.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	<span class="keyword">var</span> d1 dog</span><br><span class="line"></span><br><span class="line">	do(p1)</span><br><span class="line">	do(d1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shit~</span></span><br><span class="line"><span class="comment">// 汪汪汪~</span></span><br></pre></td></tr></table></figure>
<h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>一个变量如果实现了接口中全部的方法，那么此变量就实现了这个接口。</p>
<p>接口是一个<strong>需要实现的类型(方法列表)</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> speak <span class="keyword">interface</span> &#123;</span><br><span class="line">	speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体person的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体dog 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s speak)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line">	s.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	<span class="keyword">var</span> d1 dog</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个接口类型：speak的变量speaks</span></span><br><span class="line">	<span class="keyword">var</span> speaks speak</span><br><span class="line">	speaks = d1</span><br><span class="line">	speaks = p1</span><br><span class="line">	fmt.Print(speaks)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>接口类型变量能够存储所有实现了该接口的实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> say <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cats <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dogs <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cats)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Fish~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dogs)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;Shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayer</span><span class="params">(s say)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line">	s.say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x say</span><br><span class="line">	a := cats&#123;&#125;</span><br><span class="line">	b := dogs&#123;&#125;</span><br><span class="line">	x = a</span><br><span class="line">	x.say()</span><br><span class="line">	x = b</span><br><span class="line">	x.say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="值的接受者与指针接收者实现接口"><a href="#值的接受者与指针接收者实现接口" class="headerlink" title="值的接受者与指针接收者实现接口"></a>值的接受者与指针接收者实现接口</h3><h4 id="值的接受者实现接口"><a href="#值的接受者实现接口" class="headerlink" title="值的接受者实现接口"></a>值的接受者实现接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moving <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;丁丁～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;喵呜～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(m moving)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line">	m.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x moving</span><br><span class="line">	a := dog&#123;&#125;</span><br><span class="line">	b := &amp;cat&#123;&#125;</span><br><span class="line">	x = a</span><br><span class="line">	x.move()</span><br><span class="line">	x = b</span><br><span class="line">	x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针<em>dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，cat指针<code>x</code>内部会自动求值`(</em> ** x)`</p>
<h4 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h4><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moving <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;丁丁～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;喵呜～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(m moving)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line">	m.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x moving</span><br><span class="line">	a := dog&#123;&#125; <span class="comment">// a是dog类型</span></span><br><span class="line">	x = a      <span class="comment">// 可以接收dog类型</span></span><br><span class="line">	x.move()</span><br><span class="line">	b := cat&#123;&#125;</span><br><span class="line">	x = b <span class="comment">// 不可以接受指针类型</span></span><br><span class="line">	x.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./pointer.go:28:4: cannot use b (type cat) as type moving in assignment:</span></span><br><span class="line"><span class="comment">// cat does not implement moving (move method has pointer receiver)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-自定义类型</title>
    <url>/2020/11/21/Golang-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在Go语言中没有<code>类</code>，也没有相关于<code>类</code>的继承、多态的实现。却有一种”新的概念”—结构体</p>
<p>Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>那么，接下来就让我们推开Go语言进阶部分内容的大门，Let’s Go</p>
<p>在学习<code>结构体</code>之前我们先预热一下，先了解Golang 的自定义类型<br><a id="more"></a></p>
<ul>
<li>自定义类型: 当现有类型不足以满足需求的时候, 自己创建的类型</li>
<li>类型别名: 仅存在于编写过程, 提高代码可读性 ( byte 是 uint8 的别名; rune 是 uint16 的别名 )</li>
</ul>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><strong><em>类型别名</em></strong> 是 Go 1.9 版本添加的新功能。主要应用于代码升级、工程重构、迁移中类型的兼容性问题。C/C++ 语言中，代码的重构升级可以使用宏快速定义新的代码。Go 语言中并未选择通过宏，而是选择通过类型别名解决重构中最复杂的类型名变更问题</p>
<h2 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h2><p>类型别名规定：Type Alias只是Type 的别名，本质上Type Alias 与Type是同一个类型，即基本数据类型是一致的。好比如我们小时家里人给我们起的小名，上学后英语老师给起的英文名字，但是这个名字都是指的我们自己。</p>
<p>表面上看类型别名与类型定义只有一个等号的差异（”=”）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个叫自定义类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个叫类型别名</span></span><br><span class="line"><span class="keyword">type</span> YourInt = <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>我们继续深入探究他们二者究竟有什么不同。如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; type 后面的是类型</span><br><span class="line">type MyInt int     &#x2F;&#x2F; 自定义类型</span><br><span class="line">type YourInt &#x3D; int &#x2F;&#x2F; 类型别名</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var m MyInt</span><br><span class="line">	var y YourInt</span><br><span class="line">	m &#x3D; 10</span><br><span class="line">	y &#x3D; 20</span><br><span class="line">	fmt.Printf(&quot;m 的类型是：%T, \n&quot;, m)</span><br><span class="line">	fmt.Printf(&quot;y 的类型是：%T, \n&quot;, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>m 的类型是：main.MyInt,<br>y 的类型是：int, </p>
</blockquote>
<p>如上述代码，我们可以知道<code>自定义类型</code>是定义了一种新的类型，而类型别名是基于原始的类型的昵称而已。</p>
<p>相信你这时会想自定义类型有什么用？</p>
<p>既然可以自定义类型，那么我们是可以定制我们的类型的，例如，int是单纯的数字类型，如果我们可以自定义类型，我们是不是可以基于int把字符串里面的数字也包含进去呢？答案当然是可以的。如果有感兴趣的同学，可以自己去尝试一下。</p>
<p>预热完毕，那么让我们进入真正的操作环节，Go，Go，Go～</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现<code>面向对象</code>的相关概念。</p>
<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type和struct关键字来定义结构体</span></span><br><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义需注意</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型</li>
</ul>
<p>具体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	male <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有相同类型的时候，我们还可以将相同类型的变量名使用“,”分割，写在一起。如下</span></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name,male <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个的自定义类型<code>person</code>，它有<code>name</code>、<code>male</code>、<code>age</code>三个字段，分别表示姓名、性别和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和性别等，本质上是一种聚合型的数据类型</p>
<p>将前面的融汇贯通，整点复合型的东东，搞起</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt=<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name MyString</span><br><span class="line">	age MyInt</span><br><span class="line">	male <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义了之后，咱们还需要进行初始化，才能使用。</p>
<h3 id="结构体初始化与基本使用"><a href="#结构体初始化与基本使用" class="headerlink" title="结构体初始化与基本使用"></a>结构体初始化与基本使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name MyString</span><br><span class="line">	age  MyInt</span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, sex <span class="keyword">string</span></span><br><span class="line">	age       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="keyword">var</span> p1 Person1</span><br><span class="line">	p.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">	p.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">	p.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	p1.name = <span class="string">&quot;Tim&quot;</span></span><br><span class="line">	p1.sex = <span class="string">&quot;female&quot;</span></span><br><span class="line">	p1.age = <span class="number">23</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p, p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p1, p1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v&quot;</span>, p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type:main.Person,value:{Payne 20 male}<br>main.Person{name:”Payne”, age:20, sex:”male”}<br>Type:main.Person1,value:{Tim female 23}<br>main.Person1{name:”Tim”, sex:”female”, age:23}</p>
</blockquote>
<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person2 <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">		age  <span class="keyword">int</span></span><br><span class="line">		sex  <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	person2.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">	person2.age = <span class="number">20</span></span><br><span class="line">	person2.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, person2, person2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type:struct &#123; name string; age int; sex string &#125;,value:&#123;Payne 20 male&#125;</span></span><br><span class="line"><span class="comment">// struct &#123; name string; age int; sex string &#125;&#123;name:&quot;Payne&quot;, age:20, sex:&quot;male&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-结构体实现学生管理系统</title>
    <url>/2020/11/23/Golang-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="基于“结构体”实现简易版学生管理系统"><a href="#基于“结构体”实现简易版学生管理系统" class="headerlink" title="基于“结构体”实现简易版学生管理系统"></a>基于“结构体”实现简易版学生管理系统</h2><p>首先咱们在做项目之前，需要对项目进行分析。切记不可贪功冒进，从而导致无用功</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>学生类</li>
<li>管理者类</li>
<li>菜单栏</li>
<li>基于管理类实现功能<ol>
<li>查看</li>
<li>添加</li>
<li>修改</li>
<li>删除</li>
<li>退出<a id="more"></a>
结构图如下:</li>
</ol>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzgz3v3vuj30gc0c4dhc.jpg" alt=""></p>
<p>采用<code>自顶向下</code>的编程思维对以上分析进行复述，先整体、后细节(先全局、后详细)实现如上结构</p>
<h3 id="定义全局的学生类"><a href="#定义全局的学生类" class="headerlink" title="定义全局的学生类"></a>定义全局的学生类</h3><p>在定义学生类之前，我们需了解学生类包含的字段。这里我只定义了Id、姓名。其中id为唯一，姓名可重复。代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int64</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义全局的管理-即操作类"><a href="#定义全局的管理-即操作类" class="headerlink" title="定义全局的管理(即操作类)"></a>定义全局的管理(即操作类)</h3><p>由于学号为唯一，且其对照关系，非常适合使用Map的<code>Key-value</code>格式。在这里仅做定义及声明并不做初始化，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> studentMgr <span class="keyword">struct</span> &#123;</span><br><span class="line">	allStudent <span class="keyword">map</span>[<span class="keyword">int64</span>]student</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>借用好的数据结构，会让您的编程效率，编码思维，事半功倍</p>
</blockquote>
<h3 id="定义菜单栏"><a href="#定义菜单栏" class="headerlink" title="定义菜单栏"></a>定义菜单栏</h3><p>定义菜单栏，以供使用者选择所对应的功能。根据其功能展示。并根据相对功能，定义应函数。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMenu</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Welcome student Manage System, TimeNow:%v&quot;</span>, time.Now())</span><br><span class="line">	fmt.Println(</span><br><span class="line">		<span class="string">` </span></span><br><span class="line"><span class="string">			1: 查看学生</span></span><br><span class="line"><span class="string">			2: 增加学生</span></span><br><span class="line"><span class="string">			3: 修改学生</span></span><br><span class="line"><span class="string">			4: 删除学生</span></span><br><span class="line"><span class="string">			5: 退出~</span></span><br><span class="line"><span class="string">				`</span>)</span><br><span class="line">	fmt.Print(<span class="string">&quot;What are you want do? Please input Serial number:&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上所知，我们许定义的函数有5个，他们分别是<code>查看学生</code>,<code>增加学生</code>,<code>修改学生</code>,<code>删除学生</code>,<code>退出</code>,如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	smr = studentMgr&#123;</span><br><span class="line">		allStudent: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]student),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		showMenu()</span><br><span class="line">		<span class="keyword">var</span> choice <span class="keyword">int64</span></span><br><span class="line">		fmt.Scan(&amp;choice)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;You select %d\n&quot;</span>, choice)</span><br><span class="line">		<span class="keyword">switch</span> choice &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			smr.showStudent()</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			smr.addStudent()</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			smr.editStudent()</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			smr.delStudent()</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Invalid input, please select again：&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里实例化了一个全局的管理类，所有的操作都经过它。</p>
<p>使用switch语句，进行多项的条件分支，更有利于我们编写更简洁的代码</p>
<h3 id="定义功能函数"><a href="#定义功能函数" class="headerlink" title="定义功能函数"></a>定义功能函数</h3><p><code>查看学生</code>,<code>增加学生</code>,<code>修改学生</code>,<code>删除学生</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">showStudent</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 增加学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">addStudent</span><span class="params">()</span></span>	&#123;&#125;</span><br><span class="line"><span class="comment">// 修改学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">editStudent</span><span class="params">()</span></span>	&#123;&#125;</span><br><span class="line"><span class="comment">// 删除学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">delStudent</span><span class="params">()</span></span>	&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>基本的就已经做完了，基础结构就已经完成了，鼓掌～</p>
<p>那么接下来，我们只需要一个个实现相对应的函数。即可实现功能。</p>
<p>首先我们实现的是查看学生函数。</p>
<h3 id="实现查看学生功能"><a href="#实现查看学生功能" class="headerlink" title="实现查看学生功能"></a>实现查看学生功能</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">showStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> s.allStudent &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ID:%d, Name:%s\n&quot;</span>, stu.id, stu.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们只需要遍历Map中所有的键与值，即可拿到所有的学生。这里没什么好说的</p>
</blockquote>
<p>实现增加学生功能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">addStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		stuId   <span class="keyword">int64</span></span><br><span class="line">		stuName <span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 1. 根据输入内容创建学生</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input you need ID:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;stuId)</span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input you need name:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;stuName)</span><br><span class="line">	newStu := student&#123;</span><br><span class="line">		id:   stuId,</span><br><span class="line">		name: stuName,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 将创建的学生加入stu中</span></span><br><span class="line">	s.allStudent[newStu.id] = newStu</span><br><span class="line">	fmt.Println(<span class="string">&quot;Added successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们需要进行的有两步</p>
<ol>
<li><p>获取用户键盘输入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		stuId   <span class="keyword">int64</span></span><br><span class="line">		stuName <span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 1. 根据输入内容创建学生</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input you need ID:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;stuId)</span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input you need name:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;stuName)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>将输入的学生信息加入到管理函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newStu := student&#123;</span><br><span class="line">		id:   stuId,</span><br><span class="line">		name: stuName,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 将创建的学生加入stu中</span></span><br><span class="line">	s.allStudent[newStu.id] = newStu</span><br><span class="line">	fmt.Println(<span class="string">&quot;Added successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加成功则提示成功</p>
</blockquote>
</li>
</ol>
<p>做到这里，咱们就可以进行一个小小的检测，有木有点小激动以及一点小方张。反正我有，示例如下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzi01hhipj30zm0u0jx0.jpg" alt=""></p>
<p><strong>留下一个小Bug，等你去解决，提示，如果key已存在，那么该添加操作会进行？如果暂时没思路，可以继续往下看。虽然并没有直接这里告诉你，但却在下方进行的相对应的解决</strong></p>
<h3 id="实现修改学生功能"><a href="#实现修改学生功能" class="headerlink" title="实现修改学生功能"></a>实现修改学生功能</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">editStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取用户输入</span></span><br><span class="line">	<span class="keyword">var</span> StuId <span class="keyword">int64</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input want change student IdCode:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;StuId)</span><br><span class="line">  <span class="comment">// 检查该学号学生是否存在，没有则提示不存在</span></span><br><span class="line">	value, ok := s.allStudent[StuId]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;You want change student message:&quot;</span>+</span><br><span class="line">		<span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line">	<span class="comment">// 获取修改</span></span><br><span class="line">	<span class="keyword">var</span> newName <span class="keyword">string</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please change to new message:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;newName)</span><br><span class="line">	value.name = newName</span><br><span class="line">	<span class="comment">// 更新学生的姓名</span></span><br><span class="line">	s.allStudent[StuId] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先我们获取用户输入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户输入</span></span><br><span class="line">	<span class="keyword">var</span> StuId <span class="keyword">int64</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input want change student IdCode:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;StuId)</span><br></pre></td></tr></table></figure>
</li>
<li><p>拿着用户输入的学生Id，去Map里面查找相对应的学生Id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := s.allStudent[StuId]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;You want change student message:&quot;</span>+</span><br><span class="line">		<span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br></pre></td></tr></table></figure>
<p>若想实现修改，是需要存在的。如果不存在此学生，提示没有找到该学生，直接return掉。证明无法修改。如果存在那么它一定是唯一的一个Id，因为我们用的是Map格式的嘛，key唯一。</p>
</li>
<li><p>如果存在我们就需要获取到用户所修改的值，并且将原有的Name覆盖掉。即可实现修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newName <span class="keyword">string</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please change to new message:&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;newName)</span><br><span class="line">	value.name = newName</span><br><span class="line">	<span class="comment">// 更新学生的姓名</span></span><br><span class="line">	s.allStudent[StuId] = value</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>测试时间，示例如下：</p>
<p>首先我是添加了一个学生在里面，<code>Id:1,Name:Payne</code>.</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkziis5yxvj31020u044i.jpg" alt=""></p>
<h3 id="实现删除学生功能"><a href="#实现删除学生功能" class="headerlink" title="实现删除学生功能"></a>实现删除学生功能</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span> <span class="title">delStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> studentID <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 获取用户需删除的id</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;Please input want delete studentId：&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;studentID)</span><br><span class="line">	<span class="comment">// 去map里面查找，若有则删除。没有则退出重新选择</span></span><br><span class="line">	value, ok := s.allStudent[studentID]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line">		<span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line">	<span class="built_in">delete</span>(s.allStudent, studentID)</span><br><span class="line">	fmt.Print(<span class="string">&quot;Deleted Successfully\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先我们需要删除，那么它是一定存在我们才能去删除。这个没毛病吧？我觉很ok。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentID <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// 获取用户需删除的id</span></span><br><span class="line">fmt.Print(<span class="string">&quot;Please input want delete studentId：&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;studentID)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不存在提示未找到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := s.allStudent[studentID]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line">		<span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br></pre></td></tr></table></figure>
</li>
<li><p>存在进行修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line">	<span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line"><span class="built_in">delete</span>(s.allStudent, studentID)</span><br><span class="line">fmt.Print(<span class="string">&quot;Deleted Successfully\n&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang内置包之time</title>
    <url>/2020/12/01/Golang%E5%86%85%E7%BD%AE%E5%8C%85%E4%B9%8Btime/</url>
    <content><![CDATA[<h2 id="GoLang内置包之time"><a href="#GoLang内置包之time" class="headerlink" title="GoLang内置包之time"></a>GoLang内置包之time</h2><p>一寸光阴一寸金，寸金难买寸光阴</p>
<p>时间离我们仅在咫尺，无论是在编程中时间还是日常生活中对于时间的<br>记述都是离我们最近的，那么让我们一起来学习一下GoLang中内置包time。<br><a id="more"></a><br>Let’s Go</p>
<h3 id="time包源码怎么说"><a href="#time包源码怎么说" class="headerlink" title="time包源码怎么说"></a>time包源码怎么说</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">	Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">	Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">	Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">	Minute               = <span class="number">60</span> * Second</span><br><span class="line">	Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line">time.Duration是time包定义的一个类型，</span><br><span class="line">它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最长时间段大约<span class="number">290</span>年。</span><br><span class="line"></span><br><span class="line">例如：time.Duration表示<span class="number">1</span>纳秒，time.Second表示<span class="number">1</span>秒。</span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>打印显示出现在的时间，基本示例如下。<br>其中now为<code>time.Time</code>类型,Month 为<code>time.Month</code>类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">	<span class="comment">// current time:2020-12-01 22:24:30.85736 +0800 CST m=+0.000096031</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line">	year := now.Year()     <span class="comment">//年</span></span><br><span class="line">	month := now.Month()   <span class="comment">//月</span></span><br><span class="line">	day := now.Day()       <span class="comment">//日</span></span><br><span class="line">	hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">	minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">	second := now.Second() <span class="comment">//秒</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T,%T,%T,%T,%T,%T\n&quot;</span>, now, year, month, day, hour, minute, second)</span><br><span class="line">	<span class="comment">// time.Time,int,time.Month,int,int,int,int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>在编程中对于时间戳的应用也尤为广泛,例如在Web开发中做cookies有效期，接口加密，<br>Redis中的key有效期等等，大部分都是使用到了时间戳。</p>
<p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。<br>在GoLang中,获取时间戳的操作如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStamp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 当前时间戳 TimeStamp type:int64, TimeStamp:1606832965</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;TimeStamp type:%T, TimeStamp:%v&quot;</span>, now.Unix(), now.Unix())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外还有纳秒时间戳，我们可以使用<code>time.Now().UnixNano()</code>来获取它<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStamp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 纳秒级时间戳TimeStamp type:int64, TimeStamp:1606833059999670000</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;TimeStamp type:%T, TimeStamp:%v\n&quot;</span>, now.UnixNano(), now.UnixNano())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么基本的时间戳的先暂且为止了，那该如何由时间戳转化为普通的时间格式呢？</p>
<p>当然也是有方法滴，莫急莫急，请听我一一道来，嘴比较笨就直接用代码吧，嘻嘻</p>
<p>在<code>go</code>语言中可以<code>time.Unix</code>来直接将时间戳转化为当前时间格式，实现瞬间替换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStampToTime</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timestamp := time.Now().Unix()</span><br><span class="line">	timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">	fmt.Println(timeObj)</span><br><span class="line">	year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">	month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">	day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">	hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">	minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">	second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以简单的将时间戳转化为时间格式，是不是很Nice</p>
<p>基本的定义查看就以及搞完了，那咱们整一下高级一点的东西，时间的操作</p>
<h3 id="操作时间"><a href="#操作时间" class="headerlink" title="操作时间"></a>操作时间</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>在原本的时间基础上在增加h时m分钟s秒，其增加的部分源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type Duration int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">	dsec := <span class="keyword">int64</span>(d / <span class="number">1e9</span>)</span><br><span class="line">	nsec := t.nsec() + <span class="keyword">int32</span>(d%<span class="number">1e9</span>)</span><br><span class="line">	<span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">		dsec++</span><br><span class="line">		nsec -= <span class="number">1e9</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">		dsec--</span><br><span class="line">		nsec += <span class="number">1e9</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.wall = t.wall&amp;^nsecMask | <span class="keyword">uint64</span>(nsec) <span class="comment">// update nsec</span></span><br><span class="line">	t.addSec(dsec)</span><br><span class="line">	<span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">		te := t.ext + <span class="keyword">int64</span>(d)</span><br><span class="line">		<span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">			<span class="comment">// Monotonic clock reading now out of range; degrade to wall-only.</span></span><br><span class="line">			t.stripMono()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			t.ext = te</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先如果要增加的话那么数据的类型必须是一致的，这个在强类型语言go中这个是一定的。</p>
<p>从上面的源码中函数定义的这个变量名<code>Add(d Duration)</code>发现，其参数d为Duration类型，那么我们直接拿过来用即可，实现代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func operating(h, m, s, mls, msc, ns time.Duration) &#123;</span><br><span class="line">	now :&#x3D; time.Now()</span><br><span class="line">	fmt.Println(now.Add(time.Hour*h + time.Minute*m + time.Second*s + time.Millisecond*mls + time.Microsecond*msc + time.Nanosecond*ns))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F;timeDemo()</span><br><span class="line">	&#x2F;&#x2F;timeStamp()</span><br><span class="line">	&#x2F;&#x2F;timeStampToTime()</span><br><span class="line">	operating(3, 4, 5, 6, 7, 8)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意在这里并不能增加年\月\日，仅能增加时分秒,也就是以下的才被允许</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">	Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">	Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">	Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">	Minute               = <span class="number">60</span> * Second</span><br><span class="line">	Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func operating() &#123;</span><br><span class="line">	now :&#x3D; time.Now()</span><br><span class="line">	targetTime :&#x3D; now.Add(time.Hour)</span><br><span class="line">	&#x2F;&#x2F; 目标时间与此时相比相差1h0m0s</span><br><span class="line">	fmt.Println(targetTime.Sub(now))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谁的sub谁为参照时间</p>
</blockquote>
<h4 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p>
<h4 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>如果t代表的时间点在u之前，返回真；否则返回假。</p>
<h4 id="After"><a href="#After" class="headerlink" title="After"></a>After</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>如果t代表的时间点在u之后，返回真；否则返回假。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">		fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>时间类型有一个自带的方法<code>Format</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line">	<span class="comment">// 24小时制</span></span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line">	<span class="comment">// 12小时制</span></span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p>
<h4 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2019/08/04 14:15:20&quot;</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang介绍</title>
    <url>/2020/11/21/Golang%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Golang官网地址:<a href="https://golang.org/">https://golang.org/</a></li>
<li>Golang官方文档:<a href="https://golang.org/doc/">https://golang.org/doc/</a></li>
<li>Golang Packages:<a href="https://golang.org/pkg/">https://golang.org/pkg/</a></li>
<li>Golang中文网：<a href="https://studygolang.com/">https://studygolang.com/</a></li>
<li>Golang中文文档：<a href="http://docscn.studygolang.com/">http://docscn.studygolang.com/</a></li>
<li>Golang中文Packages：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></li>
</ul>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Golang(又称Go)是<a href="https://zh.wikipedia.org/wiki/Google">Google</a>公司开发的一种<a href="https://zh.wikipedia.org/wiki/静态类型">静态</a><a href="https://zh.wikipedia.org/wiki/強類型">强类型</a>、<a href="https://zh.wikipedia.org/wiki/編譯語言">编译型</a>、<a href="https://zh.wikipedia.org/wiki/並行計算">并发型</a>，并具有<a href="https://zh.wikipedia.org/wiki/垃圾回收_(計算機科學">垃圾回收功能</a>)的<a href="https://zh.wikipedia.org/wiki/编程语言">编程语言</a>。</p>
<p><a href="https://zh.wikipedia.org/w/index.php?title=羅伯特·格瑞史莫&amp;action=edit&amp;redlink=1">罗伯特·格瑞史莫</a>，<a href="https://zh.wikipedia.org/wiki/羅勃·派克">罗勃·派克</a>（Rob Pike）及<a href="https://zh.wikipedia.org/wiki/肯·汤普逊">肯·汤普逊</a>于2007年9月开始设计GO，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于<a href="https://zh.wikipedia.org/wiki/Inferno">Inferno</a>操作系统所开发的。Go于2009年11月正式宣布推出，成为<a href="https://zh.wikipedia.org/wiki/開放原始碼">开放源代码</a>项目，支持<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>、<a href="https://zh.wikipedia.org/wiki/MacOS">macOS</a>、<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>等操作系统。在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言”。</p>
<p>目前，Go每半年发布一个二级版本（即从a.x升级到a.y）。<br><a id="more"></a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Go的语法接近<a href="https://zh.wikipedia.org/wiki/C语言">C语言</a>，但对于<a href="https://zh.wikipedia.org/w/index.php?title=变量的声明&amp;action=edit&amp;redlink=1">变量的声明</a>有所不同。Go支持<a href="https://zh.wikipedia.org/wiki/垃圾回收_(計算機科學">垃圾回收功能</a>)。Go的<a href="https://zh.wikipedia.org/wiki/并行计算">并行计算</a>模型是以<a href="https://zh.wikipedia.org/wiki/東尼·霍爾">东尼·霍尔</a>的<a href="https://zh.wikipedia.org/wiki/交談循序程式">通信顺序进程</a>（CSP）为基础，采取类似模型的其他语言包括<a href="https://zh.wikipedia.org/wiki/Occam">Occam</a>和<a href="https://zh.wikipedia.org/wiki/Limbo">Limbo</a><a href="https://zh.wikipedia.org/wiki/Go#cite_note-langfaq-3">[3]</a>，Go也具有这个模型的特征，比如<a href="https://zh.wikipedia.org/wiki/通道_(编程">通道</a>)传输。通过goroutine和通道等并行构造可以建造<a href="https://zh.wikipedia.org/wiki/线程池">线程池</a>和<a href="https://zh.wikipedia.org/wiki/管道_(软件">管道</a>)等<a href="https://zh.wikipedia.org/wiki/Go#cite_note-8">[8]</a>。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。</p>
<p>与C++相比，Go并不包括如<a href="https://zh.wikipedia.org/wiki/枚举">枚举</a>、<a href="https://zh.wikipedia.org/wiki/异常处理">异常处理</a>、<a href="https://zh.wikipedia.org/wiki/繼承_(計算機科學">继承</a>)、<a href="https://zh.wikipedia.org/wiki/泛型">泛型</a>、<a href="https://zh.wikipedia.org/wiki/斷言_(程式">断言</a>)、<a href="https://zh.wikipedia.org/wiki/虚函数">虚函数</a>等功能，但增加了 切片(Slice) 型、并发、管道、<a href="https://zh.wikipedia.org/wiki/垃圾回收_(計算機科學">垃圾回收功能</a>)、<a href="https://zh.wikipedia.org/wiki/介面_(資訊科技">接口</a>)等特性的语言级支持。Go 2.0版本将支持泛型<a href="https://zh.wikipedia.org/wiki/Go#cite_note-9">[9]</a>，对于<a href="https://zh.wikipedia.org/wiki/斷言_(程式">断言</a>)的存在，则持负面态度，同时也为自己不提供类型<a href="https://zh.wikipedia.org/wiki/繼承_(計算機科學">继承</a>)来辩护。</p>
<p>不同于<a href="https://zh.wikipedia.org/wiki/Java">Java</a>，Go原生提供了<a href="https://zh.wikipedia.org/wiki/关联数组">关联数组</a>（也称为<a href="https://zh.wikipedia.org/wiki/哈希表">哈希表</a>（Hashes）或字典（Dictionaries）），就像字符串类型一样。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2007年，<a href="https://zh.wikipedia.org/wiki/Google">Google</a>设计Go，目的在于提高在<a href="https://zh.wikipedia.org/wiki/多核心處理器">多核</a>、网络机器（networked machines）、大型<a href="https://zh.wikipedia.org/wiki/代码库">代码库</a>（codebases）的情况下的开发效率。当时在Google，设计师们想要解决其他语言使用中的缺点，但是仍保留他们的优点。</p>
<ul>
<li>静态类型和<a href="https://zh.wikipedia.org/wiki/运行时">运行时</a>效率。（如：<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>）</li>
<li>可读性和易用性。（如：<a href="https://zh.wikipedia.org/wiki/Python">Python</a> 和 <a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>）<a href="https://zh.wikipedia.org/wiki/Go#cite_note-12">[12]</a></li>
<li>高性能的网络和<a href="https://zh.wikipedia.org/wiki/多进程">多进程</a>。</li>
</ul>
<p>设计师们主要受他们之间流传的“不要像C++”启发。</p>
<p>Go于2009年11月正式宣布推出，<a href="https://zh.wikipedia.org/wiki/Go#cite_note-16">[16]</a>版本1.0在2012年3月发布。之后，Go广泛应用于Google的产品以及许多其他组织和开源项目。</p>
<p>在2016年11月，Go（一种<a href="https://zh.wikipedia.org/wiki/无衬线体">无衬线体</a>）和Go Mono 字体（一种<a href="https://zh.wikipedia.org/wiki/等宽字体">等宽字体</a>）分别由设计师 Charles Bigelow 和 Kris Holmes 发布。 两种字体均采用了 <a href="https://zh.wikipedia.org/w/index.php?title=WGL4&amp;action=edit&amp;redlink=1">WGL4</a> ，并且依照着 DIN 1450 标准，可清晰地使用了 large x-height 和 letterforms 。</p>
<p>在2018年8月，本地的图标更换了 。待描述完整 然而，Gopher mascot 仍旧命相同的名字。</p>
<p>在2018年8月，Go的主要贡献者发布了两个关于语言新功能的“草稿设计——<a href="https://zh.wikipedia.org/wiki/泛型">泛型</a> 和 <a href="https://zh.wikipedia.org/wiki/异常处理">异常处理</a>，同时寻求Go用户的反馈。Go 由于在1.x时，缺少对 <a href="https://zh.wikipedia.org/wiki/泛型">泛型</a>编程 的支持和冗长的 <a href="https://zh.wikipedia.org/wiki/异常处理">异常处理</a> 而备受批评。</p>
<p><strong>以上来自<a href="https://zh.wikipedia.org/wiki/Go#%E6%8F%8F%E8%BF%B0">wiki</a>,更多详情可查看</strong></p>
<h2 id="为什么需要学习Golang？"><a href="#为什么需要学习Golang？" class="headerlink" title="为什么需要学习Golang？"></a>为什么需要学习Golang？</h2><blockquote>
<p>“<a href="https://link.juejin.im/?target=https%3A%2F%2Ftwitter.com%2Ftobi%2Fstatus%2F326086379207536640">Go will be the server language of the future.</a>” — Tobias Lütke, Shopify</p>
</blockquote>
<h2 id="硬件的局限性"><a href="#硬件的局限性" class="headerlink" title="硬件的局限性"></a>硬件的局限性</h2><p><strong><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.investopedia.com%2Fterms%2Fm%2Fmooreslaw.asp">摩尔定律</a>正在失效。</strong></p>
<p>英特尔公司在 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.informit.com%2Farticles%2Farticle.aspx%3Fp%3D339073">2004 年推出</a>了第一款具有 3.0 GHz时钟速度的奔腾 4 处理器。如今，我的 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.apple.com%2Fmacbook-pro%2Fspecs%2F">2016款 MacBook Pro</a> 的时钟速度为 2.9 GHz。因此，差不多十年，原始处理能力都没有太多的增加。你可以在下图中看到处理能力的增长与时间的关系。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkficnh9qrj30go0bkwkn.jpg" alt=""></p>
<p>从上面的图表可以看出，单线程的性能和处理器的频率在近十年几乎保持稳定。如果你认为添加更多的晶体管是一种解决问题的方法，那你就错了。这是因为在微观尺度上，量子特性开始显现（例如：量子隧道穿越），放更多的晶体管代价也会越多(<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.quora.com%2FWhat-is-Quantum-Tunneling-Limit-How-does-it-limit-the-size-of-a-transistor">为什么？</a>)，而且，每美元可以添加晶体管的数量也开始下降。</p>
<p>所以，针对上述问题的解决方案如下：</p>
<ul>
<li>厂商开始向处理器添加越来越多的内核。如今，我们已经有四核和八核的 CPU 可用。</li>
<li>我们还引入了超线程技术。</li>
<li>为处理器添加更多的缓存以提升性能。</li>
</ul>
<p>但是，以上方案也有它们自身的限制。我们无法向处理器添加更多的缓存以提升性能，因为缓存具有物理限制：缓存越大，速度越慢。添加更多的内核到处理器也有它的成本。而且，这也无法无限扩展。这些多核处理器能同时运行多个线程，同时也能带来并发能力。我们稍后会讨论它。</p>
<p>因此，如果我们不能依赖于硬件的改进，唯一的出路就是找到一个高效的软件来提升性能，但遗憾的是，现代编程语言都不是那么高效。</p>
<blockquote>
<p>“现代处理器就像一辆有氮氧加速系统的直线竞速赛车，它们在直线竞速赛中表现优异。不幸的是，现代编程语言却像蒙特卡罗赛道，它们有大量的弯道。” - <a href="https://link.juejin.im/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDavid_Ungar">David Ungar</a></p>
</blockquote>
<h2 id="Go-天生支持并发"><a href="#Go-天生支持并发" class="headerlink" title="Go 天生支持并发"></a>Go 天生支持并发</h2><p>如上所述，硬件提供商正在向处理器添加更多的内核以提升性能。所有的数据中心都在这些处理器上运行，我们应该期待在未来几年内核数量的增长。更重要的是，如今的应用程序都是使用多个微服务来维持数据库的连接、消息队列和缓存的维护。因此，我们开发的软件和编程语言可以更容易的支持并发，并且它们应该随着内核数量的增长而可扩展。</p>
<p>但是大多数现代编程语言（如 Java、Python 等）都来自于 90 年代的单线程环境。这些语言大多数都支持多线程。但真正的问题是并发执行，线程锁、竞争条件和死锁。这些问题都使得很难在这些语言上创建一个多线程的应用程序。</p>
<p>例如，在 Java 中创建新的线程会消耗大量内存。因为每一个线程都会消耗大约 1 MB 大小的堆内存，如果你运行上千个线程，他们会对堆造成巨大的压力，最终会由于内存不足而宕机。此外，你想要在两个或者多个线程之间通信也是非常困难的。</p>
<p>另一方面，Go 于 2009 年发布，那时多核处理器已经上市了。这也是为什么 Go 是在考虑并发的基础上构建的。Go 用 goroutine 来替代线程，它们从堆中消耗了大约 2 KB 的内存。因此你可以随时启动上百万个 goroutine。</p>
<h2 id="Go-直接在底层硬件上运行"><a href="#Go-直接在底层硬件上运行" class="headerlink" title="Go 直接在底层硬件上运行"></a>Go 直接在底层硬件上运行</h2><p>与其他现代高级语言（如 Java/Python）相比，使用 C、C++ 的最大好处就是它的性能，因为 C/C++ 是编译型语言而不是解释型语言。</p>
<p>处理器能理解二进制文件。通常来说，当你编译一个用 Java 或者其他基于 JVM 的语言构建的应用程序，它将人类可读的代码编译为字节代码，这可以被 JVM 或者在底层操作系统之上运行的其他虚拟机所理解。当执行的时候，虚拟机解释这些字节码并且将他们转化为处理器能理解的二进制文件。</p>
<h2 id="用-Go-编写的代码易于维护"><a href="#用-Go-编写的代码易于维护" class="headerlink" title="用 Go 编写的代码易于维护"></a>用 Go 编写的代码易于维护</h2><p>我告诉你一件事，Go 没有像其他语言一样疯狂于编程语法，它的语法非常整洁。</p>
<p>Go 的的设计者在谷歌创建这门语言的时候就考虑到了这一点，由于谷歌拥有非常强大的代码库，成千上万的开发者都工作在相同的代码库上，代码应该易于其他开发者理解，一段代码应该对另一段代码有最小的影响。这些都会使得代码易于维护，易于修改。</p>
<p>Go 有意的忽视了许多现代面向对象语言的一些特性。</p>
<ul>
<li><strong>没有类。</strong> 所有代码都仅用 package 分开，Go 只有结构体而不是类。</li>
<li><strong>不支持继承。</strong> 这将使得代码易于修改。在其他语言中，如： Java/Python，如果类 ABC 继承类 XYZ 并且你在类 XYZ 中做了一些改动，那么这可能会在继承类 XYZ 的其他类中产生一些副作用。通过移除继承，Go 也使得理解代码变得很容易 <strong>（因为当你在看一段代码时不需要同时查看父类）</strong>。</li>
<li>没有构造方法。</li>
<li>没有注解。</li>
<li>没有泛型。</li>
<li>没有异常。</li>
</ul>
<p>以上这些改变使得 Go 与其他语言截然不同，这使得用 Go 编程与其他语言很不一样。你可能不喜欢以上的一些观点。但是，并不是说没有上述这些特性，你就无法对你的应用程序编码。你要做的就是多写几行代码，但从积极的一面，它将使你的代码更加清晰，为代码添加更多的清晰度。</p>
<h2 id="Go-来势汹汹"><a href="#Go-来势汹汹" class="headerlink" title="Go 来势汹汹"></a>Go 来势汹汹</h2><ul>
<li>我知道这不是一个直接的技术优势，但 Go 是由谷歌设计并支持的，谷歌拥有世界上最大的云基础设施之一，并且规模庞大。谷歌设计 Go 以解决可扩展性和有效性问题。这些是创建我们自己的服务器时都会遇到的问题。</li>
<li>Go 更多的也是被一些大公司所使用，如 Adobe、BBC、IBM，因特尔甚至是 <a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.engineering%2Fhow-medium-goes-social-b7dbefa6d413%23.r8nqjxjpk">Medium</a>。</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang函数初探</title>
    <url>/2020/11/21/Golang%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>本节将探讨golang 的函数部分</p>
<ul>
<li>函数的结构分析函数的定义</li>
<li>函数的层次</li>
<li>函数的作用域</li>
<li>匿名函数</li>
<li>立即执行函数</li>
<li>闭包</li>
</ul>
<h2 id="函数存在的意义"><a href="#函数存在的意义" class="headerlink" title="函数存在的意义"></a>函数存在的意义</h2><ul>
<li>函数是一段代码的封装</li>
<li>使用函数可以使结构更加清晰与简洁<a id="more"></a>
<h3 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h3></li>
</ul>
<p>函数存在的一个非常明显的作用和意义就是代码重用。没有代码重用，编程人员会被活活累死，费尽千辛万苦写出来的代码只能使用一次，有类似的功能需要完成时，不得不重头开始写起。</p>
<h3 id="有助于我们思考"><a href="#有助于我们思考" class="headerlink" title="有助于我们思考"></a>有助于我们思考</h3><p>在函数设计上有一个原则，叫做单一职能原则，意思是说，一个函数只完成一个特定的功能。我以冒泡排序来向你解释什么叫做到单一职能原则，并向你展示函数是如何帮助我们思考问题的。</p>
<h2 id="初探Golang函数"><a href="#初探Golang函数" class="headerlink" title="初探Golang函数"></a>初探Golang函数</h2><p>不知道你是否还记得我们写的第一个代码<code>HelloWorld</code>，来我们对他进行分析一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello，World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它由以下几部分构成：</p>
<ul>
<li><p>任何一个函数的定义，都有一个 func 关键字，用于声明一个函数，就像使用 var 关键字声明一个变量一样。</p>
</li>
<li><p>紧跟的 main 是函数的名字，命名符合 Go 语言的规范即可，不能以数字开头。</p>
</li>
<li><p>main 函数名字后面的一对括号 () 是不能省略的，括号里可以定义函数使用的参数，这里的 main 函数没有参数，所以是空括号 () 。</p>
</li>
<li><p>括号 () 后还可以有函数的返回值，因为 main 函数没有返回值，所以这里没有定义。</p>
</li>
<li><p>{} 函数体，你可以在函数体里书写代码，写该函数自己的业务逻辑。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main		<span class="comment">// 主函数入口，表面可执行文件。若不是main，则只能被调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>		<span class="comment">// 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 关键字定义函数，与Python中的def效果一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;		 <span class="comment">// main函数名（主函数）入口，括号中为形参。没有可不写</span></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>形参：即形式参数，只与内部调用有关。</p>
<p>当调用函数的时候，为位置为准，对应对应</p>
</blockquote>
<h2 id="初探函数"><a href="#初探函数" class="headerlink" title="初探函数"></a>初探函数</h2><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;你好，我叫Payne&quot;</span>) <span class="comment">// 你好，我叫Payne</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数，有返回值（有返回值必须在后面写上返回值类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值，则需要多个类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t2</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数，有返回值。同一类型可使用逗号隔开在最后写类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t3</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数:最显著的特征是没有函数名，可以使用变量来接受它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 在main 中使用a()即可调用此韩素</span></span><br><span class="line"><span class="keyword">var</span> a  = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t1() <span class="comment">// 调用函数</span></span><br><span class="line">	<span class="comment">// 返回值需要我们打印，才能显示出来</span></span><br><span class="line">	fmt.Println(t2()) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数结构分析"><a href="#函数结构分析" class="headerlink" title="函数结构分析"></a>函数结构分析</h3><p>由于main函数的定义并不利于理解golang的函数，那么我们自定义一个函数。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// num(1,2) 调用函数</span></span><br><span class="line">	fmt.Println(num(<span class="number">1</span>, <span class="number">2</span>))		<span class="comment">// 调用函数，并打印 2，1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">num</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	j, i = i, j</span><br><span class="line">	<span class="keyword">return</span> i, j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个参数与返回值的函数</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(params ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> params &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个参数,多个参数的内部其实就是切片类型[...]int</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果定义的函数需要传递的参数既有普通参数，也有可变参数，那么可变参数一定要放在参数列表的最后一个，比如 sum1(tip string,params …int) ，params 可变参数一定要放在最末尾。</p>
</blockquote>
<h3 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h3><p>全局与局部：（变量与常量）</p>
<blockquote>
<p>全局：故名思义，全局均可访问的函数</p>
<p>局部：故名思义，仅有局部才可访问的变量</p>
<p>代码块作用域：仅在此代码块中</p>
<p>二则的区分：全局变量常常直接在代码的函数部分的上面定义，而局部变量仅在函数中定义。且不可被函数外部的访问</p>
</blockquote>
<p>golang的寻找变量的方式体现可简单理解为<code>就近原则</code>；示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aA = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	aA := <span class="number">2</span></span><br><span class="line">	fmt.Println(aA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(aA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f1()    <span class="comment">// 2</span></span><br><span class="line">	f2()    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在函数f1中对变量<code>aA</code>，进行修改。而不影响全局的<code>aA</code>.且调用时先从函数内寻找，没有则往上。</p>
<p>不仅函数中有全局、局部的概念，例如循环中也有此概念</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func f1() &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">		fmt.Print(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f2() &#123;</span><br><span class="line">	j :&#x3D; 0</span><br><span class="line">	for ; j &lt; 10; j++ &#123;</span><br><span class="line">		fmt.Print(j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f1() </span><br><span class="line">	f2() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二者的区别为，变量<code>i</code>使用完成后会立马销毁，释放内存。而变量<code>j</code>，则会一直存在</p>
</blockquote>
<h3 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h3><h4 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h4><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add和sub都能赋值给calculation类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure>
<h4 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h4><p>我们可以声明函数类型的变量并且为该变量赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">	c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">	fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">	f := add                        <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of f:%T\n&quot;</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">	fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础指令</title>
    <url>/2020/11/21/Golang%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>无论多么复杂的程序，多么复杂的逻辑。基本是由以下三种构成(当然除非其原本业务逻辑客观复杂)</p>
<p>大道至简、速归同途，找到这种感觉。come on～</p>
<h2 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h2><h3 id="if-条件分支语句"><a href="#if-条件分支语句" class="headerlink" title="if 条件分支语句"></a>if 条件分支语句</h3><p>Golang条件语句是通过一条或多条语句的执行结果（True或者False）来决定是否执行的代码块。</p>
<p>Golang程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</p>
<p>Golang 编程中 if 语句用于控制程序的执行，基本形式为：<br><a id="more"></a><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i:= <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;<span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i&gt;3&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i&lt;=3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i&lt;=3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">3</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i &lt; 3&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i == 3&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i &gt; 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i == 3</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>关于 if 条件语句的使用规则：</p>
<ul>
<li><p>if 后面的条件表达式不需要使用 ()</p>
</li>
<li><p>每个条件分支（if 或者 else）中的大括号是必需的，哪怕大括号里只有一行代码（</p>
</li>
<li><p>if 紧跟的大括号 { 不能独占一行，else 前的大括号 } 也不能独占一行，否则会编译不通过。</p>
</li>
<li><p>在 if……else 条件语句中还可以增加多个 else if，增加更多的条件分支</p>
</li>
</ul>
</blockquote>
<h3 id="switch-选择语句"><a href="#switch-选择语句" class="headerlink" title="switch 选择语句"></a>switch 选择语句</h3><p>if 条件语句比较适合分支较少的情况，如果有很多分支的话，选择 switch 会更方便，比如以上示例，使用 switch 改造后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> i:=<span class="number">7</span>;&#123;</span><br><span class="line">	<span class="keyword">case</span> i&gt;<span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i&gt;10&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> i&gt;<span class="number">5</span> &amp;&amp; i&lt;=<span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;5&lt;i&lt;=10&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5&lt;i&lt;=10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 语句同样也可以用一个简单的语句来做初始化，同样也是用分号 ; 分隔。每一个 case 就是一个分支，分支条件为 true 该分支才会执行，而且 case 分支后的条件表达式也不用小括号 () 包裹。</p>
<p>在 Go 语言中，switch 的 case 从上到下逐一进行判断，一旦满足条件，立即执行对应的分支并返回，其余分支不再做判断。也就是说 Go 语言的 switch 在默认情况下，case 最后自带 break。这和其他编程语言不一样，比如 C 语言在 case 分支里必须要有明确的 break 才能退出一个 case。Go 语言的这种设计就是为了防止忘记写 break 时，下一个 case 被执行。</p>
</blockquote>
<p>那么如果你真的有需要，的确需要执行下一个紧跟的 case 怎么办呢？Go 语言也考虑到了，提供了 fallthrough 关键字。现在看个例子，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> j := <span class="number">1</span>; j &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">fallthrough</span>	 <span class="comment">// 执行下一个case(即case2)</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有匹配&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><p>循环，顾名思义，就是遵循一定规则循环往复的执行，golang中语法循环如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始值；运行范围；表达式 &#123;</span><br><span class="line">		执行语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// for循环示例1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"> <span class="comment">// for循环示例2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> ;i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请思考两个示例有何不同？提示：作用域</span></span><br></pre></td></tr></table></figure>
<p>下面是一个经典的 for 循环示例，从这个示例中，我们可以分析出 for 循环由三部分组成，其中，需要使用两个 ; 分隔，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++ &#123;</span><br><span class="line">		sum+=i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The sum is&quot;</span>,sum)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// The sum is 5050</span></span><br></pre></td></tr></table></figure>
<h3 id="高级for循环"><a href="#高级for循环" class="headerlink" title="高级for循环"></a>高级for循环</h3><p>如果你以前学过其他编程语言，可能会见到 while 这样的循环语句，在 Go 语言中没有 while 循环，但是可以通过 for 达到 while 的效果，如以下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum:=<span class="number">0</span></span><br><span class="line">i:=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;=<span class="number">100</span> &#123;</span><br><span class="line">    sum+=i</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The sum is&quot;</span>,sum)</span><br><span class="line"><span class="comment">// The sum is 5050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> ;i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在写循环时，一定需要先树立终止条件。避免写成死循环。他较于其他编程语言更能Kill掉你的电脑</p>
</blockquote>
<h2 id="continue-or-break"><a href="#continue-or-break" class="headerlink" title="continue or break"></a>continue or break</h2><blockquote>
<p>break:用于终止</p>
<p>continue:跳过</p>
<p>二者仅且适用于if或者for</p>
<p>场景一：打印1-9，当值为6点时打印并退出(这个可能会有点牵强，主要用于理解break)</p>
<p>场景2: 打印1-9，其中不输出7</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景二：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swith"><a href="#swith" class="headerlink" title="swith"></a>swith</h2><p>if 条件语句比较适合分支较少的情况，如果有很多分支的话，选择 switch 会更方便，比如以上示例，使用 switch 改造后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> i := <span class="number">20</span>; &#123;</span><br><span class="line">	<span class="keyword">case</span> i &gt; <span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i&gt;10&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> i &gt; <span class="number">5</span> &amp;&amp; i &lt;= <span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;5&lt;i&lt;=10&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i&gt;10</span></span><br></pre></td></tr></table></figure>
<p>switch 语句同样也可以用一个简单的语句来做初始化，同样也用分号 ; 分隔。每一个 case 就是一个分支，分支条件为 true 该分支才会执行，而且 case 分支后的条件表达式也不用小括号 () 包裹。</p>
<p>在 Go 语言中，switch 的 case 从上到下逐一进行判断，一旦满足条件，立即执行对应的分支并返回，其余分支不再做判断。也就是说 Go 语言的 switch 在默认情况下，case 最后自带 break。这和其他编程语言不一样，比如 C 语言在 case 分支里必须要有明确的 break 才能退出一个 case。Go 语言的这种设计就是为了防止忘记写 break 时，下一个 case 被执行。那么如果你真的有需要，的确需要执行下一个紧跟的 case 怎么办呢？Go 语言也考虑到了，提供了 fallthrough 关键字。如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> i:=<span class="number">1</span>;i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有匹配&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上示例运行会输出 1，如果省略 case 1: 后面的 fallthrough，则不会有任何输出。</p>
<p>不知道你是否可以发现，和上一个例子对比，这个例子的 switch 后面是有表达式的，也就是输入了 ;j，而上一个例子的 switch 后只有一个用于初始化的简单语句。</p>
<p>当 switch 之后有表达式时，case 后的值就要和这个表达式的结果类型相同，比如这里的 j 是 int 类型，那么 case 后就只能使用 int 类型，如示例中的 case 1、case 2。如果是其他类型，比如使用 case “a” ，会提示类型不匹配，无法编译通过。</p>
<p>而对于 switch 后省略表达式的情况，整个 switch 结构就和 if……else 条件语句等同了。</p>
<p>switch 后的表达式也没有太多限制，是一个合法的表达式即可，也不用一定要求是常量或者整数。你甚至可以像如下代码一样，直接把比较表达式放在 switch 之后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> <span class="number">2</span> &lt; <span class="number">1</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;2&gt;1&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;2&lt;=1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2&lt;=1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础数据类型</title>
    <url>/2020/11/21/Golang%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。<br><a id="more"></a></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p>整型分为以下两个大类：</p>
<blockquote>
<p>按长度分为：int8、int16、int32、int64<br>无符号整型：uint8、uint16、uint32、uint64</p>
<ul>
<li><code>uint8</code>就是我们熟知的<code>byte</code>型</li>
<li><code>int16</code>对应C语言中的<code>short</code>型，</li>
<li><code>int64</code>对应C语言中的<code>long</code>型。</li>
</ul>
</blockquote>
<p>取值范围如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">取值范围为您操作系统的位数字，如果是64位操作系统。为int64</td>
</tr>
<tr>
<td style="text-align:center">int8</td>
<td style="text-align:center">有符号 8位整型 ( 2^8 + 1 到 2^8 -1)[-255, 255]</td>
</tr>
<tr>
<td style="text-align:center">int16</td>
<td style="text-align:center">有符号 16位整型 ( 2^16 + 1 到 2^16 -1)[-65535, 6535]</td>
</tr>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">有符号 16位整型 ( 2^32 + 1 到 2^32 -1)[-4294967295, 4294967295]</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">有符号 16位整型 ( 2^64 + 1 到 2^64 -1)[-18446744073709551615, 18446744073709551615]</td>
</tr>
<tr>
<td style="text-align:center">uint</td>
<td style="text-align:center">取值范围为您操作系统的位数字，如果是64位操作系统。为int64</td>
</tr>
<tr>
<td style="text-align:center">uint8</td>
<td style="text-align:center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td style="text-align:center">uint16</td>
<td style="text-align:center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td style="text-align:center">uint32</td>
<td style="text-align:center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td style="text-align:center">uint64</td>
<td style="text-align:center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
</tbody>
</table>
</div>
<p>特殊整形</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uintptr	<span class="comment"># 无符号整型，用于存放一个指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>
<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>
</blockquote>
<p>数字字面量语法（Number literals syntax</p>
<blockquote>
<p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>
<ul>
<li><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 </p>
</li>
<li><p><code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 </p>
</li>
<li><p><code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>
</li>
</ul>
<p>我们可以用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。</p>
<p>这两种浮点型数据格式遵循<code>IEEE 754</code>标准： </p>
<p><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p>
<p> <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi)	<span class="comment">// 3.141593</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)	<span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>complex64和complex128</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">	c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line">	<span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">	c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">	fmt.Println(c1)</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Go语言中以<code>bool</code>类型进行声明布尔型数据</p>
<p>布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>布尔类型变量的默认值为<code>false</code>。</p>
</li>
<li><p>Go 语言中不允许将整型强制转换为布尔型.</p>
</li>
<li><p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。</p>
<p> Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 </p>
</blockquote>
<p>字符串的值为<code>双引号(&quot;&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">&quot;你好,nihao&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span> = <span class="string">&quot;Hello，你好&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’ ‘）包裹起来，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a :&#x3D; &#39;一&#39;</span><br><span class="line">var b :&#x3D; &#39;x&#39;</span><br></pre></td></tr></table></figure>
<p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello,世界&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 44(,) 228(ä) 184(¸) 150() 231(ç) 149() 140() </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 44(,) 19990(世) 30028(界) </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
</blockquote>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">	byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">	byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">	s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">	runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">	runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">// &quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span>		<span class="comment">// 内建包，提供类型检查函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(a))	<span class="comment">// int64</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T&quot;</span>, a) <span class="comment">// int64</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="string">&quot;a&quot;</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(b)) <span class="comment">// string</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T&quot;</span>, b)            <span class="comment">// string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflect.TypeOf()	源码示例</span></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Type(表达式)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Type表示目标转换类型。表达式包括变量、复杂算子和函数返回值等.</span></span><br></pre></td></tr></table></figure>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数字类型之间，可以通过强制转换的方式，如以下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	i :&#x3D; 10</span><br><span class="line">	f64 :&#x3D; 10.102</span><br><span class="line">	i2f:&#x3D;float64(i)</span><br><span class="line">	f2i:&#x3D;int(f64)</span><br><span class="line">	f3 :&#x3D; float64(f2i)</span><br><span class="line">	fmt.Println(i2f,f2i, f3) &#x2F;&#x2F; 10 10 10</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种使用方式比简单，采用“类型（要转换的变量）”格式即可。采用强制转换的方式转换数字类型，可能会丢失一些精度，比如浮点型转为整型时，小数点部分会全部丢失.</p>
<p>把变量转换为相应的类型后，就可以对相同类型的变量进行各种表达式运算和赋值了。</p>
<h4 id="字符串和数字互转"><a href="#字符串和数字互转" class="headerlink" title="字符串和数字互转"></a>字符串和数字互转</h4><p>Go 语言是强类型的语言，也就是说不同类型的变量是无法相互使用和计算的，这也是为了保证Go 程序的健壮性，所以不同类型的变量在进行赋值或者计算前，需要先进行类型转换。涉及类型转换的知识点非常多，这里我先介绍这些基础类型之间的转换</p>
<p>以字符串和数字互转这种最常见的情况为例，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Age       <span class="keyword">int</span></span><br><span class="line">	Name, sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">10</span></span><br><span class="line">	<span class="comment">// 通过包 strconv 的 Itoa 函数可以把一个 int 类型转为 string，Atoi 函数则用来把 string 转为 int。</span></span><br><span class="line">	i2s:=strconv.Itoa(i)</span><br><span class="line"></span><br><span class="line">	s2i,err:=strconv.Atoi(i2s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fmt.Println(i2s,s2i,err)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;i2s: type:%T, value:%v\n&quot;</span>, i2s, i2s)  <span class="comment">// i2s: type:string, value:10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s2i: type:%T, value:%v, err:%v&quot;</span>, s2i, s2i, err)  <span class="comment">// s2i: type:int, value:10, &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="占位的相关用法"><a href="#占位的相关用法" class="headerlink" title="占位的相关用法"></a>占位的相关用法</h3><p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。Python中的print等</p>
<h4 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%v</td>
<td style="text-align:center">相应值的默认格式。</td>
</tr>
<tr>
<td style="text-align:left">%+v</td>
<td style="text-align:center">打印结构体时，会添加字段名</td>
</tr>
<tr>
<td style="text-align:left">%#v</td>
<td style="text-align:center">相应值的Go语法表示</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:center">相应值的类型的Go语法表示</td>
</tr>
<tr>
<td style="text-align:left">%%</td>
<td style="text-align:center">字面上的百分号，并非值的占位符</td>
</tr>
<tr>
<td style="text-align:left">布尔占位符 (%t)</td>
<td style="text-align:center">true 或 false</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Age       <span class="keyword">int</span></span><br><span class="line">	Name, sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := Human&#123;Name: <span class="string">&quot;Payne&quot;</span>, Age: <span class="number">20</span>, sex: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, people)  <span class="comment">// &#123;20 Payne male&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v&quot;</span>, people) <span class="comment">// &#123;20 Payne male&#125;&#123;Age:20 Name:Payne sex:male&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v&quot;</span>, people) <span class="comment">// &#123;20 Payne male&#125;&#123;Age:20 Name:Payne sex:male&#125;main.Human&#123;Age:20, Name:&quot;Payne&quot;, sex:&quot;male&quot;&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T&quot;</span>, people)  <span class="comment">// main.Human</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;%%&quot;)  // main.Humanß</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:center">二进制表示</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">八进制表示</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">十进制表示</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">十六进制表示(小写)</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">十六进制表示(大写)</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">有小数点而无指数，例如 123.456浮点数</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">相应Unicode码点所表示的字符</td>
</tr>
<tr>
<td style="text-align:center">%q</td>
<td style="text-align:center">单引号围绕的字符字面值，由Go语法安全地转义</td>
</tr>
<tr>
<td style="text-align:center">%U</td>
<td style="text-align:center">Unicode格式：U+1234，等同于 “U+%04X”</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义十进制变量a</span></span><br><span class="line">	<span class="comment">//a := 542</span></span><br><span class="line">	<span class="comment">// 数字</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot; Binary: %d,\n Octal: %o,\n Decimal:%d,\n Hex: %x,\n Uppercase_hexadecimal:%X&quot;, a, a, a, a, a)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 Binary: 542,</span></span><br><span class="line"><span class="comment">	 Octal: 1036,</span></span><br><span class="line"><span class="comment">	 Decimal:542,</span></span><br><span class="line"><span class="comment">	 Hex: 21e,</span></span><br><span class="line"><span class="comment">	 Uppercase_hexadecimal:21E</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c&quot;</span>, <span class="number">0x3E2E</span>) <span class="comment">// 㸮</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="number">0x3E2E</span>) <span class="comment">// &#x27;㸮&#x27;</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">100.1000201</span>)     <span class="comment">// 100.100020</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.1f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.3f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.4f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.1000</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数和复数的组成部分（实部和虚部）"><a href="#浮点数和复数的组成部分（实部和虚部）" class="headerlink" title="浮点数和复数的组成部分（实部和虚部）"></a>浮点数和复数的组成部分（实部和虚部）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">科学计数法，例如 -1234.456e+78</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">科学计数法，例如 -1234.456E+78</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td style="text-align:center">%G</td>
<td style="text-align:center">根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := math.Pow(<span class="number">20</span>, <span class="number">3</span>) <span class="comment">// 8000</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, a) <span class="comment">// 8.000000e+03</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, a) <span class="comment">// 8.000000E+03</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, <span class="number">10.20</span>)    <span class="comment">// 10.2</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, <span class="number">10.20</span>+<span class="number">2i</span>) <span class="comment">// (10.2+2i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:center">输出字符串表示（string类型或[]byte)</td>
<td style="text-align:center">Printf(“%s”, []byte(“Go语言”))</td>
<td style="text-align:center">Go语言</td>
</tr>
<tr>
<td style="text-align:left">%q</td>
<td style="text-align:center">双引号围绕的字符串，由Go语法安全地转义</td>
<td style="text-align:center">Printf(“%q”, “Go语言”)</td>
<td style="text-align:center">“Go语言”</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:center">十六进制，小写字母，每字节两个字符</td>
<td style="text-align:center">Printf(“%x”, “golang”)</td>
<td style="text-align:center">676f6c616e67</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:center">十六进制，大写字母，每字节两个字符</td>
<td style="text-align:center">Printf(“%X”, “golang”)</td>
<td style="text-align:center">676F6C616E67</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F;a :&#x3D; &quot;golang编程语言&quot;</span><br><span class="line">	fmt.Printf(&quot;%s\n&quot;, []byte(a))     &#x2F;&#x2F; golang编程语言</span><br><span class="line">	fmt.Printf(&quot;%q\n&quot;, []byte(a))     &#x2F;&#x2F; golang编程语言</span><br><span class="line">	fmt.Printf(&quot;%x\n&quot;, []byte(a))     &#x2F;&#x2F; 676f6c616e67e7bc96e7a88be8afade8a880</span><br><span class="line">	fmt.Printf(&quot;%X\n&quot;, []byte(a))     &#x2F;&#x2F; 676F6C616E67E7BC96E7A88BE8AFADE8A880</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-指针"><a href="#6-指针" class="headerlink" title="6)指针"></a>6)指针</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:center">十六进制表示，前缀 0x</td>
<td style="text-align:center">Printf(“%p”, &amp;people)</td>
<td style="text-align:center">0x4f57f0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 地址值</span></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> b []<span class="keyword">int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)    <span class="comment">// 0xc000014080</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)    <span class="comment">// 0xc0000a6020</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>Strings 包<br>讲到基础类型，尤其是字符串，不得不提 Go SDK 为我们提供的一个标准包 strings。它是用于处理字符串的工具包，里面有很多常用的函数，帮助我们对字符串进行操作，比如查找字符串、去除字符串的空格、拆分字符串、判断字符串是否有某个前缀或者后缀等。掌握好它，有利于我们的高效编程。</p>
<p>以下代码是我写的关于 strings 包的一些例子，你自己可以根据<a href="https://golang.google.cn/pkg/strings/">strings 文档</a>或者$GOPATH/src/stringls.go.以及自己写一些示例，多练习熟悉它们。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">	<span class="comment">//判断s1的前缀是否是H</span></span><br><span class="line">	fmt.Println(strings.HasPrefix(s1,<span class="string">&quot;H&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">	<span class="comment">//在s1中查找字符串o</span></span><br><span class="line">	fmt.Println(strings.Index(s1,<span class="string">&quot;o&quot;</span>))     <span class="comment">// 4</span></span><br><span class="line">	<span class="comment">//把s1全部转为大写</span></span><br><span class="line">	fmt.Println(strings.ToUpper(s1))              <span class="comment">// HELLO WORLD</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// s1 中是否包含某一个或一段字符串</span></span><br><span class="line">	fmt.Println(strings.Contains(s1, <span class="string">&quot;ee &quot;</span>)) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(strings.Contins(s1, <span class="string">&quot;e&quot;</span>))   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang常量-变量-匿名变量</title>
    <url>/2020/11/21/Golang%E5%B8%B8%E9%87%8F-%E5%8F%98%E9%87%8F-%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>常量：一旦声明即不可被改变</p>
<p>变量：声明后可以发生改变。若初始化后未赋值则为初始值</p>
<p>例如：</p>
<p>int -&gt; 0</p>
<p>Bool -&gt; false</p>
<p>String -&gt; 空</p>
</blockquote>
<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。<br><a id="more"></a><br>关键字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line">   <span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line">   <span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line">   <span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line">   <span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
<p>保留字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  </span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h3><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p>
<blockquote>
<p>相当于开辟相对应的内存，并对此内存取了个别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 申请一块内存，把字符串hello放进去</span></span><br><span class="line">并它的地址为指向变量名 a</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名 类型</span><br><span class="line"><span class="comment">// 类型推到声明，必须有初始值， 否则声明失败</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = 值</span><br><span class="line"><span class="comment">// 简短声明（必须在函数中）</span></span><br><span class="line">变量名 := 值</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量声明(多用于全局变量声明)，类型为必须</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> 	变量名 类型</span><br><span class="line">  	变量名 类型</span><br><span class="line">  	变量名 类型</span><br><span class="line">  。。。</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 同类型批量声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名<span class="number">1</span>，变量名<span class="number">2</span>，变量名<span class="number">3</span> 类型</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	变量名<span class="number">1</span>,</span><br><span class="line">	变量名<span class="number">2</span>, </span><br><span class="line">	变量名<span class="number">3</span> <span class="keyword">string</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短批量声明 注意必须在函数中</span></span><br><span class="line">变量名<span class="number">1</span>,变量名<span class="number">2</span>, 变量名<span class="number">3</span> := 值<span class="number">1</span>，值<span class="number">2</span>， 值<span class="number">3</span> </span><br></pre></td></tr></table></figure>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推到声明</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x <span class="keyword">string</span></span><br><span class="line">	y <span class="keyword">string</span></span><br><span class="line">	j <span class="keyword">bool</span></span><br><span class="line">	k <span class="keyword">byte</span></span><br><span class="line">	z <span class="keyword">int</span></span><br><span class="line">	</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 同类型批量声明</span></span><br><span class="line"><span class="keyword">var</span> a, b, c, d <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 简短声明</span></span><br><span class="line">	hobby := <span class="string">&quot;programming&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试输入</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Name is :&quot;</span>, name) <span class="comment">// Name is : Payne</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Age is :&quot;</span>, age)	<span class="comment">// Age is : 20</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hobby &quot;</span>, hobby)	<span class="comment">// hobby  programming</span></span><br><span class="line">	fmt.Print(a)	<span class="comment">// 0 声明未赋值采用初始值。int 类型初始值为0</span></span><br><span class="line">	<span class="comment">// 批量简短声明</span></span><br><span class="line">	a, b := <span class="number">1</span>, <span class="string">&quot;string&quot;</span></span><br><span class="line">	fmt.Print(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><blockquote>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p>
</blockquote>
<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里可能会有点绕，仅仅是为了使用“_”，而使用_</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span>  <span class="string">&quot;payne&quot;</span>, <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name, _ := foo()</span><br><span class="line">	_, age := foo()</span><br><span class="line">	fmt.Println(<span class="string">&quot;name=&quot;</span>, name) <span class="comment">//name= payne</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;age=&quot;</span>, age)	<span class="comment">//age= 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：</p>
<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>
</blockquote>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量与变量的声明基本一致，类型一致。若有声明变化的话那就是将关键字<code>var</code>， 替换成了<code>const</code>.增加了<code>iota</code>，减少了简短声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量声明声明时必须给值，否则则定义失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">const</span> 变量名 类型 = 值</span><br><span class="line"><span class="comment">// 类型推导</span></span><br><span class="line"><span class="keyword">const</span> 变量名  = 值</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(b) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Iota"><a href="#Iota" class="headerlink" title="Iota"></a>Iota</h3><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `iota`在const关键字出现时将被重置为0,请牢记！！</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用_跳过某些值</span></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_</span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="comment">// iota声明中间插队</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="常量与变量的对比示例"><a href="#常量与变量的对比示例" class="headerlink" title="常量与变量的对比示例"></a>常量与变量的对比示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要体现为 变量可以被修改</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	fmt.Println(a)	<span class="comment">// 1</span></span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">	fmt.Println(a)	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">const</span> b = <span class="number">3</span></span><br><span class="line">	fmt.Println(b) <span class="comment">// 3</span></span><br><span class="line">	b = <span class="number">4</span></span><br><span class="line">	fmt.Print(b)	<span class="comment">// Error: cannot assign to b</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的初探"><a href="#函数的初探" class="headerlink" title="函数的初探"></a>函数的初探</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参)</span> <span class="params">(返回值类型)</span></span> &#123;</span><br><span class="line">	表达式</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名(实参)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式（匿名函数）</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	表达式</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名(实参)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名立即执行函数</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	表达式</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 此时的函数为结果的值</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的调用的顺序"><a href="#函数的调用的顺序" class="headerlink" title="函数的调用的顺序"></a>函数的调用的顺序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">	fmt.Print(a) <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考：</p>
<p>为什么打印的是2？</p>
<p>原因为<code>函数</code>参数的调用采用<code>就近的原则</code></p>
</blockquote>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发编程</title>
    <url>/2020/12/06/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="单个goroutine"><a href="#单个goroutine" class="headerlink" title="单个goroutine"></a>单个goroutine</h2><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。<br><a id="more"></a><br>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。开启一个goroutine，示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> funciton()</span><br></pre></td></tr></table></figure>
<p>是不是很简单呢？那我们在实际中使用一下，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是 demo goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> demo1()</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是 main goroutine&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我是 demo goroutine</span></span><br><span class="line"><span class="comment">// 我是 main goroutine</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>细心的伙伴坑定发现了<code>time.Sleep(time.Second)</code>，在这里并不仅仅是为睡一秒，还有进类似于等待执行的作用。如果没有    time.Sleep(time.Second)，你会发现 <strong>我是 demo goroutine</strong>，将不会被打印。</p>
<p>首先为什么会先打印<code>我是 main goroutine</code>，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
</blockquote>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>多个goroutine的时候该怎么办呢？难道是这样？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是 demo goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo1()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是 main goroutine&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这样确实可行的，但之间的相互通信，以及    time.Sleep(time.Second)该怎么去掉，不可能为了这个所为的并发而强制去睡一秒吧，这也并不现实。其实我们可以使用channel（通道）来解决这个问题</p>
<h3 id="channel的定义"><a href="#channel的定义" class="headerlink" title="channel的定义"></a>channel的定义</h3><p>在 Go 语言中，声明一个 channel 非常简单，使用内置的 make 函数即可，如下所示：</p>
<blockquote>
<p>无缓冲 channel,使用 make 创建的 chan 就是一个无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
</blockquote>
<p>其中 chan 是一个关键字，表示是 channel 类型。后面的 string 表示 channel 里的数据是 string 类型。通过 channel 的声明也可以看到，chan 是一个集合类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ch:&#x3D;make(chan type)</span><br><span class="line">&#x2F;&#x2F; type 为传递的类型，由传递值的类型决定</span><br></pre></td></tr></table></figure>
<p>定义好 chan 后就可以使用了，一个 chan 的操作只有两种：发送和接收。</p>
<p>接收：获取 chan 中的值，操作符为 &lt;- chan。</p>
<p>发送：向 chan 发送值，把值放在 chan 中，操作符为 chan &lt;-。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="string">&quot;goroutine 执行完成&quot;</span></span><br><span class="line">	&#125;()</span><br><span class="line">	v := &lt;-ch</span><br><span class="line">	fmt.Printf(<span class="string">&quot;管道ch接受到的值为%v, 类型为%T&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道ch接受到的值为goroutine 执行完成, 类型为string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意发送和接收的操作符，都是 &lt;- ，只不过位置不同。接收的 &lt;- 操作符在 chan 的左侧，发送的 &lt;- 操作符在 chan 的右侧。</p>
</blockquote>
<p>这样我就实现了最基本的协程</p>
<h4 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h4><p>有缓冲 channel 类似一个可阻塞的队列，内部的元素先进先出。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel，如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChCache:&#x3D;make(chan int,10)</span><br></pre></td></tr></table></figure>
<p>在这里我们创建了一个容量为 10 的 channel，内部的元素类型是 int，也就是说这个 channel 内部最多可以存放 10个类型为 int 的元素</p>
<p>有缓冲 channel 具备以下特点：</p>
<ul>
<li><p>有缓冲 channel 的内部有一个缓冲队列；</p>
</li>
<li><p>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</p>
</li>
<li><p>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素。</p>
</li>
</ul>
<p>我创建了一个容量为 5 的 channel，内部的元素类型是 int，也就是说这个 channel 内部最多可以存放 5 个类型为 int 的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		value := &lt;-ch</span><br><span class="line">		fmt.Printf(<span class="string">&quot;这次接受ch的值为:%v, 第%d接收\n&quot;</span>, value, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这次接受ch的值为:0, 第1接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:1, 第2接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:2, 第3接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:3, 第4接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:4, 第5接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:5, 第6接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:6, 第7接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:7, 第8接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:8, 第9接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:9, 第10接收</span></span><br></pre></td></tr></table></figure>
<p>通过内置函数 cap 可以获取 channel 的容量，也就是最大能存放多少个元素，通过内置函数 len 可以获取 channel 中元素的个数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;ch的容量:&quot;</span>, <span class="built_in">cap</span>(ch), <span class="string">&quot;ch长度为:&quot;</span>, <span class="built_in">len</span>(ch))</span><br></pre></td></tr></table></figure>
<p>以上我们都是定义的双向chan，可以取也可以存。那让我们继续深入学习</p>
<h4 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h4><p>单向 channel 的声明也很简单，只需要在声明的时候带上 &lt;- 操作符即可，如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单向channel(只存)</span><br><span class="line">onlySendChan :&#x3D; make(chan&lt;- int)</span><br><span class="line">&#x2F;&#x2F; 单向channel(只取)</span><br><span class="line">onlyReceiveChan:&#x3D;make(&lt;-chan int)</span><br></pre></td></tr></table></figure>
<h4 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h4><p>当我们需要关闭channel的时候，我们可以使用内置的Close函数即可关闭</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Close(channel)</span><br></pre></td></tr></table></figure>
<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<p>不难看出channel的坑比较多，一不小心就会写出一个bug。常见情况总结如下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glaz73x65uj31bs0iiqfn.jpg" alt=""></p>
<h3 id="多协程-worker-pool（goroutine池）"><a href="#多协程-worker-pool（goroutine池）" class="headerlink" title="多协程-worker pool（goroutine池）"></a>多协程-worker pool（goroutine池）</h3><p>在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。</p>
<p>一个简易的work pool示例代码如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;worker:%d start job:%d\n&quot;</span>, id, j)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;worker:%d end job:%d\n&quot;</span>, id, j)</span><br><span class="line">		results &lt;- j * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="comment">// 开启3个goroutine</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5个任务</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	<span class="comment">// 输出结果</span></span><br><span class="line">	<span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">		&lt;-results</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>假设要从网上下载一个文件，启动 3 个 goroutine 进行下载，并把结果发送到 3 个 channel 中。哪个先下载好，就会使用哪个 channel 的结果。</p>
<p>在这种情况下，如果我们尝试获取第一个 channel 的结果，程序就会被阻塞，无法获取剩下两个 channel 的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在 Go 语言中，通过 select 语句可以实现多路复用，其语句格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">				<span class="comment">//todo  1</span></span><br><span class="line"><span class="keyword">case</span> i2 &lt;- c2:</span><br><span class="line">				<span class="comment">//todo	2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// default todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构和 switch 非常像，都有 case 和 default，只不过 select 的 case 是一个个可以操作的 channel。</p>
<blockquote>
<p>多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadFile</span><span class="params">(chanName <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//随机time.Sleep,模拟下载文件</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> chanName + <span class="string">&quot;:filePath&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//声明三个存放结果的channel</span></span><br><span class="line">	<span class="comment">//firstCh := make(chan string)</span></span><br><span class="line">	<span class="comment">//secondCh := make(chan string)</span></span><br><span class="line">	<span class="comment">//threeCh := make(chan string)</span></span><br><span class="line">	firstCh, secondCh, threeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">//同时开启3个goroutine下载</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		firstCh &lt;- downloadFile(<span class="string">&quot;firstCh&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		secondCh &lt;- downloadFile(<span class="string">&quot;secondCh&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		threeCh &lt;- downloadFile(<span class="string">&quot;threeCh&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//开始select多路复用，哪个channel能获取到值，</span></span><br><span class="line">	<span class="comment">//就说明哪个最先下载好，就用哪个。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filePath := &lt;-firstCh:</span><br><span class="line">		fmt.Println(filePath)</span><br><span class="line">	<span class="keyword">case</span> filePath := &lt;-secondCh:</span><br><span class="line">		fmt.Println(filePath)</span><br><span class="line">	<span class="keyword">case</span> filePath := &lt;-threeCh:</span><br><span class="line">		fmt.Println(filePath)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发深入了解</title>
    <url>/2020/12/06/Golang%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="协程控制需要"><a href="#协程控制需要" class="headerlink" title="协程控制需要"></a>协程控制需要</h2><p>重学编程之Golang的plan中的上一篇文章我向大家介绍了，<code>并发编程基础</code>，<code>goroutine的创建</code>，<code>channel</code>，正由于go语言的简洁性,我们可以简易快速的创建任意个协程。同时也留下了许多隐患，如果没有更加深入的学习，其实很难直接将其运用到实际项目中，实际生活中。为什么呢？并发的场景许许多多，但一味的只知道其创建，是很难有效的解决问题。例如以下场景-资源竞争<br><a id="more"></a><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 公共资源</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//防止提前退出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许你的期望值是1000,可惜结果总会差强人意，造成其终究原因是资源竞争，也就是当<code>goroutine1</code>与<code>goroutineN</code>多次执行了同一步骤</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gldr8ifn5pj31aa0ti7al.jpg" style="zoom:25%;" /><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gldr9uujd0j31dn0u0n4z.jpg" style="zoom:25%;" /></p>
<h2 id="协程控制原理与实现"><a href="#协程控制原理与实现" class="headerlink" title="协程控制原理与实现"></a>协程控制原理与实现</h2><p>协程的控制原理基本是就是加各种锁，防止<code>意外</code>发送，牺牲无序的高速，带来相对有序正确执行。例如<code>互斥锁、读写锁、等等</code></p>
<h3 id="同任务唯一执行-互斥锁"><a href="#同任务唯一执行-互斥锁" class="headerlink" title="同任务唯一执行-互斥锁"></a>同任务唯一执行-互斥锁</h3><p><strong>互斥锁</strong>（英语：Mutual exclusion，缩写 Mutex）是一种用于<a href="https://bk.tw.lvfukeji.com/baike-多线程">多线程</a><a href="https://bk.tw.lvfukeji.com/baike-编程">编程</a>中，防止两条<a href="https://bk.tw.lvfukeji.com/baike-线程">线程</a>同时对同一公共资源（比如<a href="https://bk.tw.lvfukeji.com/baike-全域變數">全局变量</a>）进行读写的机制。该目的通过将代码切片成一个一个的<a href="https://bk.tw.lvfukeji.com/baike-临界区域">临界区域</a>（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
<p>例如：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。</p>
<p>在golang里面实现互斥锁也非常的粗暴，简单可分为三步，声明互斥锁，加锁、执行业务代码、释放锁、下一次执行步骤。更深入理解可参考<a href="https://bk.tw.lvfukeji.com/wiki/%E4%BA%92%E6%96%A5%E9%94%81">wiki互斥锁</a>，示例如下</p>
<p>示例一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	sum <span class="keyword">int</span>		<span class="comment">// 全局资源sum</span></span><br><span class="line">	mutex sync.Mutex		<span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock()		<span class="comment">// 加锁</span></span><br><span class="line">	sum += i				<span class="comment">// 执行业务代码</span></span><br><span class="line">	mutex.Unlock()	<span class="comment">// 释放锁，进行下一步骤</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//防止提前退出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例二：当我们的业务代码不再是如此简单，可能会忘记释放互斥锁，而造成BUG，我们可以借助<code>defer</code>关键字，以免忘记</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	sum <span class="keyword">int</span>		<span class="comment">// 全局资源sum</span></span><br><span class="line">	mutex sync.Mutex		<span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//防止提前退出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，<strong>唤醒的策略是随机的</strong>。</p>
<h3 id="读多写少、读少写多-读写锁"><a href="#读多写少、读少写多-读写锁" class="headerlink" title="读多写少、读少写多-读写锁"></a>读多写少、读少写多-读写锁</h3><p>现在我们解决了多个 goroutine 同时读写的资源竞争问题，但是又遇到另外一个问题——性能。因为每次读写共享资源都要加锁，所以性能低下。</p>
<p>这个特殊场景的出现，有以下几种情况：</p>
<ol>
<li>写的时候不能同时读，因为这个时候读取的话可能读到脏数据（不正确的数据）；</li>
<li>读的时候不能同时写，因为也可能产生不可预料的结果；</li>
<li>读的时候可以同时读，因为数据不会改变，所以不管多少个 goroutine 读都是并发安全的。</li>
</ol>
<p>所以就可以通过读写锁 sync.RWMutex 来优化这段代码，提升性能。现在我将以上示例改为读写锁，来实现我们想要的结果，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	sum <span class="keyword">int</span> <span class="comment">// 全局资源sum</span></span><br><span class="line">	mutex sync.Mutex		<span class="comment">// 互斥锁</span></span><br><span class="line">	mutexRW sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处为写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 互斥锁</span></span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加了一个读取的函数，便于演示并发读业务场景</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//只获取读锁</span></span><br><span class="line">	mutexRW.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mutexRW.RUnlock()</span><br><span class="line">	b := sum</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启 1000个</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> fmt.Println(<span class="string">&quot;和为:&quot;</span>, readSum())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 防止提前退出</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高效率决策完成时间-WaitGroup"><a href="#高效率决策完成时间-WaitGroup" class="headerlink" title="高效率决策完成时间-WaitGroup"></a>高效率决策完成时间-WaitGroup</h3><p>相信你注意到了这段 time.Sleep(2 * time.Second) 代码，这是为了防止主函数 main 返回使用，一旦 main 函数返回了，程序也就退出了。因为我们不知道 10000 个执行 add 的协程和 10 个执行 readSum 的协程什么时候完全执行完毕，所以设置了一个比较长的等待时间。</p>
<p>但在实际的项目，如果运行一个较大的业务，需要运行的时间，我们无法预估，且并不合理。那我们该如何解决它？其实我们可以使用<code>WaitGroup</code>来进行阻塞主程序，防止退出。在这里相当实现了一个<code>生产者</code>与<code>消费者</code>模型</p>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	sum     <span class="keyword">int</span>          <span class="comment">// 全局资源sum</span></span><br><span class="line">	mutex   sync.Mutex   <span class="comment">// 互斥锁</span></span><br><span class="line">	mutexRW sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line">	round =  <span class="keyword">int</span>(math.Pow(<span class="number">100</span>, <span class="number">2</span>)) + <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 互斥锁</span></span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//只获取读锁</span></span><br><span class="line">	mutexRW.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mutexRW.RUnlock()</span><br><span class="line">	b := sum</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line">	<span class="comment">//round =  int(math.Pow(100, 2)) + 100</span></span><br><span class="line">	wg.Add(round)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">//计数器值减1</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			add(<span class="number">10</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(math.Pow(<span class="number">100</span>, <span class="number">2</span>)); i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">//计数器值减1</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(<span class="string">&quot;和为:&quot;</span>, readSum())</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ul>
<li><p>在这里的生产者<code>round</code>与总消费者的和必须相等。</p>
</li>
<li><p><code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
</li>
</ul>
</blockquote>
<h3 id="执行且只执行一次协程单例-sync-Once"><a href="#执行且只执行一次协程单例-sync-Once" class="headerlink" title="执行且只执行一次协程单例-sync.Once"></a>执行且只执行一次协程单例-sync.Once</h3><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// *备注：如果要执行的函数`f`需要传递参数就需要搭配闭包来使用。*</span></span><br></pre></td></tr></table></figure>
<h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">		<span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">		loadIcons()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">	icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">	icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">	icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">	icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> （</span><br><span class="line">	icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image </span><br><span class="line">	loadIconsOnce sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">		<span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">		<span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">	loadIconsOnce.Do(loadIcons)</span><br><span class="line">	<span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发安全的单例"><a href="#并发安全的单例" class="headerlink" title="并发安全的单例"></a>并发安全的单例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明协程单例</span></span><br><span class="line">	<span class="keyword">var</span> once sync.Once</span><br><span class="line">	onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Only Once Do&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立搞并发场景</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 实现仅实现一次</span></span><br><span class="line">			once.Do(onceBody)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doOnce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协控制随心所欲-sync-Cond"><a href="#协控制随心所欲-sync-Cond" class="headerlink" title="协控制随心所欲-sync.Cond"></a>协控制随心所欲-sync.Cond</h3><p>在 Go 语言中，sync.WaitGroup 用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<p>而 sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<p>sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。</p>
<p>sync.Cond 有三个方法，它们分别是：</p>
<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>下面我们以 10 个人赛跑为例来演示 sync.Cond 的用法。在这个示例中有一个裁判，裁判要先等这 10 个人准备就绪，然后一声发令枪响，这 10 个人就可以开始跑了，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cond :=sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">11</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span>  wg.Done()</span><br><span class="line">			fmt.Println(num,<span class="string">&quot;号已经就位&quot;</span>)</span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">			fmt.Println(num,<span class="string">&quot;号开始跑……&quot;</span>)</span><br><span class="line">			cond.L.Unlock()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line">	time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span>  wg.Done()</span><br><span class="line">		fmt.Println(<span class="string">&quot;裁判已经就位，准备发令枪&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;比赛开始～&quot;</span>)</span><br><span class="line">		cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//防止函数提前返回退出</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	race()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			set(key, n)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n)</span><br><span class="line">			value, _ := m.Load(key)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发编程初探</title>
    <url>/2020/12/06/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="基本概念了解："><a href="#基本概念了解：" class="headerlink" title="基本概念了解："></a>基本概念了解：</h2><h3 id="并发与并行：-略偏向于多线-进程方面"><a href="#并发与并行：-略偏向于多线-进程方面" class="headerlink" title="并发与并行：(略偏向于多线 / 进程方面)"></a>并发与并行：(略偏向于多线 / 进程方面)</h3><ul>
<li>并发： 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</li>
<li>并行： 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的<a id="more"></a>
<h3 id="阻塞与非阻塞：（略偏向于协程-异步方向）"><a href="#阻塞与非阻塞：（略偏向于协程-异步方向）" class="headerlink" title="阻塞与非阻塞：（略偏向于协程 / 异步方向）"></a>阻塞与非阻塞：（略偏向于协程 / 异步方向）</h3></li>
</ul>
<ul>
<li><p>阻塞：阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。</p>
</li>
<li><p>非阻塞：程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的</p>
</li>
</ul>
<h3 id="同步与异步："><a href="#同步与异步：" class="headerlink" title="同步与异步："></a>同步与异步：</h3><ul>
<li>同步：不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。</li>
<li>异步：为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。</li>
</ul>
<ul>
<li><strong>多线程（英语：multithreading）</strong>：指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。在一个程序中，这些独立运行的程序片段叫作 “线程”（Thread），利用它编程的概念就叫作 “多线程处理（Multithreading）”</li>
<li><strong>多进程 (Multiprocessing):</strong> 每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程.</li>
<li><strong>二者的区别：</strong>线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约 CPU 时间，发挥利用，根据具体<a href="https://baike.baidu.com/item/情况">情况</a>而定。线程的运行中需要使用计算机的<a href="https://baike.baidu.com/item/内存">内存</a>资源和 CPU。</li>
<li><strong>协程 (Coroutine):</strong> 又称微线程、纤程，协程是一种用户态的轻量级线程。 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</li>
</ul>
<h2 id="Go并发编程"><a href="#Go并发编程" class="headerlink" title="Go并发编程"></a>Go并发编程</h2><p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。相比线程来说，协程更加轻量，一个程序可以随意启动成千上万个 goroutine。</p>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>
<h4 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h4><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。<br>另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang介绍</title>
    <url>/2020/11/21/Golang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>Go 语言开发包</p>
<p>国外：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p>国内(推荐)： <a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>编辑器</p>
<ul>
<li>Golang:<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a> </li>
<li>Visual Studio Code: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> </li>
</ul>
</blockquote>
<p>搭建 Go 语言开发环境，需要先下载 Go 语言开发包。<br><a id="more"></a></p>
<h3 id="查看操作系统及版本"><a href="#查看操作系统及版本" class="headerlink" title="查看操作系统及版本"></a>查看操作系统及版本</h3><p>Windows：<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvrumlwpj31fk0m70x2.jpg" alt=""></p>
<p>Mac:</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvxbp6hmj317i0d21b8.jpg" alt=""></p>
<p>Linux:</p>
<p>终端输入<code>uname -a</code>,示例如下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfw129kelj31qe03c0uw.jpg" alt=""><br><!--more--></p>
<h3 id="Golang语言开发包"><a href="#Golang语言开发包" class="headerlink" title="Golang语言开发包"></a>Golang语言开发包</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvdmu9zsj31au0u0ap5.jpg" alt="Golang开发包"></p>
<p>MSI 安装的方式比较简单推荐使用</p>
<p>Windows 系统上推荐使用这种方式。现在的操作系统基本上都是 64 位的，所以选择 64 位的 go1.15.windows-amd64.msi 下载即可，如果操作系统是 32 位的，选择 go1.15.windows-386.msi 进行下载。</p>
<p>下载后双击该 MSI 安装文件，按照提示一步步地安装即可。在默认情况下，Go 语言开发工具包会被安装到 c:\Go 目录，你也可以在安装过程中选择自己想要安装的目录。</p>
<p>假设安装到 c:\Go 目录，安装程序会自动把 c:\Go\bin 添加到你的 PATH 环境变量中，如果没有的话，你可以通过系统 -&gt; 控制面板 -&gt; 高级 -&gt; 环境变量选项来手动添加。示例如下</p>
<ul>
<li>进入</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfwha3s32j31fk0kw77n.jpg" alt=""></p>
<ul>
<li>配置</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfwhx99dij30uu0huwfx.jpg" alt=""></p>
<h3 id="macOS-下安装"><a href="#macOS-下安装" class="headerlink" title="macOS 下安装"></a>macOS 下安装</h3><p>如果你的操作系统是 macOS，可以采用 PKG 安装包。下载 <code>go1.15.darwin-amd64.pkg</code> 后，双击按照提示安装即可。安装成功后，路径<code>/usr/local/go/bin</code> 应该已经被添加到了 PATH 环境变量中。</p>
<p>如果没有的话，你可以手动添加，把如下内容添加到 /etc/profile 或者 $HOME/.profile 文件保存即可。命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure>
<p>BrewHome安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># brewHome安装</span></span><br><span class="line">brew install golang</span><br></pre></td></tr></table></figure>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>保护管理工具安装</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum(Centos)</span></span><br><span class="line">sudo yum -y update <span class="comment"># 更新yum</span></span><br><span class="line">sudo yum install -y golang</span><br><span class="line"><span class="comment"># apt(ubantu)</span></span><br><span class="line">sudo apt -y update</span><br><span class="line">sudo apt install -y golang</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩包安装(安装前请查看操作系统版本)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd 版本</span></span><br><span class="line">wget https://golang.google.cn/dl/go1.15.4.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># arm版本</span></span><br><span class="line">https://golang.google.cn/dl/go1.15.4.linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压(amd)</span></span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span>/ -xzvf go1.15.4.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span>/ -xzvf go1.15.4.linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量配置</span></span><br><span class="line"><span class="comment"># sudo vim /etc/profile</span></span><br><span class="line"> <span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"> <span class="built_in">export</span> GOPATH=/home/bruce/go</span><br><span class="line"> <span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br><span class="line"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="comment"># 环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>GOROOT</code>设置golang开发包的安装位置，我们解压到了<code>/usr/local/</code>目录，该目录下的<code>go/</code>文件夹一定是go的环境的根目录，就是打开<code>go</code>目录后别再有一个<code>go/</code>目录。</p>
<p><code>GOBIN</code>目录是执行 <code>go install</code> 后生成可执行文件的目录</p>
<p><code>GOPATH</code>是我们的工作目录，一般我们设置到用户目录下，这个要根据你电脑的实际情况去配置。在介绍一下go的工作目录结构。在我们设置的工作目录下有3个子目录</p>
</blockquote>
<h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 任意目录下输入go version</span></span><br><span class="line">go version go1.15.2 darwin/amd64</span><br><span class="line"><span class="comment"># 查看环境配置</span></span><br><span class="line">go env</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go env</span></span><br><span class="line">GO111MODULE=<span class="string">&quot;on&quot;</span></span><br><span class="line">GOARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOBIN=<span class="string">&quot;&quot;</span></span><br><span class="line">GOCACHE=<span class="string">&quot;/Users/stringle-004/Library/Caches/go-build&quot;</span></span><br><span class="line">GOENV=<span class="string">&quot;/Users/stringle-004/Library/Application Support/go/env&quot;</span></span><br><span class="line">GOEXE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">GOHOSTARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOHOSTOS=<span class="string">&quot;darwin&quot;</span></span><br><span class="line">GOINSECURE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOMODCACHE=<span class="string">&quot;/Users/stringle-004/go/pkg/mod&quot;</span></span><br><span class="line">GONOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GONOSUMDB=<span class="string">&quot;&quot;</span></span><br><span class="line">GOOS=<span class="string">&quot;darwin&quot;</span></span><br><span class="line">GOPATH=<span class="string">&quot;/Users/stringle-004/go&quot;</span></span><br><span class="line">GOPRIVATE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;https://goproxy.cn,direct&quot;</span></span><br><span class="line">GOROOT=<span class="string">&quot;/usr/local/go&quot;</span>		<span class="comment"># golang开发包的安装位置</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line">GOTMPDIR=<span class="string">&quot;&quot;</span></span><br><span class="line">GOTOOLDIR=<span class="string">&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;</span></span><br><span class="line">GCCGO=<span class="string">&quot;gccgo&quot;</span></span><br><span class="line">AR=<span class="string">&quot;ar&quot;</span></span><br><span class="line">CC=<span class="string">&quot;clang&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;clang++&quot;</span></span><br><span class="line">CGO_ENABLED=<span class="string">&quot;1&quot;</span></span><br><span class="line">GOMOD=<span class="string">&quot;/Users/stringle-004/go/src/github.com/payne/awesomeProject/go.mod&quot;</span></span><br><span class="line">CGO_CFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_FFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">PKG_CONFIG=<span class="string">&quot;pkg-config&quot;</span></span><br><span class="line">GOGCCFLAGS=<span class="string">&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/sb/__n99hm13ms08lkk2lv5pxj40000gn/T/go-build659271527=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p>
<p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p>
<p>可以执行下面的命令修改GOPROXY：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p>Go 语言开发工具包的另一强大功能就是可以跨平台编译。什么是跨平台编译呢？</p>
<p>就是在 macOS 开发，可以编译 Linux、Window 等平台上的可执行程序，这样你开发的程序，就可以在这些平台上运行。也就是说，你可以选择喜欢的操作系统做开发，并跨平台编译成需要发布平台的可执行程序即可。</p>
<p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li><p>GOOS：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</p>
</li>
<li><p>GOARCH：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</p>
</li>
</ul>
<p>这样通过组合不同的 GOOS 和 GOARCH，就可以编译出不同的可执行程序。比如我现在的操作系统是 macOS AMD64 的，我想编译出 Linux AMD64 的可执行程序，只需要执行 go build 命令即可，如以下代码所示：</p>
<p>关于 GOOS 和 GOARCH 更多的组合，参考官方文档的 $GOOS and $GOARCH 这一节即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOOS&#x3D;linux GOARCH&#x3D;amd64 go build &#x2F;Users&#x2F;stringle-004&#x2F;go&#x2F;main.go</span><br></pre></td></tr></table></figure>
<p>关于 GOOS 和 GOARCH 更多的组合，参考<a href="https://golang.org/doc/install/source#environment">官方文档</a>的 $GOOS and $GOARCH 这一节即可</p>
<h2 id="Go-编辑器"><a href="#Go-编辑器" class="headerlink" title="Go 编辑器"></a>Go 编辑器</h2><p>第一款是 Visual Studio Code + Go 扩展插件，可以让你非常高效地开发，通过<a href="https://code.visualstudio.com/">官方网站</a>下载所对应操作系统版本的Visual Studio Code。</p>
<ul>
<li>安装：略（进入官网，下载安装即可）</li>
<li>Visual Studio Code + Go设置</li>
</ul>
<h4 id="安装中文简体插件"><a href="#安装中文简体插件" class="headerlink" title="安装中文简体插件"></a>安装中文简体插件</h4><p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>
<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！</p>
<p><code>VSCode</code>主界面介绍：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc8ujjej30y80lcgok.jpg" alt=""></p>
<h4 id="安装go扩展"><a href="#安装go扩展" class="headerlink" title="安装go扩展"></a>安装go扩展</h4><p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc5nin1j30y80pw0xy.jpg" alt=""></p>
<h4 id="安装中文简体插件-1"><a href="#安装中文简体插件-1" class="headerlink" title="安装中文简体插件"></a>安装中文简体插件</h4><p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>
<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc0dxgxg30xq0ppngg.gif" alt=""></p>
<p>第二款是老牌 IDE 公司 JetBrains 推出的 Goland，所有插件已经全部集成，更容易上手，并且功能强大，新手老手都适合，你可以通过官方网站 <a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a> 下载使用。</p>
<h2 id="第一个Golang程序"><a href="#第一个Golang程序" class="headerlink" title="第一个Golang程序"></a>第一个Golang程序</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">package main			<span class="comment"># 可执行文件必须为package main开头</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span>			<span class="comment"># 导入“fmt”包，用于打印（fmt.Print（打印）、fmt.Println（换行打印）、fmt.Printf(格式化打印)等）</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;			<span class="comment"># 主函数main</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;你好，我叫payne&quot;</span>)		<span class="comment"># 输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 你好，我叫payne</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang指针-pointer</title>
    <url>/2020/11/21/Golang%E6%8C%87%E9%92%88-pointer/</url>
    <content><![CDATA[<p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>
<p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。<br><a id="more"></a></p>
<h2 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h2><blockquote>
<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<p>比如，“永远不要高估自己”这句话，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p>
<p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p>
</blockquote>
<p>取变量指针的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>v:代表被取地址的变量，类型为<code>T</code></li>
<li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li>
</ul>
</blockquote>
<p>注意：<code>&amp;</code>仅对基本类型适用基本类型(包含int\bool\string，不包含数组、切片等),<code>fmt.printf(%p)</code>使用于所有类型。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := &amp;a     <span class="comment">// &amp; 取地址值操作</span></span><br><span class="line">	c := *b     <span class="comment">// * 根据地址值取值操作</span></span><br><span class="line">	fmt.Println(a, reflect.TypeOf(a))  <span class="comment">// 10 int</span></span><br><span class="line">	<span class="comment">// 每次的地址值不一定，若打印出0x开头的即成功获取到该变量地址值</span></span><br><span class="line">	fmt.Println(b, reflect.TypeOf(b))  <span class="comment">// 0xc000014080 *int</span></span><br><span class="line">	fmt.Println(c, reflect.TypeOf(c))  <span class="comment">// 10 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>
</blockquote>
<h2 id="Make-or-New"><a href="#Make-or-New" class="headerlink" title="Make or New"></a>Make or New</h2><p>导入</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b[<span class="string">&quot;Payne&quot;</span>] = <span class="number">10</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码会引发panic，为什么呢？ </p>
<p>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</p>
<p>而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
</blockquote>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type表示类型，new函数只接受一个参数，这个参数是一个类型</span></span><br><span class="line"><span class="comment">// *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">	fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">		a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">		*a = <span class="number">10</span></span><br><span class="line">		fmt.Println(*a)  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。</p>
</blockquote>
<h3 id="new与make的同与异"><a href="#new与make的同与异" class="headerlink" title="new与make的同与异"></a>new与make的同与异</h3><ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang运算符</title>
    <url>/2020/11/21/Golang%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>本章目标：</p>
<ul>
<li>了解运算符、运算符的种类、各运算符的特征</li>
<li>进制</li>
<li>位运算符及位运算</li>
<li>运算符优先级</li>
</ul>
</blockquote>
<h2 id="什么是运算符"><a href="#什么是运算符" class="headerlink" title="什么是运算符"></a>什么是运算符</h2><p>运算符用于执行程序代码运算，会针对一个以上操作数项目来进行<a href="https://baike.baidu.com/item/运算/5866856">运算</a>。例如：2+3，其<a href="https://baike.baidu.com/item/操作数/7658270">操作数</a>是2和3，而运算符则是“+”。</p>
<p>在vb2005中运算符大致可以分为5种类型：<a href="https://baike.baidu.com/item/算术运算符/9324947">算术运算符</a>、<a href="https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/2786163?fr=aladdin">位运算符</a>、 <a href="https://baike.baidu.com/item/关系运算符/352774">关系运算符</a>、<a href="https://baike.baidu.com/item/赋值运算符/2482721">赋值运算符</a>、<a href="https://baike.baidu.com/item/逻辑运算符/4123505">逻辑运算符</a>。<br><a id="more"></a></p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">相加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">相减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">相乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">相除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">求余</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;a 加 b = %d\n&quot;</span>, a + b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a 减 b = %d\n&quot;</span>, a - b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a 乘 b = %d\n&quot;</span>, a * b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a 除 b = %d\n&quot;</span>, a / b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a == b?&quot;,  a == b)         // a == b? false</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a != b?&quot;,  a != b)         // a != b? true</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a &gt;  b?&quot;,  a &gt; b )         // a &gt;  b? true</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a &gt;= b?&quot;,  a &gt;= b)         // a &gt;= b? false</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a &lt;  b?&quot;,  a &lt; b )         // a &gt;= b? true</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;a &lt;= b?&quot;,  a &lt;= b )        // a &lt;= b? true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td></td>
<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a &amp;&amp; b ?&quot;</span>, a &amp;&amp; b)      <span class="comment">// a &amp;&amp; b ? false</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a || b ?&quot;</span>, a || b)      <span class="comment">// a || b ? true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;  !a ?&quot;</span>, !a)            <span class="comment">//  !a ? false</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;  !b ?&quot;</span>, !b)            <span class="comment">//  !b ? true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="常见进制："><a href="#常见进制：" class="headerlink" title="常见进制："></a>常见进制：</h3><ul>
<li><p>二进制：只有 0 和 1，Go语言中不能直接使用二进制表示整数；</p>
</li>
<li><p>八进制：0-7，以数字 0 开头；</p>
</li>
<li><p>十进制：0-9；</p>
</li>
<li><p>十六进制：0-9 以及 A-F，以 0X 开头，A-F 以及 X 不区分大小写。</p>
</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	<span class="comment">// 二进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,a)    <span class="comment">// 1010</span></span><br><span class="line">	<span class="comment">// 八进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%o\n&quot;</span>,a)    <span class="comment">// 12</span></span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>,a)    <span class="comment">// 10</span></span><br><span class="line">	<span class="comment">// 十六进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>,a)    <span class="comment">// a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意进制转换为十进制</p>
<p>二进制转十进制：从最低位开始，每个位上数乘以 2 的位数减 1 次方然后求和。</p>
<p>1011 = 1<em>20 + 1</em>21 + 0<em>22 + 1</em>23 = 11</p>
<p>八进制转十进制：从最低位开始，每个位上数乘以 8 的位数减 1 次方然后求和。</p>
<p>0123 = 3<em>80 + 2</em>81 + 1<em>82 + 0</em>83 = 83</p>
<h3 id="其他进制互转："><a href="#其他进制互转：" class="headerlink" title="其他进制互转："></a>其他进制互转：</h3><ul>
<li>二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可；</li>
<li>二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可；</li>
<li>八进制转换二进制：将八进制数每 1 位转换成一个 3 位的二进制数（首位 0 除外）；</li>
<li>十六进制转二进制：将十六进制每 1 位转换成对应的一个 4 位的二进制数即可。</li>
</ul>
<h3 id="反码补码"><a href="#反码补码" class="headerlink" title="反码补码"></a>反码补码</h3><p>对于有符号数而言，二进制的最高为是符号位：0 表示正数，1 表示负数。</p>
<p>短除法进行进制转变</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj31dvdq2j30no0f6wks.jpg" alt=""></p>
<p><code>十进制</code>的10-&gt; 二进制：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj392vw2zj30o00fi441.jpg" alt=""></p>
<p><code>二进制</code>的1011 -&gt; 十进制</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj3cnxtifj30o00ba786.jpg" alt=""></p>
<p>想要详细了解其原理的可以参考<a href="https://baike.baidu.com/item/%E7%9F%AD%E9%99%A4%E6%B3%95/3640958?fr=aladdin">短除法</a>相关说明</p>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>
</div>
<p>XOR - 异或：相同为0，不同为1.也可用“进位加法”来理解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = X</span><br><span class="line">x ^ <span class="number">1</span>s = ~x  # <span class="number">1</span>s = ~ <span class="number">0</span></span><br><span class="line">x ^ (~x) = <span class="number">1</span>s </span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line">c = a ^ b  =&gt; a ^ c = b, b ^c = a # 交换两数</span><br><span class="line">a ^ b ^ c = a ^(b ^ c) = (a ^ b) ^c # associative</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定未知的位运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将x最右边的n位请零： x &amp; (~<span class="number">0</span> &lt;&lt; n )</span><br><span class="line"><span class="number">2.</span> 获取x的第n位值（<span class="number">0</span> 或 <span class="number">1</span>）： （x &gt;&gt; n）&amp; <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 获取x的第n位的幂值：x &amp; （<span class="number">1</span> &lt;&lt; n）</span><br><span class="line"><span class="number">4.</span> 仅将第n位置为 <span class="number">1</span>： x | (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line"><span class="number">5.</span> 仅将第n位置为<span class="number">0</span>：x &amp; （~<span class="number">1</span>（<span class="number">1</span> &lt;&lt; n））</span><br><span class="line"><span class="number">6.</span> 将x最高位至第n位(含)清零：x &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实战位运算要点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断奇偶性</span></span><br><span class="line">x % <span class="number">2</span> == <span class="number">1</span> - &gt; (x &amp; <span class="number">1</span>) == <span class="number">1</span>	</span><br><span class="line">x &amp; <span class="number">2</span> == <span class="number">0</span> -&gt; (x&amp;<span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"> <span class="comment">// 清零最低位的1</span></span><br><span class="line">x = x &amp; (x - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 得到最低位的1</span></span><br><span class="line">x &amp; ~x </span><br><span class="line">x &amp; ~ x = &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>为了更清晰的观察其变化，我们使用二进制来进行演示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">13</span>, <span class="number">21</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;a:%b &amp; %b = %b\n&quot;</span>, a, b, a &amp; b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a:%b | %b = %b\n&quot;</span>, a, b, a | b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a:%b ^ %b = %b\n&quot;</span>, a, b, a ^ b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a:%b ^ %b = %b\n&quot;</span>, a, b, a ^ b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 左移</span></span><br><span class="line">		<span class="comment">// 二进制表示</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b &lt;&lt; %b = %b\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&lt;&lt;<span class="number">2</span>) <span class="comment">// 10 &lt;&lt; 10 = 1000</span></span><br><span class="line">		<span class="comment">// 十进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d &lt;&lt; %d = %d\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&lt;&lt;<span class="number">2</span>) <span class="comment">// 2 &lt;&lt; 2 = 8</span></span><br><span class="line">	<span class="comment">// 右移</span></span><br><span class="line">		<span class="comment">// 二进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b &gt;&gt; %b = %b\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&gt;&gt;<span class="number">2</span>) <span class="comment">// 10 &gt;&gt; 10 = 0</span></span><br><span class="line">		<span class="comment">// 十进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d &gt;&gt; %d = %d\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&gt;&gt;<span class="number">2</span>) <span class="comment">// 2 &gt;&gt; 2 = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">相加后再赋值</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">相减后再赋值</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">相乘后再赋值</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">相除后再赋值</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">求余后再赋值</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;=</td>
<td style="text-align:center">左移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;=</td>
<td style="text-align:center">右移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&amp;=</td>
<td style="text-align:center">按位与后赋值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">=</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td style="text-align:center">^=</td>
<td style="text-align:center">按位异或后赋值</td>
</tr>
</tbody>
</table>
</div>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>运算符优先级确定表达式中的分组。这会影响表达式的计算方式。某些运算符比其他运算符具有更高的优先级; 例如，乘法运算符比加法运算符有更高的优先级。</p>
<p>当同级别的运算符出现在同一个表达式中，从左到右的顺序计算，比如乘除一起，不管是乘在前面还是除在前面都是从左到右计算乘、除运算符。加减亦是如此。</p>
<p>例如：<code>x = 7 + 3 * 2</code>; 这里，计算结果<code>x</code>被分配<code>13</code>，而不是<code>20</code>，因为运算符 <code>*</code>具有比<code>+</code>有更的优先级，所以它首先乘以<code>3 * 2</code>，然后加上<code>7</code>。</p>
<p>这里，具有最高优先级的运算符放在表的顶部，具有最低优先级的运算符出现在底部。 在表达式中，将首先计算较高优先级运算符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后缀</td>
<td style="text-align:center">()[]-&gt;.++ —</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">一元</td>
<td style="text-align:center">+ -!~++ —(type)*&amp;sizeof</td>
<td style="text-align:center">右到左</td>
</tr>
<tr>
<td style="text-align:center">乘法</td>
<td style="text-align:center">*/ %</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">加法</td>
<td style="text-align:center">+ -</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">移位</td>
<td style="text-align:center">&lt;&lt;&gt;&gt;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">关系</td>
<td style="text-align:center">&lt;&lt;=&gt;&gt;=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">相等</td>
<td style="text-align:center">==!=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位AND</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位XOR</td>
<td style="text-align:center">^</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位OR</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>左到右</td>
</tr>
<tr>
<td style="text-align:center">逻辑AND</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">逻辑OR</td>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td></td>
<td>左到右</td>
</tr>
<tr>
<td style="text-align:center">条件</td>
<td style="text-align:center">?:</td>
<td style="text-align:center">右到左</td>
</tr>
<tr>
<td style="text-align:center">分配</td>
<td style="text-align:center">=+=-=*=/= %=&gt;&gt;= &lt;&lt;= &amp;= ^= \</td>
<td style="text-align:center">=</td>
<td>右到左</td>
</tr>
<tr>
<td style="text-align:center">逗号</td>
<td style="text-align:center">,</td>
<td style="text-align:center">左到右</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang初识结构体</title>
    <url>/2020/11/21/Golong%E5%88%9D%E8%AF%86%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现<code>面向对象</code>的相关概念。<br><a id="more"></a></p>
<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type和struct关键字来定义结构体</span></span><br><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义需注意</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型</li>
</ul>
<p>具体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	male <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有相同类型的时候，我们还可以将相同类型的变量名使用“,”分割，写在一起。如下</span></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name,male <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个的自定义类型<code>person</code>，它有<code>name</code>、<code>male</code>、<code>age</code>三个字段，分别表示姓名、性别和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和性别等，本质上是一种聚合型的数据类型</p>
<p>将前面的融汇贯通，整点复合型的东东，搞起</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt=<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name MyString</span><br><span class="line">	age MyInt</span><br><span class="line">	male <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义了之后，咱们还需要进行初始化，才能使用。</p>
<h3 id="结构体初始化与基本使用"><a href="#结构体初始化与基本使用" class="headerlink" title="结构体初始化与基本使用"></a>结构体初始化与基本使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name MyString</span><br><span class="line">	age  MyInt</span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, sex <span class="keyword">string</span></span><br><span class="line">	age       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="keyword">var</span> p1 Person1</span><br><span class="line">	p.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">	p.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">	p.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	p1.name = <span class="string">&quot;Tim&quot;</span></span><br><span class="line">	p1.sex = <span class="string">&quot;female&quot;</span></span><br><span class="line">	p1.age = <span class="number">23</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p, p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p1, p1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v&quot;</span>, p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type:main.Person,value:{Payne 20 male}<br>main.Person{name:”Payne”, age:20, sex:”male”}<br>Type:main.Person1,value:{Tim female 23}<br>main.Person1{name:”Tim”, sex:”female”, age:23}</p>
</blockquote>
<p>通过以上示例我们知道，它是通过<code>.</code>，来一个一个的进行赋值</p>
<p>当然我们也是可以通过键值对对形式，从而进行批量赋值的，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1 := Person1&#123;</span><br><span class="line">	name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">	age:  <span class="number">20</span>,</span><br><span class="line">	sex:  <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T, value:%#v&quot;</span>, p1, p1)</span><br></pre></td></tr></table></figure>
<h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person2 <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">		age  <span class="keyword">int</span></span><br><span class="line">		sex  <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	person2.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">	person2.age = <span class="number">20</span></span><br><span class="line">	person2.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, person2, person2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type:struct &#123; name string; age int; sex string &#125;,value:&#123;Payne 20 male&#125;</span></span><br><span class="line"><span class="comment">// struct &#123; name string; age int; sex string &#125;&#123;name:&quot;Payne&quot;, age:20, sex:&quot;male&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="指针类型结构体"><a href="#指针类型结构体" class="headerlink" title="指针类型结构体"></a>指针类型结构体</h3><p>通过使用<code>new</code>关键字堆结构体初始化，得到的是结构体的地址值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	gender <span class="keyword">string</span></span><br><span class="line">	hobby  <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p3 = <span class="built_in">new</span>(person3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type:%T, Vlue:%v&quot;</span>, p3, p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是地址值，那么我们也是可以使用<code>&amp;</code>对他进行运算等操作的，相当于new</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	gender <span class="keyword">string</span></span><br><span class="line">	hobby  []<span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p3 := &amp;person3&#123;&#125;</span><br><span class="line">	p3.name = <span class="string">&quot;payne&quot;</span></span><br><span class="line">	p3.gender = <span class="string">&quot;sex&quot;</span></span><br><span class="line">	p3.hobby = []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	p3.age = <span class="number">20</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>p3.name = &quot;payne&quot;</code>其实在底层是<code>(*p3).name = &quot;payne&quot;</code>，这是Go语言帮我们实现的语法糖。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型</p>
<p>借用结构体构造函数，实现<code>类</code>的概念，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person5 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClass</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">person5</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person5&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p5 := newClass(<span class="string">&quot;payne&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value:%#v&quot;</span>, p5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(谁能调用我？-接收者)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回类型)</span></span> &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="keyword">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := &amp;Dog&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">&quot;aw&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	d1.wang() <span class="comment">//aw会汪汪汪~</span></span><br><span class="line">	d1.move() <span class="comment">//aw会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>Golang传递参数，永远是拷贝。也就是说，在函数内部改变其值，仅仅在内部生效。若想在某一函数中改变其全局的值。需要使用指针</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群搭建</title>
    <url>/2021/02/07/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>其实本节的文章我在很久之前就已经发过了一次，但不够详细，层次不轻。我今天部署的时候看的够呛(虽然也是部署成功了)，也算是对以前的坑，做个忏悔吧。本文可能会比较boring，但请相信这并不是我的本意。这一定是最精简的笔记之一，相信我这绝对不是混水。</p>
<p>本文主要分三大部分，他们分别是系统初始化、安装docker、安装Kubernetes，测试验证与删库跑路<br><a id="more"></a></p>
<h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><blockquote>
<p>请注意后面的单词all，代表所有(master、node)</p>
<p>Master：仅在master上</p>
<p>node: 仅在node上</p>
</blockquote>
<h4 id="关闭防火墙-all"><a href="#关闭防火墙-all" class="headerlink" title="关闭防火墙(all)"></a>关闭防火墙(<code>all</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 临时关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">## 永久关闭</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">## 验证防火墙是否关闭</span></span><br><span class="line">systemctl status firewalld </span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne8fmrrrpj31cw0h6dl3.jpg" alt=""></p>
<h4 id="关闭selinux-all"><a href="#关闭selinux-all" class="headerlink" title="关闭selinux(all)"></a>关闭selinux(<code>all</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment"># 永久</span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="关闭swap-all"><a href="#关闭swap-all" class="headerlink" title="关闭swap(all)"></a>关闭swap(<code>all</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="comment"># 永久</span></span><br><span class="line">sed  -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一条命令完成所有</span></span><br><span class="line">systemctl stop firewalld &amp;&amp; setenforce 0 &amp;&amp; swapoff -a &amp;&amp; systemctl status firewalld </span><br></pre></td></tr></table></figure>
<h4 id="设置主机名称-all"><a href="#设置主机名称-all" class="headerlink" title="设置主机名称(all)"></a>设置主机名称(<code>all</code>)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置名称(k8s-m-1)忽略大写字母</span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line"># 验证</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure>
<h4 id="时间同步-All"><a href="#时间同步-All" class="headerlink" title="时间同步(All)"></a>时间同步(<code>All</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y ntpdate  &amp;&amp; ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h4 id="在Master添加Hostname-master"><a href="#在Master添加Hostname-master" class="headerlink" title="在Master添加Hostname(master)"></a>在<code>Master</code>添加Hostname(<code>master</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">masterIp master</span></span><br><span class="line"><span class="string">node1Ip node1</span></span><br><span class="line"><span class="string">node2Ip node2</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.50.182	 master</span></span><br><span class="line"><span class="string">192.168.50.252   node</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证，此时<code>ping node</code>， 看是否能ping通</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne92s7tj7j31800ge41c.jpg" alt=""></p>
<h4 id="将桥接的IPV4-流量传递到iptables的链-all"><a href="#将桥接的IPV4-流量传递到iptables的链-all" class="headerlink" title="将桥接的IPV4 流量传递到iptables的链(all)"></a>将桥接的IPV4 流量传递到iptables的链(<code>all</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><h4 id="删除docker-可选"><a href="#删除docker-可选" class="headerlink" title="删除docker(可选)"></a>删除docker(可选)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can use scripts for one click installation，You may need to type enter at the end</span></span><br><span class="line"><span class="comment"># remove docker </span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="comment"># Set up repository</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">wget https:/mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum -y install docker-18.06.1.ce-3.e17</span><br></pre></td></tr></table></figure>
<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use Aliyun Docker</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># install docker from yum</span></span><br><span class="line">yum install  -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment"># cat version </span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置镜像加速</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://etdea28s.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># reload</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="comment"># 配置开启自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># start docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><strong>验证docker镜像加速</strong></p>
<p>在终端上输入<code>docker info</code>,效果图如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne9v1z6acj30ks03q3yn.jpg" alt=""></p>
<p>完成～</p>
<h3 id="安装Kubernetes"><a href="#安装Kubernetes" class="headerlink" title="安装Kubernetes"></a>安装Kubernetes</h3><h4 id="配置阿里镜像源-all"><a href="#配置阿里镜像源-all" class="headerlink" title="配置阿里镜像源(all)"></a>配置阿里镜像源(all)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="安装-kubectl-kubelet-kubeadm-all"><a href="#安装-kubectl-kubelet-kubeadm-all" class="headerlink" title="安装 kubectl kubelet kubeadm(all)"></a>安装 kubectl kubelet kubeadm(<code>all</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install kubectl kubelet kubeadm</span></span><br><span class="line">yum install -y kubectl kubelet kubeadm --disableexcludes=kubernetes</span><br><span class="line"><span class="comment">#--disableexcludes=kubernetes  禁掉除了这个之外的别的仓库</span></span><br><span class="line"><span class="comment"># set boot on opening computer</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h4 id="kubeadm初始化-Master"><a href="#kubeadm初始化-Master" class="headerlink" title="kubeadm初始化(Master)"></a>kubeadm初始化(<code>Master</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=masterIp   \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers  \</span><br><span class="line">--service-cidr=10.10.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.122.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg  </span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.50.182   \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers  \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>如果没有Error，即kubeadm开始初始化成功</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnea5d1zctj31ek0b240h.jpg" alt=""></p>
<p>等上几分钟，初始化成功，如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gneaijhntij31mw0l6jup.jpg" alt=""></p>
<p><strong>开启集群(master)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="comment"># 正常打印出信息即，成功</span></span><br></pre></td></tr></table></figure>
<p><strong>节点加入集群(node)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line">kubeadm join 192.168.50.182:6443 --token 7t70cl.hr22v89g7wkqojdf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:d0541c10506744981838a7d4ce504eb69d28fdcfc8e1261373505c42047be33f</span><br></pre></td></tr></table></figure>
<p>这个是初始化完成后，系统给的。请以自己输出为准</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认token24hour后过期，获取新token命令如下：</span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<p><strong>部署CNI网络组件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于是国外的源，国内无法访问。我们需要添加镜像，若存在，则忽略</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.28.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署CNI网络组件</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启IPVS，修改ConfigMap的kube-system&#x2F;kube-proxy中的模式为ipvs</span><br><span class="line">kubectl edit cm kube-proxy -n kube-system </span><br><span class="line"># 将空的data -&gt; ipvs -&gt; mode中替换如下</span><br><span class="line">mode: &quot;ipvs&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk82xypglpj30rg0eo431.jpg" alt=""></p>
<p>此时已经全部就绪了，如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebsqe1pwj310g03sq3g.jpg" alt=""></p>
<h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl create deployment NAME --image=image -- [COMMAND] [args...] [options]</span></span><br><span class="line"><span class="comment"># 简单部署nginx</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 对外暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get all -n kube-system</span><br></pre></td></tr></table></figure>
<p>部署成功示意图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebxc1qlfj3114032weu.jpg" alt=""></p>
<p>向外暴露随机端口</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebyb224zj315q03i0t8.jpg" alt=""></p>
<p>访问集群中任意一个ip</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnec5gpwbij30ni0gogn2.jpg" alt=""></p>
<p>完成～</p>
<p>补充，删除部署的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get deployment </span><br><span class="line"># 我们只需要删除对应的deploy 即可</span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnec92m03hj30wm03q0sv.jpg" alt=""></p>
<p>删除成功后，已经找不到nginx的影子，完成</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnece8de4uj31w40bkgr2.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们对使用<code>kubeadm</code>工具快速搭建搭建了Kubernetes的集群，系统初始化，记得关闭防火墙、分区等哦。</p>
<p>如果对你有帮助，感觉不错。可以推荐给朋友哦，让他拿着笔记部署，怎一个香字了得，加油，冲冲冲～</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>docker</tag>
        <tag>容器编排</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis概览与安装</title>
    <url>/2021/01/14/Redis%E6%A6%82%E8%A7%88%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Redis概览"><a href="#Redis概览" class="headerlink" title="Redis概览"></a>Redis概览</h2><p>Redis是一个开源（BSD许可）的内存数据结构存储，用作数据库、缓存和消息代理。Redis提供诸如字符串、哈希、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流等数据结构。Redis具有内置的复制、Lua脚本、LRU逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster的自动分区提供高可用性<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型丰富    								（笔试、面试）*****</span><br><span class="line">支持持久化      								 （笔试、面试）*****</span><br><span class="line">多种内存分配及回收策略</span><br><span class="line">支持事务            						（面试） ****</span><br><span class="line">消息队列、消息订阅 </span><br><span class="line">支持高可用                             ****</span><br><span class="line">支持分布式分片集群 							（面试）*****</span><br><span class="line">缓存穿透\雪崩（笔试、面试）   					  *****</span><br><span class="line">Redis API                  					 **</span><br></pre></td></tr></table></figure></p>
<h2 id="Redis使用场景介绍"><a href="#Redis使用场景介绍" class="headerlink" title="Redis使用场景介绍"></a>Redis使用场景介绍</h2><p>Memcached：多核的缓存服务，更加适合于多用户并发访问次数较少的应用场景<br>Redis：单核的缓存服务，单节点情况下，更加适合于少量用户，多次访问的应用场景。Redis一般是单机多实例架构，配合redis集群出现。</p>
<h2 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方示例</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install gcc automake autoconf libtool make</span><br><span class="line"><span class="comment"># 安装源码包</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 进入文件</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.10</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定制</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install gcc automake autoconf libtool make</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir /database &amp;&amp; <span class="built_in">cd</span> /database</span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.10</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=/databases/redis-6.0.10/src:<span class="variable">$PATH</span>&quot;</span> &gt;&gt; /etc/profile  &amp;&amp; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>安装成功，如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmgwgimywj30tu050jrs.jpg" alt=""></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/redis-server &amp; </span></span><br><span class="line">src/redis-cli</span><br><span class="line">redis&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line"><span class="string">&quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmhgt73evj30ji07gq3a.jpg" alt=""></p>
<blockquote>
<p>温馨提示：</p>
<p>若编译失败，请检查<code>gcc</code>版本(可使用<code>gcc -v</code>)查看</p>
<p>我这里的是9.0.1</p>
</blockquote>
<h3 id="包管理工具安装"><a href="#包管理工具安装" class="headerlink" title="包管理工具安装"></a>包管理工具安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get -y update &amp;&amp; apt-get -y upgrade &amp;&amp; apt-get -y dist-upgrade </span><br><span class="line">apt install -y  software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:redislabs/redis</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis</span><br></pre></td></tr></table></figure>
<p>Referer</p>
<p><a href="https://redis.io/">Redis官网</a></p>
<p><a href="http://www.redis.cn/">Redis中文文档</a></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>NoSQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL,何必在忆之一(索引与执行计划篇)</title>
    <url>/2021/01/13/SQL-%E4%BD%95%E5%BF%85%E5%9C%A8%E5%BF%86%E4%B9%8B%E4%B8%80-%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%AF%87/</url>
    <content><![CDATA[<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h2><h3 id="B树的种类"><a href="#B树的种类" class="headerlink" title="B树的种类"></a>B树的种类</h3><ul>
<li>B Tree</li>
<li>B+ Tree</li>
<li>B* Tree</li>
</ul>
<h3 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B 树的定义"></a>B 树的定义</h3><a id="more"></a>
<p><strong>B树</strong>（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在<a href="https://zh.wikipedia.org/wiki/时间复杂度#对数时间">对数时间</a>内完成。B树，概括来说是一个一般化的<a href="https://zh.wikipedia.org/wiki/二元搜尋樹">二叉查找树</a>（binary search tree）一个节点可以拥有2个以上的子节点。与<a href="https://zh.wikipedia.org/wiki/自平衡二叉查找树">自平衡二叉查找树</a>不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在<a href="https://zh.wikipedia.org/wiki/数据库">数据库</a>和<a href="https://zh.wikipedia.org/wiki/文件系统">文件系统</a>的实现上。</p>
<p>三阶B树如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmk5199byij313u0g6mzl.jpg" alt=""></p>
<p>采用树形状结构，采用链表进行划分，这样就可以大量减少查询IO(且平均)，以上图为例子，等值的查询，需要三次IO，且仅要三次。</p>
<p>增加、删除、插入、搜索其之间的关系如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center"><strong>平均</strong></th>
<th style="text-align:center"><strong>最差</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">空间</td>
<td style="text-align:center">O(<em>n</em>)</td>
<td style="text-align:center">O(<em>n</em>)</td>
</tr>
<tr>
<td style="text-align:center">搜索</td>
<td style="text-align:center">O(log <em>n</em>)</td>
<td style="text-align:center">O(log <em>n</em>)</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">O(log <em>n</em>)</td>
<td style="text-align:center">O(log <em>n</em>)</td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">O(log <em>n</em>)</td>
<td style="text-align:center">O(log <em>n</em>)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>B树运用的理念</strong></p>
<ul>
<li>保持键值有序，以顺序遍历</li>
<li>使用层次化的索引来最小化磁盘读取</li>
<li>使用不完全填充的块来加速插入和删除</li>
<li>通过优雅的遍历算法来保持索引平衡</li>
</ul>
<p>另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。</p>
<p><strong>B树的弊端</strong></p>
<ul>
<li>除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到70字符之内。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的一种变形，比B树具有更广泛的应用，m阶 B+树有如下特征: </p>
<ol>
<li>每个结点的关键字个数与孩子个数相等，所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字.</li>
<li>除根结点以外，每个内部结点有<code>M/2</code> 到m个孩子.</li>
<li>所有叶结点在树结构的同一层，并且不含任何信息(可看成是外部结点或查找失败的结点)，因此，树结构总是树高平衡的。</li>
</ol>
<p>在B+树，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。</p>
<p>如图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmk5zbc02dj30ta0cmaa0.jpg" alt=""></p>
<p>一颗m阶的B+树和m阶的B_树的差异在于：</p>
<p>1.有n棵子树的结点中含有n个关键字； (而B树是n棵子树有n-1个关键字)</p>
<p>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B树的叶子节点并没有包括全部需要查找的信息)</p>
<p>3.<strong><em>\</em>所有的非终端结点可以看成是索引部分**</strong>，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
<blockquote>
<p>B＋树的主要优点：非终端结点仅仅起高层索引作用，而B树非终端结点的关键字除作子树分界外，本身还是实际记录的有效关键字（含记录指针），因此相同的结点空间，B＋树可以设计的阶树比B树大，相同的索引，B＋树的索引层数比B树少，因此检索速度比B树快。此外，B＋树叶子结点包含完整的索引信息，可以较方便地表示文件的稀疏索引。最后，B＋树的检索、插入和删除都在叶子结点进行，比B树相对简单</p>
</blockquote>
<h3 id="B-树比B树更适合数据库索引？"><a href="#B-树比B树更适合数据库索引？" class="headerlink" title="B+树比B树更适合数据库索引？"></a>B+树比B树更适合数据库索引？</h3><p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p><img src="http://static.oschina.net/uploads/space/2011/0509/171056_sAnR_135650.jpg" alt=""></p>
<p>B<em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。</p>
<blockquote>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>​    B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>​    B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>​    B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3</p>
<blockquote>
<p>这里更加具体的有待探究，欢迎大佬批评与指点</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h3><p>为了更快与查询，例如寻找书中的一页内容，我们可以先从目录进行塞选、从而加快查找的效率</p>
<h3 id="索引的种类-算法"><a href="#索引的种类-算法" class="headerlink" title="索引的种类(算法)"></a>索引的种类(算法)</h3><ul>
<li>B树索引 —&gt; B+Tree —&gt; B* Tree </li>
<li>Hash索引</li>
<li>R树</li>
<li>Full text</li>
<li>GIS </li>
</ul>
<h3 id="聚簇索引B树结构"><a href="#聚簇索引B树结构" class="headerlink" title="聚簇索引B树结构"></a>聚簇索引B树结构</h3><p>区 extend =&gt; 簇 =&gt; 64 pages -&gt; 1MB</p>
<p><strong>构建前提</strong></p>
<ul>
<li>建表时，指定了主键列，MySQL InnoDB会将主键作为聚簇索引列，比如 ID NOT NULL Primary Key</li>
<li>如果没有主键,会选择唯一(unique)的列，作为聚集索引.</li>
<li>以上均没有会生成隐藏的聚簇索引</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>有了聚簇索引后，将插入的数据行，都会按照Id值的顺序，<code>有序</code>在磁盘存储数据</li>
</ul>
<h3 id="辅助索引B树结构"><a href="#辅助索引B树结构" class="headerlink" title="辅助索引B树结构"></a>辅助索引B树结构</h3><blockquote>
<p>使用普通的列作为条件构建的索引，需要认为创建</p>
</blockquote>
<p><strong>种类</strong></p>
<ul>
<li><p>普通的单列辅助索引</p>
</li>
<li><p>联合索引（多个列作为索引条件,生成索引树,理论上设计的好的,可以减少大量的回表查询)</p>
<ul>
<li>注意最左原则</li>
<li>建立联合索引时，选择重复值少的列。作为最左列</li>
</ul>
</li>
<li><p>唯一索引（索引列的值都是唯一的.）</p>
</li>
</ul>
<p><strong>作用</strong></p>
<p>优化非聚簇索引列之外的查询优化</p>
<p><strong>构建过程</strong></p>
<ol>
<li>索引是基于表中,列(索引键)的值生成的B树结构</li>
<li>首先提取此列所有的值,进行自动排序</li>
<li>将排好序的值,均匀的分布到索引树的叶子节点中(16K)</li>
<li>然后生成此索引键值所对应得后端数据页的指针</li>
<li>生成枝节点和根节点,根据数据量级和索引键长度,生成合适的索引树高度</li>
</ol>
<p><strong>前缀索引</strong></p>
<p>当选取的索引列值过长，造成索引树增高，此时我们就需要使用前缀索引</p>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p><strong>什么时候创建索引？</strong></p>
<p>按业务所需创建合适的索引，并不是索引越多越好，将索引建立在经常<code>where</code>\<code>group by</code>\<code>order by</code>\<code>join on</code>的条件</p>
<p><strong>为什么随意建立索引？</strong></p>
<p>如果冗余索引过多，表的数据发生变化的时候，导致索引频繁更新，造成锁</p>
<p>索引过多会造成优化器选择偏差</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询表索引</span><br><span class="line">desc table_name</span><br><span class="line">show index from table_name</span><br><span class="line"># PRI 聚簇索引、MUL辅助索引、 UNI索引</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line">create index idx_name1 on city(name);</span><br><span class="line">alter table student add index idx_name(name)</span><br><span class="line"></span><br><span class="line"># 联合索引</span><br><span class="line">alter table city add index idx_co_po(countrycode,population);</span><br><span class="line"># 前缀索引</span><br><span class="line">alter table city add index idx_di(district(5));</span><br><span class="line"># 唯一索引</span><br><span class="line">alter table city add unique index idx_uni1(name);</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">alter table city drop index Index_Name</span><br></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>聚集索引只能有一个,非空唯一,一般时主键</li>
<li>辅助索引,可以有多个,时配合聚集索引使用的</li>
<li>聚集索引叶子节点,就是磁盘的数据行存储的数据页</li>
<li>MySQL是根据聚集索引,组织存储数据,数据存储时就是按照聚集索引的顺序进行存储数据</li>
<li>辅助索引,只会提取索引键值,进行自动排序生成B树结构</li>
</ul>
<p><strong>建索引原则</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 必须要有主键,如果没有可以做为主键条件的列,创建无关列</span><br><span class="line">(<span class="number">2</span>) 经常做为<span class="keyword">where</span>条件列  order <span class="keyword">by</span>  <span class="keyword">group</span> <span class="keyword">by</span>  <span class="keyword">join</span> <span class="keyword">on</span>, distinct 的条件(业务:产品功能+用户行为)</span><br><span class="line">(<span class="number">3</span>) 最好使用唯一值多的列作为索引,如果索引列重复值较多,可以考虑使用联合索引</span><br><span class="line">(<span class="number">4</span>) 列值长度较长的索引列,我们建议使用前缀索引.</span><br><span class="line">(<span class="number">5</span>) 降低索引条目,一方面不要创建没用索引,不常使用的索引清理,<span class="function">percona <span class="title">toolkit</span>(<span class="params">xxxxx</span>)</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">6</span></span>) 索引维护要避开业务繁忙期</span></span><br></pre></td></tr></table></figure>
<p><strong>关于索引树的高度受什么影响</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据量级, 解决方法:分表,分库,分布式</span><br><span class="line"><span class="number">2.</span> 索引列值过长 , 解决方法:前缀索引</span><br><span class="line"><span class="number">3.</span> 数据类型:</span><br><span class="line">变长长度字符串,使用了<span class="built_in">char</span>,解决方案:变长字符串使用varchar</span><br><span class="line"><span class="built_in">enum</span>类型的使用<span class="built_in">enum</span> (<span class="string">&#x27;山东&#x27;</span>,<span class="string">&#x27;河北&#x27;</span>,<span class="string">&#x27;黑龙江&#x27;</span>,<span class="string">&#x27;吉林&#x27;</span>,<span class="string">&#x27;辽宁&#x27;</span>,<span class="string">&#x27;陕西&#x27;</span>......)</span><br><span class="line">                                         <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="执行计划获取及分析"><a href="#执行计划获取及分析" class="headerlink" title="执行计划获取及分析"></a>执行计划获取及分析</h2><blockquote>
<p>执行计划： 优化器按照内置的cost计算，选择执行的方案</p>
<p>cost：IO、CPU、MEM</p>
</blockquote>
<p>获取到的是优化器选择完成认为代价最小的执行计划.<br>作用: 语句执行前,先看执行计划信息,可以有效的防止性能较差的语句带来的性能问题.<br>如果业务中出现了慢语句，我们也需要借助此命令进行语句的评估，分析优化方案。</p>
<p><strong>select 获取数据的方法</strong></p>
<p>全表扫描(应当尽量避免,因为性能低)</p>
<p>索引扫描</p>
<p>获取不到数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看执行计划</span><br><span class="line">desc </span><br><span class="line">explain  </span><br><span class="line"># desc(explain) select * from sr_paper</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmlbo3s5wmj319e02sgln.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需关注点</span><br><span class="line">table						：此次查询涉及的表</span><br><span class="line">type						: 查询类型：全表(一般来说有问题，重点关注)、索引(详细探究)</span><br><span class="line">possible_keys		：可能会用的索引</span><br><span class="line">key							: 最后选择的索引</span><br><span class="line">key_len					： 索引覆盖长度</span><br><span class="line">rows						: 此次查询需要扫描的行数</span><br><span class="line">Extra 					：额外的信息</span><br><span class="line"></span><br><span class="line"># 输出介绍</span><br><span class="line">全表扫：ALL</span><br><span class="line">索引扫描</span><br><span class="line">index：全索引扫描</span><br><span class="line">range：索引范围查询</span><br><span class="line">ref	：辅助索引等值查询</span><br><span class="line">eq_ref： 多表连接</span><br><span class="line">const(system)：聚簇索引等值查询</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 底层原理探究</title>
    <url>/2021/01/24/docker-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>Docker is written in the <a href="https://golang.org/">Go programming language</a> and takes advantage of several features of the Linux kernel to deliver its functionality.<br><a id="more"></a><br>Docker用<code>Go编程语言</code>编写，并利用Linux内核的多个功能来实现其功能。</p>
<h2 id="Namespaces-命名空间"><a href="#Namespaces-命名空间" class="headerlink" title="Namespaces(命名空间)"></a>Namespaces(命名空间)</h2><p>Docker uses a technology called <code>namespaces</code> to provide the isolated workspace called the <em>container</em>. When you run a container, Docker creates a set of <em>namespaces</em> for that container.</p>
<blockquote>
<p>Docker使用<code>命名空间</code>的技术实现容器(虚拟)独立的工作区</p>
</blockquote>
<p><strong>理解<code>Namespaces</code></strong></p>
<p><strong>Namespaces</strong>,可以理解为虚拟化隔离</p>
<p>当我们在系统上运行程序时，系统会为我们分配<code>pid</code>,<code>net</code>,<code>ipc</code>,<code>mnt</code>,<code>uts</code>等资源，当我们在Linux中运行时这些都是全局的。</p>
<p>当我们使用命名空间即可实现隔离的机制，每个分配<code>pid</code>,<code>net</code>,<code>ipc</code>,<code>mnt</code>,<code>uts</code>都是独立的，这样我们就可以实现权限管理等</p>
<p>These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.</p>
<p>Docker Engine uses namespaces such as the following on Linux:</p>
<ul>
<li><strong>The <code>pid</code> namespace:</strong> Process isolation (PID: Process ID).</li>
<li><strong>The <code>net</code> namespace:</strong> Managing network interfaces (NET: Networking).</li>
<li><strong>The <code>ipc</code> namespace:</strong> Managing access to IPC resources (IPC: InterProcess Communication).</li>
<li><strong>The <code>mnt</code> namespace:</strong> Managing filesystem mount points (MNT: Mount).</li>
<li><strong>The <code>uts</code> namespace:</strong> Isolating kernel and version identifiers. (UTS: Unix Timesharing System).</li>
</ul>
<p><strong>进程ID（pid）</strong></p>
<p>进程的<code>PID</code>命名空间提供与一组独立的从其他命名空间进程ID（PID）的处理。PID名称空间是嵌套的，这意味着在创建新进程时，它将为每个名称空间从当前名称空间到初始PID名称空间都有一个PID。因此，初始PID名称空间能够查看所有进程，尽管与其他名称空间看到的PID不同。</p>
<p>在PID名称空间中创建的第一个进程被分配了编号为1的进程，并获得与常规进程相同的大多数特殊处理，最值得注意的是，名称空间内的<code>孤立进程</code>。这也意味着此PID 1进程的终止将立即终止其PID名称空间中的所有进程以及所有后代。</p>
<p><strong>网络（网络）</strong></p>
<p>网络名称空间可虚拟化<code>网络堆栈</code>。创建时，网络名称空间仅包含<code>回送</code>接口。</p>
<p>每个<code>网络接口</code>（物理或虚拟）都存在于1个名称空间中，并且可以在名称空间之间移动。</p>
<p>每个名称空间都有一组专用的<code>P地址</code>，自己的<code>路由表</code>，<code>套接字</code>列表，连接跟踪表，防火墙和其他与网络相关的资源。</p>
<p>销毁网络名称空间会破坏其中的任何虚拟接口，并将其中的任何物理接口移回到初始网络名称空间。</p>
<p><strong>进程间通信（ipc）</strong></p>
<p>IPC名称空间将进程与<code>SysV</code>样式的进程间通信隔离开。这样可以防止不同IPC名称空间中的进程使用例如SHM系列功能在两个进程之间建立一定范围的共享内存。相反，每个进程将能够对共享内存区域使用相同的标识符，并产生两个这样的不同区域。</p>
<p><strong>挂载（mnt）</strong></p>
<p>安装名称空间控制安装点。创建后，会将当前安装名称空间中的安装复制到新的名称空间，但是之后创建的安装点不会在名称空间之间传播（使用共享子树，可以在名称空间之间传播安装点。</p>
<p>用于创建这种类型的新名称空间的克隆标志是CLONE_NEWNS-“ NEW NameSpace”的缩写。该术语不是描述性的（因为它没有告诉您要创建哪种类型的名称空间），因为挂载名称空间是第一类名称空间，设计人员并不预期会有其他名称空间。</p>
<p><strong>UTS (UNIX <a href="https://en.wikipedia.org/wiki/Time-sharing">Time-Sharing</a>)</strong> </p>
<p>命名空间允许单个系统对不同的进程使用不同的主机名和域名。</p>
<h2 id="Control-groups"><a href="#Control-groups" class="headerlink" title="Control groups"></a>Control groups</h2><p>Docker Engine on Linux also relies on another technology called <em>control groups</em> (<code>cgroups</code>). A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. For example, you can limit the memory available to a specific container.</p>
<blockquote>
<p>Linux上的Docker引擎还依赖另一种称为<em>控制组</em>（<code>cgroups</code>）的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可以选择性地实施限制和约束。例如，可以限制特定容器的可用内存。</p>
</blockquote>
<h2 id="Union-file-systems"><a href="#Union-file-systems" class="headerlink" title="Union file systems"></a>Union file systems</h2><p>Union file systems, or UnionFS, are file systems that operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and DeviceMapper.</p>
<blockquote>
<p>Union文件系统（UnionFS）是通过<code>创建层</code>来操作的文件系统，使它们非常轻量级和快速。Docker引擎使用UnionFS为容器提供构建块。Docker引擎可以使用多种UnionFS变体，包括AUFS、btrfs、vfs和DeviceMapper。</p>
</blockquote>
<h2 id="Container-format"><a href="#Container-format" class="headerlink" title="Container format"></a>Container format</h2><p>Docker Engine combines the namespaces, control groups, and UnionFS into a wrapper called a container format. The default container format is <code>libcontainer</code>. In the future, Docker may support other container formats by integrating with technologies such as BSD Jails or Solaris Zones.</p>
<blockquote>
<p>Docker引擎将名称空间、控制组和UnionFS组合成一个称为容器格式的包装器。默认容器格式为“libcontainer”。将来，Docker可以通过集成BSD监狱或Solaris区域等技术来支持其他容器格式。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>docker使用go语言编写，基于<strong>Namespaces</strong>进行虚拟化隔离，Control groups进行对资源的限制，联合文件Union file systems来快速构建（可复用的镜像层），</p>
]]></content>
      <categories>
        <category>容器编排</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署控制</title>
    <url>/2020/12/13/docker%E9%83%A8%E7%BD%B2%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Docker-swarm部署控制"><a href="#Docker-swarm部署控制" class="headerlink" title="Docker swarm部署控制"></a>Docker swarm部署控制</h2><p>还记得我之前写过一片文章叫做<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzM4NTg3MA==&amp;tempkey=MTA5MF9RcFZ5c1B4QTFmSnZHd2Qxa3hMNWhpLXFoOEJYWVBBaUZyME1sRmVBQnR1QWN3V3FUZ1hfa1BnemdtOWpLY1o0RTlzVnE2OUtRblZPS1ZDV2pDSk9QU3BadDUzLTNJa3RHYmxFQXNqMjQyQ1dSNUlrcDdfTG1scDRTWVg2UDdiLTI5eWo4dE9HSHI4TlVKOVltZEdtVzZObW9NT19GN2I5eF9YbzdBfn4%3D&amp;chksm=4e78226b790fab7d1fb0283f8b6294c40456df7aebf58d947412ed03d0c3fc3aa188de79f130#rd">《Docker快速部署项目，极速搭建分布式》</a>，在那里讲述了如何去使用docker swarm，如何构建自己的私人镜像仓库。随着最近的业务量的增长，机子加多。对于docker swarm管理难度有上升的趋势。主要的问题有以下几个</p>
<ul>
<li>物理机配置不同（比如 CPU、内存等）</li>
<li>部署着不同类型的服务（比如 Web服务、Job服务等）</li>
<li>Swarm 集群中的节点跨机房，为了内部服务间通信更快，该如何分组部署</li>
<li>。。。</li>
</ul>
<p>为了解决以上问题,以求更合理、更科学的管理部署所以有了今天这篇文章。<br><a id="more"></a><br>docker 节点的部署调度一共有三种机制，随机部署、平衡部署、先满部署</p>
<blockquote>
<p>随机部署：active中随机选择</p>
<p>平衡部署：尽可能先平均填满所有的节点</p>
<p>先满部署：与平衡部署相反，先部署至上限，然后在部署对应的</p>
</blockquote>
<p>那么该如何管理呢？下面我介绍几种方式，如下</p>
<ul>
<li>NodeId</li>
<li>HOSTNAME</li>
<li>Node role</li>
<li>node labels</li>
<li>engine.labels</li>
</ul>
<p>首先我们查看一下节点列表信息，直接使用<code>docker node ls</code>，即可</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glgia65xg6j31jo0b8dgn.jpg" alt=""></p>
<p>首先我们先解读一下，docker 的限制指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker service create --help</span></span><br><span class="line">--constraint list                    Placement constraints</span><br><span class="line">--container-label list               Container labels</span><br></pre></td></tr></table></figure>
<p>他们的 后面跟随的参数都是list，具体使用如以下示例</p>
<h3 id="NodeId"><a href="#NodeId" class="headerlink" title="NodeId"></a>NodeId</h3><p>根据NodeId来指定部署节点，以下以搭建私人镜像仓库为示例。</p>
<h4 id="docker-service"><a href="#docker-service" class="headerlink" title="docker service"></a>docker service</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name registry \</span><br><span class="line">--publish published=5000,target=5000 \</span><br><span class="line">--constraint node.id==ytsyvuhfs60spr361y6irpynm \</span><br><span class="line">registry:2</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glgiv5qw30j31le03i0sr.jpg" alt=""></p>
<p>命令解读</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在docker swarm中创建服务</span></span><br><span class="line">docker service create 	\</span><br><span class="line"><span class="comment"># --name 服务别名</span></span><br><span class="line"><span class="comment"># 指定node的id，ytsyvuhfs60spr361y6irpynm这个是我这里的node.id，你使用的时候需按照需求替换即可</span></span><br><span class="line">--constraint node.id==ytsyvuhfs60spr361y6irpynm \</span><br><span class="line"><span class="comment"># 暴露公开的接口，可以让节点中的其他node可以访问</span></span><br><span class="line">--publish published=5000,target=5000	\</span><br><span class="line"><span class="comment"># 镜像名：版本号</span></span><br><span class="line">registry:2</span><br></pre></td></tr></table></figure>
<p>这样我们就实现了指定节点的部署，是不是很简单呢。</p>
<h4 id="docker-stack"><a href="#docker-stack" class="headerlink" title="docker stack"></a>docker stack</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">registry:</span></span><br><span class="line">         <span class="string">registry:2</span></span><br><span class="line">         <span class="attr">ports:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">8080</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">8080</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">         <span class="attr">deploy:</span></span><br><span class="line">           <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">           <span class="attr">placement:</span></span><br><span class="line">              <span class="attr">constraints:</span>                      <span class="comment"># 添加条件约束</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node.id==ytsyvuhfs60spr361y6irpynm</span></span><br><span class="line">           <span class="attr">restart_policy:</span></span><br><span class="line">             <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">             <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="HOSTNAME"><a href="#HOSTNAME" class="headerlink" title="HOSTNAME"></a>HOSTNAME</h3><p>​    除此之外我们还可以指定hostname 去将应用部署到指定的hostname上，操作与以上差不多。那让我们来实现一下，首先我们需要查看对应节点的信息，在manager节点上使用<code>docker node ls</code>查看，如下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhr7pa7oj31yo07ewfw.jpg" alt=""></p>
<h4 id="docker-service-1"><a href="#docker-service-1" class="headerlink" title="docker service"></a>docker service</h4><p><strong>创建命令如下</strong>,以nginx为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name nginx \</span><br><span class="line">--constraint node.hostname&#x3D;&#x3D;ecs-dc8a-0003 \</span><br><span class="line">-p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmi66uraij31y405mt9f.jpg" alt=""></p>
<p>这样我们就将nginx服务部署至对应的节点了，并且扩容也仅会在此节点进行部署。示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service scale nginx&#x3D;3</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmidvm1g1j31y60pwtcy.jpg" alt=""></p>
<h4 id="docker-stack-1"><a href="#docker-stack-1" class="headerlink" title="docker stack"></a>docker stack</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">nginx:</span></span><br><span class="line">         <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">         <span class="attr">ports:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">80</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">         <span class="attr">deploy:</span></span><br><span class="line">           <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">           <span class="attr">placement:</span></span><br><span class="line">              <span class="attr">constraints:</span>                      <span class="comment"># 添加条件约束</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node.hostname==ecs-dc8a-0003</span></span><br><span class="line">           <span class="attr">restart_policy:</span></span><br><span class="line">             <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">             <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="Node-role"><a href="#Node-role" class="headerlink" title="Node role"></a>Node role</h3><p>前面我们了解到了根据<code>node.id</code>,<code>node.hostname</code>进行指定节点的部署，但指定的却是唯一的。那么该如何实现同一类进行随机的部署呢？到这里我们继续深入了解，更具节点关系的进行约束。可部署节点中的关系有leader，work。</p>
<p>例如，我想实现不在主节点上部署，虽然我们可以使用使用限制中的条件，避开。例如这样</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="string">docker</span> <span class="string">service</span> <span class="string">create</span> <span class="string">\</span></span><br><span class="line"><span class="string">--name</span> <span class="string">registry</span> <span class="string">\</span></span><br><span class="line"><span class="string">--publish</span> <span class="string">published=5000,target=5000</span> <span class="string">\</span></span><br><span class="line"><span class="string">--constraint</span> <span class="string">node.id!=ytsyvuhfs60spr361y6irpynm</span> <span class="string">\</span> <span class="comment"># 修改处</span></span><br><span class="line"><span class="string">registry:2</span></span><br></pre></td></tr></table></figure>
<p>只需要将<code>==</code>,改为<code>!=</code>,即可。</p>
<h4 id="docker-service-2"><a href="#docker-service-2" class="headerlink" title="docker service"></a>docker service</h4><p>但终究还是感觉很不喜欢，其实我们也可以这样,根据节点关系进行约束部署，示例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name nginx \</span><br><span class="line">--publish published=80,target=80 \</span><br><span class="line">--constraint node.role!=manager nginx</span><br></pre></td></tr></table></figure>
<h4 id="docker-stack-2"><a href="#docker-stack-2" class="headerlink" title="docker stack"></a>docker stack</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">nginx:</span></span><br><span class="line">         <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">         <span class="attr">ports:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">80</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">         <span class="attr">deploy:</span></span><br><span class="line">           <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">           <span class="attr">placement:</span></span><br><span class="line">              <span class="attr">constraints:</span>                      <span class="comment"># 添加条件约束</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node.role!=manager</span></span><br><span class="line">           <span class="attr">restart_policy:</span></span><br><span class="line">             <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">             <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="Node-lables"><a href="#Node-lables" class="headerlink" title="Node lables"></a>Node lables</h3><p>讲了这么多，照顾新手的就已经过去了，接下来我们晚点更常用的部署，更具lables，来部署。只要是同一个lable，就会可以被部署到，切后续还可以根据label进行更得心应手的管理，例如加入一个label，进行节点驱逐、然后在新加入lables，扩容</p>
<h4 id="添加标签与检查标签"><a href="#添加标签与检查标签" class="headerlink" title="添加标签与检查标签"></a>添加标签与检查标签</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">docker node update --label-add role=web hostname</span><br><span class="line"><span class="comment"># 检查标签</span></span><br><span class="line">docker node inspect hostname </span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">docker node update --label-rm role hostname</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ID&quot;</span>: <span class="string">&quot;ttdku9ch37pknxu7b9sxknimb&quot;</span>,                                                                                   </span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;                                                                                                         </span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 852                                                                                                     </span><br><span class="line">        &#125;,                                                                                                                   </span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2020-12-08T11:10:53.322771866Z&quot;</span>,                                                                       </span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2020-12-13T13:24:57.009816659Z&quot;</span>,                                                                       </span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;                                                                                                            </span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;                                                                                                      </span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;web&quot;</span>              <span class="comment"># 这样我们就实现了添加标签                                                                                  </span></span><br><span class="line">            &#125;,                                                                                                               </span><br><span class="line">            <span class="string">&quot;Role&quot;</span>: <span class="string">&quot;manager&quot;</span>,                                                                                               </span><br><span class="line">            <span class="string">&quot;Availability&quot;</span>: <span class="string">&quot;active&quot;</span>                                                                                         </span><br><span class="line">        &#125;,                 </span><br><span class="line">        <span class="comment"># 略</span></span><br></pre></td></tr></table></figure>
<h4 id="docker-Service"><a href="#docker-Service" class="headerlink" title="docker Service"></a>docker Service</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name nginx_2 \</span><br><span class="line">  --constraint <span class="string">&#x27;node.labels.role == web&#x27;</span> \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>
<h4 id="docker-Stack"><a href="#docker-Stack" class="headerlink" title="docker Stack"></a>docker Stack</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">    mycat:</span><br><span class="line">         image: nginx</span><br><span class="line">         ports:</span><br><span class="line">           - target: <span class="number">8080</span></span><br><span class="line">             published: <span class="number">8080</span></span><br><span class="line">             protocol: tcp</span><br><span class="line">             mode: ingress</span><br><span class="line">         deploy:</span><br><span class="line">           mode: <span class="keyword">global</span></span><br><span class="line">           placement:</span><br><span class="line">              constraints:                      <span class="meta"># 添加条件约束</span></span><br><span class="line">                - node.labels.role==web</span><br><span class="line">           restart_policy:</span><br><span class="line">             condition: <span class="keyword">on</span>-failure</span><br><span class="line">             max_attempts: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>constraints</code> 为数组，填写多个约束时，它们之间的关系是 <code>AND</code>。也就是说我们可以进行组合使用</p>
<h3 id="更多请参考下表"><a href="#更多请参考下表" class="headerlink" title="更多请参考下表"></a>更多请参考下表</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">node attribute</th>
<th style="text-align:left">matches</th>
<th style="text-align:left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>node.id</code></td>
<td style="text-align:left">Node ID</td>
<td style="text-align:left"><code>node.id==2ivku8v2gvtg4</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.hostname</code></td>
<td style="text-align:left">Node hostname</td>
<td style="text-align:left"><code>node.hostname!=node-2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.role</code></td>
<td style="text-align:left">Node role (<code>manager</code>/<code>worker</code>)</td>
<td style="text-align:left"><code>node.role==manager</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.platform.os</code></td>
<td style="text-align:left">Node operating system</td>
<td style="text-align:left"><code>node.platform.os==windows</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.platform.arch</code></td>
<td style="text-align:left">Node architecture</td>
<td style="text-align:left"><code>node.platform.arch==x86_64</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.labels</code></td>
<td style="text-align:left">User-defined node labels</td>
<td style="text-align:left"><code>node.labels.security==high</code></td>
</tr>
<tr>
<td style="text-align:left"><code>engine.labels</code></td>
<td style="text-align:left">Docker Engine’s labels</td>
<td style="text-align:left"><code>engine.labels.operatingsystem==ubuntu-14.04</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://docs.docker.com/engine/reference/commandline/service_create/#set-service-mode---mode">此部分的官方文档</a></p>
]]></content>
      <categories>
        <category>容器编排</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发模式</title>
    <url>/2021/02/12/golang%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发模式并不是一种函数的运用、亦或者实际存在的东西。他是前人对于并发场景的运用总结与经验。他与23中设计模式一样。好啦，话不多说。开干</p>
<p>无论是如何厉害的架构还是编程方式，我始终相信都是从零开始，不断的抽象，不断的迭代的。抽象思维对于我们尤为重要。那么我们也带着这样的一个疑问。思考到底什么是抽象</p>
<p>首先我们将要学习的是<code>work pool</code>模式<br><a id="more"></a></p>
<h2 id="work-pool"><a href="#work-pool" class="headerlink" title="work pool"></a>work pool</h2><p>不知道大家是否在go并发的时候遇见过以下几个问题或者想法</p>
<ul>
<li>goroutine的数量控制可能并不是那么称心如意<ul>
<li>goroutine，创造过多，造成资源浪费。且并发效果也并非那么好。他正如正态分布那样。到达某个极点所带来的收益将会下降</li>
</ul>
</li>
<li>goroutine复用的问题，往往一个goroutine都只处理了一个任务。不断的创建与删除</li>
<li>甚至更多。。。</li>
</ul>
<p>workpool，首先分析以上问题，我个人总结都以上其实是一个问题，groutine与任务死死的绑定，并没有进行解耦。比如像这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exs</span><span class="params">(accept &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, recipient <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> accept &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received only sent channel a:&quot;</span>, result)</span><br><span class="line">		recipient &lt;- result + <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;Send Only&quot;, recipient)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			fmt.Println(&lt;-ch)</span><br><span class="line">		&#125;(ch)</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们来改造一下，然后进行代码剖析。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func work(id int, jobs &lt;-chan int, result chan&lt;- int) &#123;</span><br><span class="line">	for j :&#x3D; range jobs &#123;</span><br><span class="line">		fmt.Println(&quot;Worker [ID]&quot;, id, &quot;Start Process JoB [Id]&quot;, j)</span><br><span class="line">		time.Sleep(time.Second * 2)</span><br><span class="line">		&#x2F;&#x2F;fmt.Println(&quot;Working, will Spend 2 s&quot;)</span><br><span class="line">		fmt.Println(&quot;Worker [ID]&quot;, id, &quot;Carry Process JoB [Id]&quot;, j)</span><br><span class="line">		result &lt;- j * 2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	const jobNumber &#x3D; 1000</span><br><span class="line">	const workerNumber &#x3D; 100</span><br><span class="line"></span><br><span class="line">	jobs :&#x3D; make(chan int, workerNumber)</span><br><span class="line">	result :&#x3D; make(chan int, jobNumber)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Create Worker(start Goroutines)</span><br><span class="line">	for w :&#x3D; 0; w &lt;&#x3D; workerNumber; w++ &#123;</span><br><span class="line">		go work(w, jobs, result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; arrange work</span><br><span class="line">	for j :&#x3D; 0; j &lt;&#x3D; jobNumber; j ++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取结果</span><br><span class="line">	for r :&#x3D; 0; r &lt;&#x3D; jobNumber; r ++ &#123;</span><br><span class="line">		&lt;- result</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work pool的精髓在于将任务，与groutine进行分离。只关心初始的任务与结果。是不是与函数式编程很像呢？我也这么觉得，嘻嘻</p>
<p>来吧，我们剖析一下代码</p>
<ol>
<li>首先我们定义了两个常量（建议是常量），<code>jobNum</code>与<code>workerNumber</code>，故名思义他们分别是任务数量，以及工人数量。你可以将他们看出生产者与消费者。</li>
<li>我们定义了两个channel，他们作为我们发送指令与获取结果的通道。记得加缓存哦，否则将造成死锁</li>
<li>最后就是分别定义消费者-<code>groutine</code>，生产者jobNumber，然后传递任务进入goroutine。然后我们就只需要得到结果就好啦</li>
</ol>
<p>nice，虽然很简单。但也有无限的可能性哦。你还可以进一步抽象，变成一个通用的goroutine pool。</p>
<h2 id="Pipeline-模式"><a href="#Pipeline-模式" class="headerlink" title="Pipeline 模式"></a>Pipeline 模式</h2><p>Pipeline 模式也称为流水线模式，模拟的就是现实世界中的流水线生产。</p>
<p>从技术上看，每一道工序的输出，就是下一道工序的输入，在工序之间传递的东西就是数据，这种模式称为流水线模式，而传递的数据称为数据流。下面我们用代码模拟<code>柴火烧饭的</code>过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	combust :&#x3D; wash(10)</span><br><span class="line">	rice :&#x3D; combustion(combust)</span><br><span class="line">	packs :&#x3D; open(rice)</span><br><span class="line">	&#x2F;&#x2F;输出测试，看看效果</span><br><span class="line">	for p :&#x3D; range packs &#123;</span><br><span class="line">		fmt.Println(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func wash(n int) &lt;-chan string &#123;</span><br><span class="line">	out :&#x3D; make(chan string)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(out)</span><br><span class="line">		for i :&#x3D; 1; i &lt;&#x3D; n; i++ &#123;</span><br><span class="line">			out &lt;- fmt.Sprint(&quot;洗米&quot;, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return out</span><br><span class="line">&#125;</span><br><span class="line">func combustion(in &lt;-chan string) &lt;-chan string &#123;</span><br><span class="line">	out :&#x3D; make(chan string)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(out)</span><br><span class="line">		for c :&#x3D; range in &#123;</span><br><span class="line">			out &lt;- &quot;烧饭(&quot; + c + &quot;)&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func open(in &lt;-chan string) &lt;-chan string &#123;</span><br><span class="line">	out :&#x3D; make(chan string)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(out)</span><br><span class="line">		for c :&#x3D; range in &#123;</span><br><span class="line">			out &lt;- &quot;开锅(&quot; + c + &quot;)&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>开锅(烧饭(洗米1))<br>开锅(烧饭(洗米2))<br>开锅(烧饭(洗米3))<br>开锅(烧饭(洗米4))<br>开锅(烧饭(洗米5))<br>开锅(烧饭(洗米6))<br>开锅(烧饭(洗米7))<br>开锅(烧饭(洗米8))<br>开锅(烧饭(洗米9))<br>开锅(烧饭(洗米10))</p>
</blockquote>
<p>首先，我为什么一定强调是柴火烧饭呢，难道柴火香一点？那可不，必须的。</p>
<p>其实再这里，我们需要思考一个问题，什么是可异步的，什么是不可异步的？</p>
<blockquote>
<p>拓展：</p>
<p>可异步：例如网络请求，发送网络请求后，立马发送下一个。尽量减少网络io阻塞，从而提高效率。可前提是，网络io阻塞可以不用等待</p>
<p>不可异步：也就是说我们每一步都必须参与其中，计算机它无法独自去完成。例如柴火烧饭，没柴火咋烧饭，魔法么。当然你硬要说火烧一次就一直可以不需要人去干预，那咱也没办法了不是</p>
</blockquote>
<p>在这里，生产者与消费者可能并不像之前那么分的那么开了，首先 </p>
<p>洗米（生产者）</p>
<p>烧饭（消费者、生产者）</p>
<p>开锅（消费者）</p>
<p>这种模式称为流水线模式，而传递的数据称为数据流</p>
<h2 id="分治模式"><a href="#分治模式" class="headerlink" title="分治模式"></a>分治模式</h2><p>就像前面所说那样，每一道必须依靠前面完成了才能进行下一步，但我们发现其中烧饭或者太慢了，我们可以分而治之，然后合并。也可以达到我们需要的效果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	combust := wash(<span class="number">10</span>)</span><br><span class="line">	rice1 := combustion(combust)</span><br><span class="line">	rice2 := combustion(combust)</span><br><span class="line">	rice3 := combustion(combust)</span><br><span class="line">	rice := merge(rice1, rice2, rice3)</span><br><span class="line">	packs := open(rice)</span><br><span class="line">	<span class="comment">//输出测试，看看效果</span></span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> packs &#123;</span><br><span class="line">		fmt.Println(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wash</span><span class="params">(n <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">			out &lt;- fmt.Sprint(<span class="string">&quot;洗米&quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combustion</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">		time.Sleep(<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- <span class="string">&quot;烧饭(&quot;</span> + c + <span class="string">&quot;)&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">		<span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- <span class="string">&quot;开锅(&quot;</span> + c + <span class="string">&quot;)&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(ins ...&lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">//把一个channel中的数据发送到out中</span></span><br><span class="line">	p := <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(ins))</span><br><span class="line">	<span class="comment">//扇入，需要启动多个goroutine用于处于多个channel中的数据</span></span><br><span class="line">	<span class="keyword">for</span> _, cs := <span class="keyword">range</span> ins &#123;</span><br><span class="line">		<span class="keyword">go</span> p(cs)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//等待所有输入的数据ins处理完，再关闭输出out</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Futures-模式"><a href="#Futures-模式" class="headerlink" title="Futures 模式"></a>Futures 模式</h2><p>Pipeline 流水线模式中的工序是相互依赖的，上一道工序做完，下一道工序才能开始。但是在我们的实际需求中，也有大量的任务之间相互独立、没有依赖，所以为了提高性能，这些独立的任务就可以并发执行。</p>
<p>举个例子，比如我打算自己做顿火锅吃，那么就需要洗菜、烧水。洗菜、烧水这两个步骤相互之间没有依赖关系，是独立的，那么就可以同时做，但是最后做火锅这个步骤就需要洗好菜、烧好水之后才能进行。这个做火锅的场景就适用 Futures 模式。</p>
<p>Futures 模式可以理解为未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取，如果子协程还没有返回结果，就一直等待</p>
<p>Futures 模式下的协程和普通协程最大的区别是可以返回结果，而这个结果会在未来的某个时间点使用。所以在未来获取这个结果的操作必须是一个阻塞的操作，要一直等到获取结果为止。</p>
<p>如果你的大任务可以拆解为一个个独立并发执行的小任务，并且可以通过这些小任务的结果得出最终大任务的结果，就可以使用 Futures 模式。</p>
<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>22讲通关go语言-飞雪无情</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发铁索连环-context</title>
    <url>/2021/02/12/golang%E5%B9%B6%E5%8F%91%E9%93%81%E7%B4%A2%E8%BF%9E%E7%8E%AF-context/</url>
    <content><![CDATA[<p>首先要和大家说声抱歉哈，由于工作上、生活上的某些琐事，以至于造成本节的断更。不过请不要悲伤。因为我在这期间也是做过详细的复习的。我相信一定会让你有更加深入的理解，同时也欢迎你向我提出不足。我们共同进步。话不多说，我相信你已经迫不及待了。还在等什么？let‘s GO</p>
<p>在本文中，我首先会介绍context是什么，它有什么作用，以及如何使用，其中还会参杂一点个人的理解，以及部分源码的了解。What are you waiting for?<br><a id="more"></a></p>
<h2 id="Context："><a href="#Context：" class="headerlink" title="Context："></a>Context：</h2><blockquote>
<p>来自官方文档</p>
</blockquote>
<p>Context包定义了上下文类型，该类型在API边界之间以及进程之间传递截止日期，取消信号和其他请求范围的值</p>
<p>对服务器的传入请求应创建一个Context，而对服务器的传出调用应接受一个Context。</p>
<p>它们之间的函数调用链必须传播Context，可以选择将其替换为使用WithCancel，WithDeadline，WithTimeout或WithValue创建的派生Context。取消上下文后，从该上下文派生的所有上下文也会被取消。</p>
<p>WithCancel，WithDeadline和WithTimeout函数采用Context（父级）并返回派生的Context（子级）和CancelFunc。调用CancelFunc会取消该子代及其子代，删除父代对该子代的引用，并停止所有关联的计时器。未能调用CancelFunc会使子代及其子代泄漏，直到父代被取消或计时器触发。审核工具检查所有控制流路径上是否都使用了CancelFuncs。</p>
<p>使用上下文的程序应遵循以下规则，以使各个包之间的接口保持一致，并使静态分析工具可以检查上下文传播：</p>
<p>不要将上下文存储在结构类型中；而是将上下文明确传递给需要它的每个函数。 Context应该是第一个参数，通常命名为ctx：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//  ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使函数允许，也不要传递nil Context。如果不确定使用哪个上下文，请传递context.TODO</p>
<p>仅将上下文值用于传递过程和API的请求范围数据，而不用于将可选参数传递给函数。</p>
<p>可以将相同的上下文传递给在不同goroutine中运行的函数。上下文可以安全地被多个goroutine同时使用</p>
<p>巴拉巴拉，说了一大堆，反正我一句没懂，当然我知道context是干嘛的，（尬～，不小心暴露了，学渣的本质），说说我的理解以及使用建议</p>
<ul>
<li>对服务器的传入请求应创建一个Context，而对服务器的传出响应也应接受一个Context。</li>
<li><p>函数调用链必须传播Context，也可以选择将其替换为使用WithCancel，WithDeadline，WithTimeout或WithValue创建的派生Context(也就是子类context)。取消上下文后，从该上下文派生的所有上下文也会被取消</p>
</li>
<li><p>Context 不要放在结构体中，要以参数的方式传递。</p>
</li>
<li>Context 作为函数的参数时，要放在第一位，也就是第一个参数。</li>
<li>要使用 context.Background 函数生成根节点的 Context，也就是最顶层的 Context。</li>
<li>Context 传值要传递必须的值，而且要尽可能地少，不要什么都传。</li>
<li><strong>Context 多协程安全，可以在多个协程中放心使用。</strong></li>
</ul>
<h3 id="go-Context定义"><a href="#go-Context定义" class="headerlink" title="go Context定义"></a>go Context定义</h3><p>Context 是Go 1.7 标准库引入 的标准库，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。</p>
<p>使用context，我们可以轻松优雅的做到<code>取消goroutine</code>，<code>超时时间</code>,<code>运行截止时间</code>，<code>k-v</code>存储等。<strong>它是并发安全的</strong></p>
<p>随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context 几乎成为了并发控制和超时控制的标准做法。</p>
<blockquote>
<p>context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。<br>与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行。</p>
</blockquote>
<p>止于这些么？当然 不止,还有更多的骚操作，接下来让我们一起拿下它吧。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>为什么需要使用context，理由一</p>
<p>一个协程启动后，大部分情况需要等待里面的代码执行完毕，然后协程会自行退出。但需要让协程提前退出怎么办呢？</p>
</blockquote>
<p>下面我们以一个小的示例，来逐渐了解context的妙用之一吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启for select循环，j进行后台监控</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Time: %v 监控者:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// sleep 1 second</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s 监控完成，一切正常，请指示 over...\n&quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">// Define waiting group</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// Execution complete</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		monitor(<span class="string">&quot;天眼&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//Exit after waiting</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里实现了一个基本的groutine执行的case</p>
<blockquote>
<p>我们定义了等待组<code>wait group</code>,防止协程提前退出。关于<code>wait group</code>可参考上一篇文章，golang并发控制的心应手。</p>
</blockquote>
<p>他会周期性的运行，不断打印监控信息，例如</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnhog0u2cbj30iy06eq33.jpg" style="zoom:50%;" /></p>
<p>那么我们完成上述的那个需求<code>提前退出</code>,那么该怎么办呢？其中一个方法就是定义一个全局的sign，其他地方可以通过修改这个sign发出停止监控的指令。然后在协程中先检查这个变量，如果发现被通知关闭就停止监控，退出当前协程。从而实现可控制提前退出。示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor1</span><span class="params">(signCh <span class="keyword">chan</span> <span class="keyword">bool</span>, MonitoringPeriod time.Duration, name <span class="keyword">string</span>, )</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启for select循环，一直后台监控</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-signCh:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;停止指令已收到，停止...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	signCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">//sign 用来停止监控</span></span><br><span class="line">	<span class="keyword">const</span> MonitoringTime, MonitoringPeriod = <span class="number">20</span>, <span class="number">2</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		monitor1(signCh, MonitoringPeriod, <span class="string">&quot;天眼&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(MonitoringTime * time.Second) <span class="comment">//实施监控时间</span></span><br><span class="line">	signCh &lt;- <span class="literal">true</span>                           <span class="comment">//发停止指令</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样我们就实现了，可控制话的groutine退出，但如果在新增几个定期的任务功能，那该如何是好？</p>
<p>管他的，我们先把这个弄懂了先。老夫先干为敬。首先我们先看程序运行图，如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnhpa8zjtfj315k0tsmxg.jpg" style="zoom:50%;" /></p>
<p>这个示例是使用 select+channel 的方式改造，实现了通过 channel 发送指令让监控狗停止，进而达到协程退出的目的。</p>
<p>首先我们定义了sync.WaitGroup，防止gorontine提前退出。signCh，他是一个bool值类型channel，用于发送sign后续的退出。</p>
<p>MonitoringTime，MonitoringPeriod，监控时间与监控周期。second。</p>
<p>然后创建goroutine执行select+channel。</p>
<h2 id="Go-Context-初试体验"><a href="#Go-Context-初试体验" class="headerlink" title="Go Context 初试体验"></a>Go Context 初试体验</h2><p>为 函数增加 signCh 参数，用于接收停止指令；</p>
<p>在 main 函数中，声明用于停止的 signCh，传递给 monitor1 函数，然后通过 signCh&lt;-true 发送停止指令让协程退出。</p>
<p>通过 select+channel 让协程退出的方式比较优雅，以下几个问题也随之凸显</p>
<p>但如果我们希望做到同时取消很多个协程呢？</p>
<p>如果是定时取消协程又该怎么办？</p>
<p>这时候 select+channel 的局限性就凸现出来了，即使定义了多个 channel 解决问题，当然这个方式是可行的，但代码逻辑也会非常复杂、难以维护。</p>
<p>要解决这种复杂的协程问题，必须有一种可以跟踪协程的方案，只有跟踪到每个协程，才能更好地控制它们，这种方案就是 Go 语言标准库为我们提供的 Context，接下来我们体验一下它的强大之处吧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">const</span> MonitoringTime, MonitoringPeriod = <span class="number">20</span>, <span class="number">2</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 定义一个等待的 `context`</span></span><br><span class="line">	ctx, stop := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		monitor2(ctx, MonitoringPeriod, <span class="string">&quot;天眼&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(MonitoringTime * time.Second) <span class="comment">//先监控5秒</span></span><br><span class="line">	stop()                                   <span class="comment">//发停止指令</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor2</span><span class="params">(ctx context.Context, MonitoringPeriod time.Duration, name <span class="keyword">string</span>, )</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启for select循环，一直后台监控</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;停止指令已收到，停止...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很优雅呢？确实如此，那么为什么也可以达到上面使用<code>channel</code>，的效果呢。那么我们去看一下它的具体实现部分呢，</p>
<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a><code>WithCancel</code></h3><p>以下是WithCancel：具体实现部分代码</p>
<blockquote>
<p>WithCancel:返回具有新的“完成”通道的父级副本。当调用返回的cancel函数或关闭父上下文的Done通道时（以先发生的为准），将关闭返回的上下文的Done通道。取消此上下文将释放与其关联的资源，因此在此上下文中运行的操作完成后，代码应立即调用cancel。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了WithCancel，之外还有<code>WithDeadline</code>,<code>WithTimeout</code>,<code>WithValue</code>,首先我们来继续看看<code>WithDeadline</code>具体实现，以及使用技巧吧</p>
<h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a><code>WithTimeout</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取消此上下文将释放与之关联的资源，因此在此上下文中运行的操作完成后，代码应立即调用cancel：</p>
</blockquote>
<p>来看一下具体如何使用吧，示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 创建一个子节点的context,3秒后自动超时</span><br><span class="line">	const MonitoringTime, MonitoringPeriod &#x3D; 20, 2</span><br><span class="line">	ctx, cancel :&#x3D; context.WithTimeout(context.Background(), time.Second*10)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		monitor4(ctx, MonitoringPeriod, &quot;天眼&quot;)</span><br><span class="line">		fmt.Println(&quot;退出时间&quot;,time.Now().Unix())</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(MonitoringTime * time.Second)</span><br><span class="line">	cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func monitor4(ctx context.Context, MonitoringPeriod time.Duration, name string, ) &#123;</span><br><span class="line">	&#x2F;&#x2F;开启for select循环，一直后台监控</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, &quot;停止指令已收到，停止...&quot;)</span><br><span class="line">			return</span><br><span class="line">		default:</span><br><span class="line">			fmt.Printf(&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;, time.Now().Unix(), name)</span><br><span class="line">			time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上会有两种情况发生退出，</p>
<p>一、程序main退出，全局退出</p>
<p>二、我们定义的timeout退出</p>
</blockquote>
<p>他们的基本性质与使用我们就简单的过了一遍，下面让我们来个小结。</p>
<p>WithCancel(parent Context)：生成一个可取消的 Context。</p>
<p>WithDeadline(parent Context, d time.Time)：生成一个可定时取消的 Context，<strong>参数 d 为定时取消的具体时间。</strong></p>
<p>WithTimeout(parent Context, timeout time.Duration)：生成一个可超时取消的 Context，<strong>参数 timeout 用于设置多久后取消</strong></p>
<p>WithValue(parent Context, key, val interface{})：生成一个可携带 key-value 键值对的 Context。</p>
<p>是不是发现，其实也没有那么难呢？当然，它本来就很简单，接下来我们来点更刺激的，同时取消多goroutine，啥也不说了，上～</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	const MonitoringTime, MonitoringPeriod &#x3D; 20, 2</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	ctx, stop :&#x3D; context.WithCancel(context.Background())</span><br><span class="line">	for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">		go monitor6(ctx, MonitoringPeriod, strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(MonitoringTime * time.Second) &#x2F;&#x2F;先监控5秒</span><br><span class="line">	stop()                                   &#x2F;&#x2F;发停止指令</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">func monitor6(ctx context.Context, MonitoringPeriod time.Duration, name string, ) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	&#x2F;&#x2F;开启for select循环，一直后台监控</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, &quot;停止指令已收到，停止...&quot;)</span><br><span class="line">			return</span><br><span class="line">		default:</span><br><span class="line">			fmt.Printf(&quot;Time: %v [监控者]:天眼%s, 正在监控...\n&quot;, time.Now().Unix(), name)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Time: 1612948086 [监控者]:天眼0, 正在监控…<br>Time: 1612948086 [监控者]:天眼1, 正在监控…<br>Time: 1612948086 [监控者]:天眼2, 正在监控…<br>… …<br>Time: 1612948104 [监控者]:天眼2, 正在监控…<br>Time: 1612948104 [监控者]:天眼0, 正在监控…<br>Time: 1612948104 [监控者]:天眼1, 正在监控…<br>2 停止指令已收到，停止…<br>1 停止指令已收到，停止…<br>0 停止指令已收到，停止…</p>
</blockquote>
<p>你以为这样就完了么，这只是一个小的case，它还可以管理子节点。其管理与树形结构十分的相似。</p>
<p>除此之外还可以传递值，接下来让我们来看看吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ctx, stop := context.WithCancel(context.Background())</span><br><span class="line">	ctxVal := context.WithValue(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;payne&quot;</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		getValue(ctxVal)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">3</span>)</span><br><span class="line">	stop()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValue</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			user := ctx.Value(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">			fmt.Println(<span class="string">&quot;【获取用户】&quot;</span>, <span class="string">&quot;用户为：&quot;</span>, user)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<blockquote>
<p>【获取用户】 用户为： payne<br>exit…</p>
</blockquote>
<p>总结：</p>
<p>Context为我们主要定义四种方法<code>WithDeadline</code>,<code>WithTimeout</code>,<code>WithValue</code>,<code>WithCancel</code>,从而达到控制goroutine的目的，但却不仅限于我们以上介绍的那样(只介绍了一层，其实可以是多层。形成多对多的关系)，它更深层次的使用你可以想象成多叉树的情况。</p>
<p>context，这一篇就暂且完成啦，期待下一篇。并发模式</p>
<p>并发模式，故名思义。他与设计模式一样，即使用goroutine并发的一些总结。</p>
<p>我将与你探讨</p>
<ul>
<li><code>Goroutine WorkPool</code>:让我们随影所欲的控制创建gototine的数量，且复用。</li>
<li>Pipeline 模式，他像工厂流水线一般，我们将是这将其拆分归并</li>
<li>扇出扇入模式，在pipline的基础上对耗时较长的进行处理</li>
<li>Futures 模式，Pipeline 流水线模式中的工序是相互依赖的，但是在我们的实际需求中，也有大量的任务之间相互独立、没有依赖，所以为了提高性能，这些独立的任务就可以并发执行。</li>
</ul>
<p>期待～</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang第三方包发布详细流程</title>
    <url>/2021/03/31/golang%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E5%8F%91%E5%B8%83%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="发布golang第三方包"><a href="#发布golang第三方包" class="headerlink" title="发布golang第三方包"></a>发布golang第三方包</h3><p>事情是这样的，随着公司的业务的增长。各种重复的工作越来约多。CV久了就想在进一步的那啥，毕竟我懒，不是。我就想着能不能把那些重复cv的干脆写成一个第三方包，进行调用。咱不谈那些啥封装啥的，我也想过，我也做过。但无论咋封装，总不可能跨项目吧,还是需要。。。</p>
<p>所幸，还是有方法的，来吧，让我们发表第一个golang工具包<br><a id="more"></a></p>
<h3 id="创建项目仓库"><a href="#创建项目仓库" class="headerlink" title="创建项目仓库"></a>创建项目仓库</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2ghktr3vj31ml0u0abu.jpg" alt=""></p>
<ol>
<li>首先输入仓库的名字，我这里输入simpleExample，用来做演示</li>
<li>这里选择public，公开。要不并不好拉</li>
<li>选择需要添加的文件(可选)</li>
<li>鼠标左键点击create repository创建此仓库</li>
</ol>
<p>完成后就有一个名为simpleExample的项目仓库，如下图所示。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gnbyu4kj32620nm3zq.jpg" alt=""></p>
<p>如果<code>第三步</code>全都没选的话就是另外一个图了</p>
<blockquote>
<p>这一步还是很简单的，毕竟github，全球最大的程序员交友网站不是。2110年了相信大家还是都会用的，是实在不会的，可自行百度，或者Google。</p>
</blockquote>
<h3 id="拉取仓库，编辑示例代码"><a href="#拉取仓库，编辑示例代码" class="headerlink" title="拉取仓库，编辑示例代码"></a>拉取仓库，编辑示例代码</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gtep6b6j31hs0nigmr.jpg" alt=""></p>
<p>第一步，鼠标左键点击code</p>
<p>第二步，点击后面类似于粘贴板的东西，复制https的URL</p>
<p>然后在cd到GOPATH中使用git，把这个项目clone下来</p>
<p>例如，我在这里的使用的git命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Golzaes/simpleExample.git</span><br></pre></td></tr></table></figure>
<p>执行成功后使用 <code>ls</code>命令查看一下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gzfqf28j31f2032weo.jpg" alt=""></p>
<p>使用编辑器打开<code>simpleExample</code>这个项目文件夹，如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2h1zo9gjj31fy0eugm9.jpg" alt=""></p>
<p><strong>go module初始化</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ go mod init &quot;github.com/Golzaes/simpleExample&quot;</span></span><br><span class="line"><span class="deletion">- go mod init &quot;github.com/组织名/项目名&quot; </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的一定是<code>&quot;github.com/组织名/项目名&quot;</code>这样的格式</p>
</blockquote>
<p>创建文件夹与示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example/example.go</span></span><br><span class="line"><span class="keyword">package</span> exampleCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadNumber create random number</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadNumber</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// random number range</span></span><br><span class="line">	rnr := <span class="number">10</span></span><br><span class="line">	<span class="comment">//  returns, as an int, a non-negative pseudo-random number in [0,n)</span></span><br><span class="line">	<span class="keyword">return</span> rand.Intn(rnr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的函数名<code>ReadNumber</code>，首字母必须大写！！！</p>
<p>否则无法再外部调用此函数</p>
</blockquote>
<p>来个简单的单元测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example/example_test.go</span></span><br><span class="line"><span class="keyword">package</span> exampleCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadNumber</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">		want <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Add test cases.</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;exampleCode1&quot;</span>,</span><br><span class="line">			<span class="number">1</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="string">&quot;exampleCode2&quot;</span>,</span><br><span class="line">			<span class="number">2</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="string">&quot;exampleCode3&quot;</span>,</span><br><span class="line">			<span class="number">3</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="string">&quot;exampleCode4&quot;</span>,</span><br><span class="line">			<span class="number">4</span>,</span><br><span class="line">		&#125;,&#123;</span><br><span class="line">			<span class="string">&quot;exampleCode5&quot;</span>,</span><br><span class="line">			<span class="number">5</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> got := ReadNumber(); got != tt.want &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;ReadNumber() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hje5s3pj31m20u0dhw.jpg" alt=""></p>
<p>有个测试过了，说明我们的代码没有问题，也可以外部调用</p>
<h3 id="推送与发布代码"><a href="#推送与发布代码" class="headerlink" title="推送与发布代码"></a>推送与发布代码</h3><p>使用以下命令，提交与push</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add exampleCode&#x2F;</span><br><span class="line">git commit -am &quot;add exampleCode&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hmyx0dlj31ws0u0409.jpg" alt=""></p>
<p>仔细对比就会发现，这里多了个<code>exampleCode</code>文件夹。到这里我们就已经将代码push到了github，接下来我们发布一个，这样我们可以在另外一个项目中以第三方包的形式使用</p>
<p>第一步，点击releases下面的create a new releases</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hsentogj322q0smgn2.jpg" alt=""></p>
<p>先 填写标签号(常规格式是 x.y.z)例如我的<code>v0.0.1</code>,</p>
<p>填写发表的标题，一般是项目名</p>
<p>填写简介</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hvvs1bsj31pk0u0tal.jpg" alt=""></p>
<p>然后鼠标左键点击 左下方的<code>publish release</code>，进行发布，发布完成后会自动跳转到如下图所示的发布栏</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i0che88j323z0u0zl9.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i0zg0g6j327e0qm3zw.jpg" alt=""></p>
<p>至此，发布部分就已经完成了。那么自己来测试一下这个第三方包</p>
<h3 id="使用发布的第三方包"><a href="#使用发布的第三方包" class="headerlink" title="使用发布的第三方包"></a>使用发布的第三方包</h3><p>新建一个项目、go mod init初始化、创建文件夹就不过多赘述了</p>
<p>下载我们发布的包</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i6hgxrnj31ai044t8u.jpg" alt=""></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/Golzaes/simpleExample/exampleCode</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2ibah1b2j31gt0u0my1.jpg" alt=""></p>
<p>在项目中import 这个包</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文从创建仓库开始到发布第三方包后到使用第三方包，这样我们就可以跨项目使用啦。</p>
<p>如果测试未完成，请重新查阅。尤其是注意点！！！</p>
]]></content>
      <categories>
        <category>Go</category>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy-splash对接代理</title>
    <url>/2020/12/19/scrapy-splash%E5%AF%B9%E6%8E%A5%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="Scrapy-Splash使用及代理失败处理"><a href="#Scrapy-Splash使用及代理失败处理" class="headerlink" title="Scrapy-Splash使用及代理失败处理"></a>Scrapy-Splash使用及代理失败处理</h2><p>在日常做爬虫的时候肯定遇到这么一些问题，网页js渲染，接口加密等，以至于无法有效的获取数据，那么此时若想获取数据大致有两种方向，<code>硬刚加密参数</code>或<code>使用渲染工具</code></p>
<p>二者的各有所不同？</p>
<p>刚加密参数：</p>
<ul>
<li><p>优势：爬取速度快，实效性。损耗资源更少</p>
</li>
<li><p>劣势：耗费时间长，不懂的完全不会，会的也不一定能完全处理。难以在有效的时间内获取到数据</p>
<a id="more"></a>
<p>渲染工具：webdervi，puppeteer，pyppeteer，splash</p>
</li>
<li><p>优势：见效快、新手友好</p>
</li>
<li>劣势：爬取速度较慢、数据实效性难以保证、损耗资源多</li>
</ul>
<p>那么相信做爬虫的小伙伴一定会有相对应的权衡</p>
<blockquote>
<p>个人建议：如果可以刚参数，尽量刚参数。一方面是为了自己的在爬虫这条路上逐步前进，另一方面是更加符合</p>
<p>当然如果实在搞不掉了，也可以使用渲染工具来进行模拟爬取</p>
</blockquote>
<h3 id="splash是什么？"><a href="#splash是什么？" class="headerlink" title="splash是什么？"></a>splash是什么？</h3><p><strong>Splash-一种JavaScript渲染服务</strong></p>
<p>Splash是一种javascript渲染服务。这是一个带有HTTP API的轻量级Web浏览器，使用Twisted和QT5在Python 3中实现。（扭曲的）QT反应器用于使服务完全异步，从而允许通过QT主循环利用Webkit并发性。Splash的一些功能：</p>
<ul>
<li>并行处理多个网页；</li>
<li>获取HTML结果和/或获取屏幕截图；</li>
<li>关闭图片或使用Adblock Plus规则来加快渲染速度；</li>
<li>在页面上下文中执行自定义JavaScript；</li>
<li>编写Lua浏览<a href="https://splash.readthedocs.io/en/stable/scripting-tutorial.html#scripting-tutorial">脚本</a>;</li>
<li>在<a href="https://splash.readthedocs.io/en/stable/kernel.html#splash-jupyter">Splash-Jupyter</a> Notebook中开发Splash Lua脚本。</li>
<li>以HAR格式获取详细的渲染信息。</li>
</ul>
<p>话不多说，直接上splash。谁让我菜呢？</p>
<h3 id="splash的安装"><a href="#splash的安装" class="headerlink" title="splash的安装"></a>splash的安装</h3><p>官方建议直接使用docker进行运行，<a href="https://docs.docker.com/get-docker/">docker安装</a></p>
<p>安装完成之后直接运行一下命令，使用docker运行splash</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取splash</span></span><br><span class="line">docker pull scrapinghub/splash</span><br><span class="line"><span class="comment"># 运行splash </span></span><br><span class="line">docker run -p 8050:8050 --name splash scrapinghub/splash</span><br><span class="line">docker run -itd --name splash  -p 8050:8050 scrapinghub/splash --disable-lua-sandbox</span><br><span class="line"><span class="comment"># -p 向外暴露端口</span></span><br><span class="line"><span class="comment"># -d 守护进程方式运行(后台运行)</span></span><br><span class="line"><span class="comment"># --name 自定义昵称</span></span><br><span class="line"><span class="comment"># --disable-lua-sandbox 关闭沙盒模式。如果是在测试环境上可以直接去体验一下，功能更全。如果是在开发环境的话那就直接用正式的，虽然花里胡哨，但安全性并不好</span></span><br></pre></td></tr></table></figure>
<p>此时你若无意外你可以访问’<a href="http://localhost:8050/&#39;，就可以看到这样的画面">http://localhost:8050/&#39;，就可以看到这样的画面</a></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glt2mblmo3j31kh0u0q51.jpg" alt=""></p>
<p>ok，到这里你就可以正常的使用它了，此时对于新手朋友的关照就已经结束了。接下来让我们对接scrapy。请确保scrapy可以正常运行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">scrapy startproject &lt;projectName&gt;</span><br><span class="line"><span class="comment"># 创建spider</span></span><br><span class="line"><span class="built_in">cd</span> &lt;projectName&gt;</span><br><span class="line">scrapy genspider httpbin httpbin.org/get</span><br></pre></td></tr></table></figure>
<p>此时的项目结构应该如下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glt3ab0oyij30kc0fc3yn.jpg" alt=""></p>
<h3 id="scrapy-splash试用前配置"><a href="#scrapy-splash试用前配置" class="headerlink" title="scrapy-splash试用前配置"></a>scrapy-splash试用前配置</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install scrapy-splash</span><br></pre></td></tr></table></figure>
<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改</span></span><br><span class="line">SPIDER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashDeduplicateArgsMiddleware&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: <span class="number">723</span>,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: <span class="number">725</span>,</span><br><span class="line">    <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: <span class="number">810</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure scrapy-splash(加入)</span></span><br><span class="line">SPLASH_URL = <span class="string">&#x27;http://localhost:8050&#x27;</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&#x27;scrapy_splash.SplashAwareDupeFilter&#x27;</span></span><br><span class="line">HTTPCACHE_STORAGE = <span class="string">&#x27;scrapy_splash.SplashAwareFSCacheStorage&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Httbin.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy_splash <span class="keyword">import</span> SplashRequest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttbinSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;httpbin&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;httbin.org/get&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.start_urls[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">yield</span> SplashRequest(</span><br><span class="line">            url=self.start_urls[<span class="number">0</span>],</span><br><span class="line">            callback=self.parse</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response, **kwargs</span>):</span></span><br><span class="line">        print(response)</span><br><span class="line">        print(response.text)</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行爬虫</span></span><br><span class="line">scrapy crawl httpbin</span><br></pre></td></tr></table></figure>
<p>返回打印结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2020-12-19 13:21:51 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/get via http://localhost:8050/render.html&gt; (referer: None)</span><br><span class="line">&lt;200 https://httpbin.org/get&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=<span class="string">&quot;word-wrap: break-word; white-space: pre-wrap;&quot;</span>&gt;&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Scrapy/2.4.0 (+https://scrapy.org)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd8dea-4ba769963b76178b56cd9724&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;220.202.249.12&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">---略</span><br></pre></td></tr></table></figure>
<p>我们用浏览器访问一下”<a href="https://httpbin.org/get">https://httpbin.org/get</a>“</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Dnt&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;document&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;navigate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;none&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-User&quot;</span>: <span class="string">&quot;?1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd8e50-48c6e9ec6dc7274967b9a493&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;220.202.249.12&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ok，基本的使用也就到这里ok了。那么该如何配置代理呢？访问量一大大多情况下都会封ip</p>
<h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy_splash import SplashRequest</span><br><span class="line"></span><br><span class="line">class HttbinSpider(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;httbin&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;httbin.org/get&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        <span class="built_in">print</span>(self.start_urls[0])</span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Linux; U; Android 0.5; en-us) AppleWebKit/522  (KHTML, like Gecko) Safari/419.3&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># yield scrapy.Request(url=self.start_urls[0], callback=self.parse, headers=header)</span></span><br><span class="line">        yield SplashRequest(</span><br><span class="line">            url=self.start_urls[0],</span><br><span class="line">            callback=self.parse,</span><br><span class="line">            args=&#123;</span><br><span class="line">                <span class="string">&quot;wait&quot;</span>: 3,</span><br><span class="line">                <span class="string">&quot;proxy&quot;</span>: <span class="string">&#x27;http://119.114.100.159:22992&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def parse(self, response, **kwargs):</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">2020-12-19 13:31:06 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/get via http://localhost:8050/render.html&gt; (referer: None)</span><br><span class="line">&lt;200 https://httpbin.org/get&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=<span class="string">&quot;word-wrap: break-word; white-space: pre-wrap;&quot;</span>&gt;&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Scrapy/2.4.0 (+https://scrapy.org)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd9017-7ef5ac1d6c66d99b52b200c0&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;119.114.100.159&quot;</span>, 	<span class="comment"># 代理修改完成</span></span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>使用中间件的方式设置代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHttpProxyMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">	      request.meta[<span class="string">&#x27;splash&#x27;</span>][<span class="string">&#x27;args&#x27;</span>][<span class="string">&#x27;proxy&#x27;</span>] = proxyServer	<span class="comment"># （eg：&#x27;http://119.114.100.159:22992&#x27;）</span></span><br><span class="line">        <span class="comment"># 认证消息，没有可以不写</span></span><br><span class="line">	      <span class="comment"># request.headers[&quot;Proxy-Authorization&quot;] = proxyAuth</span></span><br></pre></td></tr></table></figure>
<p>此时的中间件设置为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;learnSplash.middlewares.MyHttpProxyMiddleware&#x27;</span>: 724,</span><br><span class="line">    <span class="string">&#x27;learnSplash.middlewares.MyUserAgentMiddleware&#x27;</span>: 400,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: 723,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: 725,</span><br><span class="line">    <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: 810,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对接代理错误点总结："><a href="#对接代理错误点总结：" class="headerlink" title="对接代理错误点总结："></a>对接代理错误点总结：</h3><ol>
<li><p>```python</p>
<h1 id="settings中"><a href="#settings中" class="headerlink" title="settings中"></a>settings中</h1><p>SPLASH_URL = ‘<a href="http://localhost:8050">http://localhost:8050</a>‘<br>错写成SPLASH_URL = ‘localhost:8050’ (错误。验证方式command+鼠标左点击，若能正常显示splash页面即可)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;python</span><br><span class="line">   # 爬虫文件中</span><br><span class="line">   args&#x3D;&#123;</span><br><span class="line">   &quot;wait&quot;: 3,</span><br><span class="line">   &quot;proxy&quot;: &#39;http:&#x2F;&#x2F;119.114.100.159:22992&#39;</span><br><span class="line">   &#125;</span><br><span class="line">   # proxy，书写格式不对，缺少http等字段</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="lang-python"># 中间键设置代理
# 错误点一：书写格式不对，缺少http等字段
# 权重设置错误
DOWNLOADER_MIDDLEWARES = &#123;
    &#39;learnSplash.middlewares.MyHttpProxyMiddleware&#39;: 724,
    &#39;learnSplash.middlewares.MyUserAgentMiddleware&#39;: 400,
    &#39;scrapy_splash.SplashCookiesMiddleware&#39;: 723,
    &#39;scrapy_splash.SplashMiddleware&#39;: 725,
    &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;: 810,

&#125;
# MyHttpProxyMiddleware的权重必须小于等于725，否则设定不成功。将使用原始ip访问
</code></pre>
</li>
</ol>
<h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://splash.readthedocs.io/en/stable/">官方文档</a></h3><p><a href="https://github.com/PowerSpider/ScrapySplashTest">完整代码</a></p>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>splash</tag>
        <tag>scrapy-splash</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂二叉树遍历</title>
    <url>/2020/12/11/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="Brush-the-topic-BinaryTree"><a href="#Brush-the-topic-BinaryTree" class="headerlink" title="Brush the topic-BinaryTree"></a>Brush the topic-BinaryTree</h2><p>大家好，这是Brush the topic的第一章节,BinaryTree。首先我说一下为什么把这个放在刷题的第一节呢？</p>
<p>原因如下:</p>
<ul>
<li>培养、训练自己的计算机的思维。</li>
<li>锻炼模版化，抽象化思维</li>
</ul>
<p>下面让我们一起去完成一个壮举，那就是完全解决二叉树的遍历问题，以及相关问题。are you ok？</p>
<h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>由于对于二叉树的遍历顺序不同，构造出三种不同的遍历方式<br><a id="more"></a></p>
<ul>
<li>前序遍历-根左右</li>
<li>中序遍历-左根右</li>
<li>后序遍历-左右根</li>
</ul>
<h4 id="递归代码模版如下"><a href="#递归代码模版如下" class="headerlink" title="递归代码模版如下"></a>递归代码模版如下</h4><p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOreder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    self.traverse_path.append(root.val)</span><br><span class="line">    preOreder(self.left)</span><br><span class="line">    preOreder(self.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOreder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    preOreder(self.left)</span><br><span class="line">    self.traverse_path.append(root.val)</span><br><span class="line">    preOreder(self.right)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOreder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    preOreder(self.left)</span><br><span class="line">    preOreder(self.right)</span><br><span class="line">    self.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure>
<p><strong>Golang</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">  preOreder(root.Left)</span><br><span class="line">  preOreder(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  preOreder(root.Left)</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">  preOreder(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  postOreder(root.Left)</span><br><span class="line">  postOreder(root.Right)</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h3><p>基于此我们可以拿下以下题目,完全二叉树递归模版解题</p>
<h3 id="144-二叉树的前序遍历-Python"><a href="#144-二叉树的前序遍历-Python" class="headerlink" title="144. 二叉树的前序遍历-Python"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>-Python</h3><h4 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a><strong>Recursive</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        self.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, result</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.helper(root.left,result)</span><br><span class="line">        self.helper(root.right, result)</span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            </span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        res+=self.preorderTraversal(root.left)</span><br><span class="line">        res+=self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a><strong>Iterative</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">         stack, result = [], []</span><br><span class="line">         <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">             <span class="keyword">while</span> root:</span><br><span class="line">                 <span class="comment"># 前序遍历-根左右，先拿根</span></span><br><span class="line">                 result.append(root.val)</span><br><span class="line">                 <span class="comment"># 压栈</span></span><br><span class="line">                 stack.append(root)</span><br><span class="line">                 <span class="comment"># 拿完根之后拿左儿子</span></span><br><span class="line">                 root = root.left</span><br><span class="line">             <span class="comment"># 左儿子拿出来，拿右儿子</span></span><br><span class="line">             node = stack.pop()</span><br><span class="line">             root = node.right</span><br><span class="line">        <span class="comment"># # 完成</span></span><br><span class="line">         <span class="keyword">return</span> result</span><br><span class="line">      </span><br><span class="line"><span class="comment"># Solution-2	简化Solution-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution-3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 拿出根</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="comment"># 前序遍历拿出，先拿根的值                </span></span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="comment"># 模仿栈，先入后出。后拿右孩子</span></span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="94-二叉树的中序遍历-Python"><a href="#94-二叉树的中序遍历-Python" class="headerlink" title="94. 二叉树的中序遍历-Python"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>-Python</h3><h4 id="Recursive-1"><a href="#Recursive-1" class="headerlink" title="Recursive"></a><strong>Recursive</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        self.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, result</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left,result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.helper(root.right, result)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            helper(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res+=self.preorderTraversal(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        res+=self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="Iterative-1"><a href="#Iterative-1" class="headerlink" title="Iterative"></a><strong>Iterative</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 2 简化Solution-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><h4 id="Recursive-2"><a href="#Recursive-2" class="headerlink" title="Recursive"></a><strong>Recursive</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        self.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, result</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left,result)</span><br><span class="line">        self.helper(root.right, result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res+=self.preorderTraversal(root.left)</span><br><span class="line">        res+=self.preorderTraversal(root.right)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="Iterative-2"><a href="#Iterative-2" class="headerlink" title="Iterative"></a><strong>Iterative</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solution - 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br><span class="line">      </span><br><span class="line"> <span class="comment"># Solution - 2    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br><span class="line">      </span><br><span class="line"><span class="comment"># Solution - 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">      	<span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>二叉树迭代遍历模版-Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="comment"># Solution-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            root = tmp.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>由递归到迭代，基本的思想就是由递归中由系统维护的栈，转为手动维护。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/03/26/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="进制与位运算"><a href="#进制与位运算" class="headerlink" title="进制与位运算"></a>进制与位运算</h2><p>在我们编程的领域，进制的重要性不言而喻。为什么我的世界只有0与1，这之间到底有什么不可不知的秘密</p>
<p>为什么旁边的“高级工程师”，天天学框架、学架构，反而给他学废了。这一切的一切究竟是计算机的计算扭曲，还是计算机的道德沦丧。今天让我们进入哪个传说中只有0与1的世界。<br><a id="more"></a></p>
<h3 id="进制介绍"><a href="#进制介绍" class="headerlink" title="进制介绍"></a>进制介绍</h3><p>进制是人为定义的带进位的计数方法（有不带进位的计数方法，比如原始的结绳计数法，唱票时常用的“正”字计数法，以及类似的tally mark计数）。 对于任何一种进制—-X进制，就表示每一位置上的数运算时都是逢X进一位。 是逢十进一，是逢十六进一，就是逢二进一，以此类推，x进制就是逢x进位。</p>
<h3 id="常见进制表示"><a href="#常见进制表示" class="headerlink" title="常见进制表示"></a>常见进制表示</h3><p>二进制: 0, 1 逢2进1，常以0b，0B开头</p>
<p>八进制：0-7 逢8进1，常以o开头</p>
<p>十进制：0-9 逢10进1</p>
<p>十六进制：逢16进1，0-9 A(10)-F(15 )常以0x开头</p>
<h3 id="进制运算"><a href="#进制运算" class="headerlink" title="进制运算"></a>进制运算</h3><p>二进制数的加法和乘法基本运算法则各有四条，如下：</p>
<p>0+0=0，0+1=1，1+0=1，1+1=10</p>
<p>0×0=0，0×1=0，1×0=0，1×1=1</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h4><p>一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，<a href="https://baike.baidu.com/item/逆序">逆序</a>排列余数即可得到――简称除二取余法．</p>
<p>上面这段话是什么意思呢？逆序排列即二进制中的从高位到低位排序</p>
<p>如以下为例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 十进制11的二进制</span></span><br><span class="line">11 ➗ 2 = 5 	余 1</span><br><span class="line"> 5 ➗ 2 = 2  余 1</span><br><span class="line"> 2 ➗ 2 = 1  余 0 </span><br><span class="line"> 1 ➗ 2 = 0  余 1</span><br><span class="line"></span><br><span class="line">11 = (1011)2</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>十进制数除以 2 ，得到商和余数；</li>
<li>再用第一步的商除以 2,得到新的商和余数；</li>
<li>重复第 1 和第 2 步，直到商为 0;</li>
<li>将先得到的余数作为二进制数的高位，后得到的余数作为二进制数的低位，依次排序；</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decimal_to_binary</span>(<span class="params">value: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0b0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Accepted parameters must be int&quot;</span>)</span><br><span class="line">    flag = <span class="literal">False</span> <span class="keyword">if</span> value &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">    value = <span class="built_in">abs</span>(value)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> value:</span><br><span class="line">        <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            result.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        value &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0b&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>]) <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">&#x27;-0b&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h4><p>二进制转化为十进制的原理，(二进制数长度(不含0b) - 1) 次方  X 此位置的数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0b1101 13</span><br><span class="line">2的3次方 乘 1 + 2的2次方 乘 1 + 2的1次方 乘 0 + 2的0次方 乘 1</span><br><span class="line">8 + 4 + 0 + 1</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_to_decimal</span>(<span class="params">binary: <span class="built_in">str</span></span>):</span></span><br><span class="line">    binary_list = binary.split(<span class="string">&quot;0b&quot;</span>)[-<span class="number">1</span>] <span class="keyword">if</span> <span class="string">&#x27;0b&#x27;</span> <span class="keyword">in</span> binary <span class="keyword">else</span> binary</span><br><span class="line">    <span class="comment">#  判断是否为正数</span></span><br><span class="line">    flag = <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> binary <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(binary_list):</span><br><span class="line">        a = <span class="number">2</span> ** <span class="built_in">int</span>(<span class="built_in">len</span>(binary_list) - index - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">sum</span> += a * <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">f&#x27;-<span class="subst">&#123;<span class="built_in">sum</span>&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13: </span><br><span class="line">binary：0b1101 </span><br><span class="line">oct：(001) (101) 0o15</span><br><span class="line">hex：0000 (1101) 0xd</span><br></pre></td></tr></table></figure>
<p>同理得进制转换</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>现代的计算器技术全部采用的是二进制，因为他只使用0、1两个数字符号，非常简单方便，易于计算机实现。计算机内部都是采用二进制数来表示</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang操作文件的那些事儿</title>
    <url>/2020/11/28/%E4%BD%BF%E7%94%A8Golang%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="Golang-文件操作"><a href="#Golang-文件操作" class="headerlink" title="Golang 文件操作"></a>Golang 文件操作</h2><p>Os模块的使用与源码研究</p>
<p>文件：计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。例如咱们常见的文件后缀名<code>.exe</code>,<code>.txt</code>,’.word’…等等</p>
<p>文件的基本操作可简单分为<code>增</code>、<code>删</code>两类，也就是咱们所说的CURD(增删改查)，也是基于此两类操作。可简单理解为<code>打开文件夹</code>、<code>CURD</code>、关闭文件夹。结束～</p>
<p>golang对于文件基本上都是基于Golang的<code>os</code>模块，那让我们一起了解一下，那么Golang是如何对文件进行操作呢。Let’s Go~<br><a id="more"></a></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>Golang中打开文件使用<code>os.Open</code>模块,官方os.open部分源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os.Open</span></span><br><span class="line"><span class="comment">// Open opens the named file for reading. If successful, methods on</span></span><br><span class="line"><span class="comment">// the returned file can be used for reading; the associated file</span></span><br><span class="line"><span class="comment">// descriptor has mode O_RDONLY.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Open打开命名文件以供读取。如果成功，则可以使用返回文件上的方法进行读取；关联的文件。描述符的模式为O_RDONLY。 如果有错误，它将是* PathError类型。</p>
<p>它接收一个string 类型的变量<code>name</code>,返回两个值，File的指针和错误error。那么我们使用它打开文件的的时候就需要这样做</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fileObj, err := os.Open(name <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 其中os.Open中的name为路径Path</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>基础使用的介绍暂且为止，其实我们更应该关心的应该是<code>OpenFile(name, O_RDONLY, 0)</code>，这个函数到底干了啥，我们追踪一下这个函数(在GoLang编辑器中， mac可以直接使用command + 鼠标左键直接进入，Win可以使用ctrl + 鼠标左键)，如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	testlog.Open(name)</span><br><span class="line">	f, err := openFileNolog(name, flag, perm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OpenFile是广义的open调用；大多数用户将使用Open 或Create代替。它打开带有指定标志的命名文件（O_RDONLY等）。如果该文件不存在，并且传递了O_CREATE标志，则会使用模式perm（在umask之前）创建该文件。如果成功，返回文件上的方法可以用于I / O。 如果有错误，它将是* PathError类型。</span></span><br></pre></td></tr></table></figure>
<p>这个文件全部内容还是有点分量的，有信息的伙伴，可以详细的阅读一下全部内容。暂且为止</p>
<p>那让我们实践一下，使用Golang打开文件，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line">	fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Open File Error Message:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line">	fmt.Println(&amp;fileObj)</span><br><span class="line">	<span class="comment">// defer 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> fileObj.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44ct0b29j31fu0u07d6.jpg" alt=""></p>
<p>以防忘记关闭文件，造成bug，我们在这里使用defer + 关闭。</p>
<blockquote>
<p>注意：在编辑器中并不建议直接使用鼠标右键运行，这样可能会导致路径错误。大部分的编辑器都并不是只运行此文件!!!</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Open File Error Message:&amp;os.PathError&#123;Op:<span class="string">&quot;open&quot;</span>, Path:<span class="string">&quot;./main.go&quot;</span>, Err:0x2&#125;</span><br></pre></td></tr></table></figure>
<p>如果你遇见了类似的错误，你可以直接在终端中，切换到当前路径。使用<code>go run main.go</code>，直接运行。这样就可以直接得到正确的结果啦</p>
</blockquote>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>打开文件之后，那么我们可以就可以对他们进行操作了，我们在这里主要演示一下读取文件的操作。还是老样子，先看一下主要的相关源码，如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileObj.Read()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	n, e := f.read(b)</span><br><span class="line">	<span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f.read(b)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	n, err = f.pfd.Read(b)</span><br><span class="line">	runtime.KeepAlive(f)</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileObj.Read()</p>
<p>示例化接受文件的地址值(也就是咱们前面打开获取到的结果)，接受切片的字节，返回读取的内容，以及错误</p>
<p>在此函数中首先检查是否为有效的读取，然后在进行f.read(b)的操作,接受其返回结果。</p>
<p>f.read(b)</p>
<p>在这里，主要检测是否在读取，如果是那么返回本次的读取内容</p>
</blockquote>
<p>从以上我们不难看出，其实读取文件是读取文件内部的字节</p>
<p>那么更具FileObj.Read()，我们可以了解它基本的使用方法，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>读取部分的示例代码如下：</p>
<p>在这里我们需要考虑：是否能够正常读取？是否读完了？具体请看异常处理部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">	<span class="comment">// 定义每次读取的大小</span></span><br><span class="line">	<span class="comment">//var tmp = make([]byte, 128)</span></span><br><span class="line">	<span class="keyword">var</span> tmp  [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// n:从开始到结尾的内容</span></span><br><span class="line">	n, err := fileObj.Read(tmp[:])</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取了%d个字节\n&quot;</span>, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取到的内容：\n%s&quot;</span>,tmp[:])</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl453fvstjj30su0fg75h.jpg" alt=""></p>
<p>以上很明显是并没有读完的仅读取了部分，原始的全部代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line">	fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line">	fmt.Println(&amp;fileObj)</span><br><span class="line">	<span class="comment">// defer 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	<span class="comment">// 定义每次读取的大小</span></span><br><span class="line">	<span class="comment">//var tmp = make([]byte, 128)</span></span><br><span class="line">	<span class="keyword">var</span> tmp  [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// n:从开始到结尾的内容</span></span><br><span class="line">	n, err := fileObj.Read(tmp[:])</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取了%d个字节\n&quot;</span>, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取到的内容：\n%s&quot;</span>,tmp[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完整读取"><a href="#完整读取" class="headerlink" title="完整读取"></a>完整读取</h3><h4 id="for无线循环读取"><a href="#for无线循环读取" class="headerlink" title="for无线循环读取"></a>for无线循环读取</h4><p>由于以上我们并没有读取完整个文件，那么我需要读取全部的该怎么办呢？一个方法是不断的读取下去，然后和在一起就是完整的内容了，示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line">	fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line">	fmt.Println(&amp;fileObj)</span><br><span class="line">	<span class="comment">// defer 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> fileObj.Close()</span><br><span class="line">	<span class="comment">// 循环读取文件</span></span><br><span class="line">	<span class="keyword">var</span> content []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := fileObj.Read(tmp)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要的思路为：无限循环去读取，读完了之后break掉。然后把读取的内容合并起来</p>
<p>这种读取虽然可行，不过是否有点太麻烦了，那么有什么更简便的方式呢？答案当然是有的，bufio读取</p>
<h4 id="bufio读取"><a href="#bufio读取" class="headerlink" title="bufio读取"></a>bufio读取</h4><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>
<p>主要的部分源码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bufio.NewReader</span></span><br><span class="line"><span class="comment">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewReaderSize</span></span><br><span class="line"><span class="comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">	<span class="comment">// Is it already a Reader?</span></span><br><span class="line">	b, ok := rd.(*Reader)</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">		size = minReadBufferSize</span><br><span class="line">	&#125;</span><br><span class="line">	r := <span class="built_in">new</span>(Reader)</span><br><span class="line">	r.reset(<span class="built_in">make</span>([]<span class="keyword">byte</span>, size), rd)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它简便的原因是因为已经帮我们定义了文件的指针，以及它还定义了缓冲区，这样我们使用它来读取更加的快与便捷。</p>
<p> bufio.NewReader语法格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> </span><br><span class="line"><span class="comment">// 其中rd为我们打开文件的对象</span></span><br></pre></td></tr></table></figure>
<p>使用如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line">	fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">	<span class="comment">// 异常处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line">	fmt.Println(&amp;fileObj)</span><br><span class="line">	<span class="comment">// defer 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> fileObj.Close()</span><br><span class="line">	<span class="comment">// bufio读取</span></span><br><span class="line">	reader := bufio.NewReader(fileObj)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//注意是字符</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(line)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入结果如上，略。。。</p>
<p>搞了这么多，就没有一键读取的么？当然也是有的，让我们来了体验一下<code>ioutil</code>读取整个文件的愉悦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io&#x2F;ioutil&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ioutil.ReadFile读取整个文件</span><br><span class="line">func main() &#123;</span><br><span class="line">	content, err :&#x3D; ioutil.ReadFile(&quot;.&#x2F;main.go&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(string(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部的实现原理，先预测整个文件的大小。然后一次性全部读取。当然需要做好异常的准备哦</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadFile reads the file named by filename and returns the contents.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadFile</span></span><br><span class="line"><span class="comment">// reads the whole file, it does not treat an EOF from Read as an error</span></span><br><span class="line"><span class="comment">// to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span></span><br><span class="line">	<span class="comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span></span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// As initial capacity for readAll, use Size + a little extra in case Size</span></span><br><span class="line">		<span class="comment">// is zero, and to avoid another allocation after Read has filled the</span></span><br><span class="line">		<span class="comment">// buffer. The readAll call will read into its allocated internal buffer</span></span><br><span class="line">		<span class="comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span></span><br><span class="line">		<span class="comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span></span><br><span class="line">		<span class="comment">// it just right.</span></span><br><span class="line">		<span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">			n = size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h3><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>os.O_WRONLY</code></td>
<td style="text-align:center">只写</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_CREATE</code></td>
<td style="text-align:center">创建文件</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_RDONLY</code></td>
<td style="text-align:center">只读</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_RDWR</code></td>
<td style="text-align:center">读写</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_TRUNC</code></td>
<td style="text-align:center">清空</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_APPEND</code></td>
<td style="text-align:center">追加</td>
</tr>
</tbody>
</table>
</div>
<p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p>
<h4 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(test.txt<span class="string">&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</span></span><br><span class="line"><span class="string">	if err != nil &#123;</span></span><br><span class="line"><span class="string">		fmt.Println(&quot;</span>open file failed, err:<span class="string">&quot;, err)</span></span><br><span class="line"><span class="string">		return</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	defer file.Close()</span></span><br><span class="line"><span class="string">	str := &quot;</span>hello<span class="string">&quot;</span></span><br><span class="line"><span class="string">	file.Write([]byte(str))       //写入字节切片数据</span></span><br><span class="line"><span class="string">	file.WriteString(&quot;</span>hello<span class="string">&quot;) //直接写入字符串数据</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(<span class="string">&quot;hello&quot;</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">	&#125;</span><br><span class="line">	writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	err := ioutil.WriteFile(<span class="string">&quot;./asd.txt&quot;</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>so cool～</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>执行一条SQL，这之间到底发生了啥？</title>
    <url>/2021/01/03/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%EF%BC%8C%E8%BF%99%E4%B9%8B%E9%97%B4%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="MySQL模型初探"><a href="#MySQL模型初探" class="headerlink" title="MySQL模型初探"></a>MySQL模型初探</h3><p>MySQL基础结构是采用典型的C/S工作模型(即是server/client)<br><a id="more"></a><br>以sshd与xshell为例,如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9saa2hxxj30s60f0wfd.jpg" alt=""></p>
<h2 id="MySQL客户端实例："><a href="#MySQL客户端实例：" class="headerlink" title="MySQL客户端实例："></a>MySQL客户端实例：</h2><p>Mysql客户端主要有以下功能</p>
<ul>
<li>连接数据库</li>
<li>发送指令</li>
</ul>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>socket连接方式与远程TCP/IP连接</p>
<p>在Linux中<code>/etc/my.cnf</code>文件中显示（已完成Mysql的安装）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socket= /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例如下</span></span><br><span class="line">root@ecs-dc8a-0003:~<span class="comment"># cat /etc/my.cnf                                                                                        </span></span><br><span class="line">[client]</span><br><span class="line"><span class="comment">#password       = your_password</span></span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line">datadir = /www/server/data</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">performance_schema_max_table_instances = 400</span><br><span class="line">table_definition_cache = 400</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 1024M</span><br><span class="line"></span><br><span class="line">---略</span><br></pre></td></tr></table></figure>
<h3 id="连接mysql的两种方式实现"><a href="#连接mysql的两种方式实现" class="headerlink" title="连接mysql的两种方式实现"></a>连接mysql的两种方式实现</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">way1: <span class="comment"># 只能在本地使用，不依靠ip地址与端口号</span></span><br><span class="line">在本地可直接使用如下命令进行scoket连接	</span><br><span class="line">mysql -S /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">way2: <span class="comment"># “远程”连接(基于TCP/IP)</span></span><br><span class="line">mysql -h ip -P 3306 -u username -p passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常用参数示例:</p>
<p><code>-S</code>:    指定socker文件</p>
<p><code>-h</code>:   指定连接ip地址</p>
<p><code>-P</code>：指定连接端口号，默认为3306</p>
<p><code>-u</code>:  指定连接用户名</p>
<p>`-p    指定连接密码</p>
</blockquote>
<h3 id="发送指令"><a href="#发送指令" class="headerlink" title="发送指令"></a>发送指令</h3><p>即发送操作数据库指令(SQL语句)</p>
<blockquote>
<p><strong>SQL种类</strong></p>
<p>DDL 数据定义语言</p>
<p>DCL 数据控制语言</p>
<p>DML 数据操作语言</p>
<p>DQL 数据查询语言</p>
</blockquote>
<h2 id="服务器端-实例"><a href="#服务器端-实例" class="headerlink" title="服务器端(实例):"></a>服务器端(实例):</h2><p>实例：My sqld + 工作线程 + 预分配内存 </p>
<p>功能：管理数据(增删改查等)</p>
<h3 id="Mysqld工作模型"><a href="#Mysqld工作模型" class="headerlink" title="Mysqld工作模型"></a>Mysqld工作模型</h3><p>Mysqld的工作模型可分为两块，<code>server</code>层，<code>引擎层</code>，server层可细分为<code>连接层</code>、<code>SQL层</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmace22omuj30em0jit8k.jpg" alt="Mysqld工作模型"></p>
<h3 id="连接层：提供连接"><a href="#连接层：提供连接" class="headerlink" title="连接层：提供连接"></a>连接层：提供连接</h3><ol>
<li>提供可连接协议，例如（TCP/IP， socket）</li>
<li>验证用户名密码等连接</li>
<li>提供专用的连接线程</li>
</ol>
<p>在mysql命令行中使用<code>show processlist;</code>查看连接线程,如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmacry3p4cj31p608wab1.jpg" alt=""></p>
<h3 id="SQL层：执行SQL"><a href="#SQL层：执行SQL" class="headerlink" title="SQL层：执行SQL"></a>SQL层：执行SQL</h3><ol>
<li>验证SQL语句(语法检查)</li>
<li>语意(SQL语句种类，DDL，DCL，DML，DQL… …)</li>
<li>权限验证</li>
<li>解析器：解析预处理，列举所有可行的方案</li>
<li>优化器：mysql会采用自己的估价函数去预估选择”最优执行”方法</li>
<li>执行器：执行其按照优化器选择执行SQL语句</li>
<li>日志记录(bingo二进制日志\glog，默认不开启。需人工开启)</li>
</ol>
<p>Mysql中有查询缓存这么一说(query_cache,默认不开启)，当业务量有大量相同的查询等操作，我们一般采用Redis进行一个缓存.</p>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>相当于Linux中文件系统，与磁盘交互的模块</p>
<h2 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h2><p>那么各层之间有什么作用呢？请听我细细说来，在这样我们使用一条SQL语句执行流程来理解一下此流程。</p>
<p>当需要执行SQL语句的时候，必然需要服务端（Mysqld）存在，那么我们无论如何是需要首先开启mysqld的服务</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmahqqq935j31000sgwj9.jpg" alt=""></p>
<h3 id="服务端开启"><a href="#服务端开启" class="headerlink" title="服务端开启"></a>服务端开启</h3><p>首先开启mysql服务即(Mysqld),成功开启此服务后，主要体现为<code>mysqld实例</code>，开启工作线程，向系统申请内存(此内存为预分配内存，一旦分配无论使用与否，其他应用均不可使用)</p>
<p>mysqld开启后，打开server层 存储引擎层，其中server层中连接层提供连接，sql层准备接受客户端指令，存储引擎层与系统磁盘交互。至此mysqld服务开启成功</p>
<h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>假设mysql服务端启动完成之后，我们可以采用<code>TCP/IP</code>或者<code>socket</code>协议连接mysql数据库。那么我们此时便发起连接请求。输入以下连接命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h ip -P 3306 -u username -p passwd</span><br></pre></td></tr></table></figure>
<p>服务端接受到连接请求，将会进行以下几步操作。(发生在服务端，肉眼无法直接看见)</p>
<p>首先会验证连接请求的账号与密码。去mysql.user表中去寻找账号名，账号名不存在断开连接，账号存在下一步寻找对应加密了的密码。与之对应验证。验证成功后，分配此连接专用的连接线程。并提供服务。</p>
<p>连接成功之后如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai4ejkq8j31920gs0us.jpg" alt=""></p>
<p>接下来我们，在mysql的终端上执行如下sql查询语句,它的意思是从mysql库中的user表查询字段名(表头)为<code>host,name</code>的所有内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select host,name from mysql.user;</span><br></pre></td></tr></table></figure>
<p>当mysqld接收到此指令之后，会进行以下几步操作。</p>
<ol>
<li><p>语法检查，如果语法不属于sql语句系列，直接抛出错误，终止执行此语句。若通过之后执行下一步</p>
</li>
<li><p>语义，进一步释意sql语句。若表不存在，字段名不存在。直接抛出错误，终止执行此语句。若通过之后执行下一步</p>
</li>
<li><p>验证<code>用户权限</code>，顾名思义，这个没什么好说的</p>
</li>
<li><p>解析预处理，经过层层验证到了此步骤之后，说明此语句是可以被执行的。那么此时mysqld会采用”演练”枚举列出所有的可执行方案。我们或多或少的知道，需要达到相同的效果，达成的方法有各种各样。此时mysql会列举出所有的方案。例如，以”select host,name from mysql.user;”这条SQL语句为例，它可达到目的的方式至少有两种，</p>
<ul>
<li>方案1.对mysql下的user表进行全表查询，后截断塞选出user表查询字段名(表头)为<code>host,name</code>的所有内容。</li>
<li>方案2.对mysql下user表字段<code>host,name</code>进行查询，后直接输出</li>
</ul>
<p>虽然二者执行的结果是一致的但资源消耗却并不是一致的</p>
</li>
<li><p>优化器，经过上一步的解析预处理之后，这一步mysql会采用直接的估计函数，进行资源损耗的预估，从而选择“最优”</p>
</li>
<li><p>得到优化器的方案选举结果，执行</p>
</li>
<li><p>到存储引擎层申请数据，存储引擎层向磁盘获取数据</p>
</li>
<li><p>查询</p>
</li>
<li><p>查询成功，释放内存</p>
</li>
<li><p>输出</p>
</li>
</ol>
<p>执行成功后，如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmaifmwzqfj30mu0ca74v.jpg" alt=""></p>
<p>那么到这里你可能会有以下两个疑问</p>
<p>疑问一：</p>
<p>既然mysql有‘优化器’来帮助我们进行最优的执行方案，那么是否我们的SQL语句只要能正常运行就好了呢？反正它都是“最优的”执行方案。</p>
<p>理论上确实如此，但是实际上却并不一定是这样的。mysql的优化器仅仅帮我们达到了局部最优，而不是全局最优。类似于“贪心算法”思路，我们得到的最终结果就并不一定是全局最优的。我们以以下一个场景来说明这一情况。</p>
<p>我们需要在student表中查询一条数据并输出。此数据需求为name为张三,其中student表中数据量过十亿(就是没做分表，求不杠)</p>
<p>达到此方案的需求有三种方案</p>
<ul>
<li>全表查询，挑选出name为张三的所有信息的这一行，进行输出。</li>
<li>student表，字段名name，全查询。查到name为张三后以此行为“起始点”，横向拓展，获取到张三的所有信息</li>
<li>student表，字段名name，迭代查询。</li>
</ul>
<p>方法3无疑是全局最优的方案,而优化器能帮我选举出的防范最多到方案2。为什么呢？</p>
<p>详细了解过mysql的运行原理的朋友就会知道，执行查询语句的时候，mysql的存储引擎层会将“user”表所有的数据从系统的磁盘上读到存储引擎层，然后进行查询。如果内存释放不及时，由于数据量的增加而造成内存溢出。说不定mysql就挂彩了</p>
<p>那么迭代查询好处是可以及时的释放内存，查过的读出来后又放回磁盘中，这样就避免了内存不足而造成的隐患。当然也有一个隐患那就是I/O操作密集，而造成查询速度过慢。那么这个也是没有办法的事情，所以在合适的场景选择合适的方案尤为重要。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫优化之道</title>
    <url>/2021/05/26/%E7%88%AC%E8%99%AB%E4%BC%98%E5%8C%96%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><h3 id="网络爬虫的定义"><a href="#网络爬虫的定义" class="headerlink" title="网络爬虫的定义"></a>网络爬虫的定义</h3><p>爬虫又称为网络蜘蛛、网页追逐者。是一种按照一定的规则，自动地抓取万维网信息的程序或脚本</p>
<p>同时还有很多种说法,但我个人认为最通俗的理解就是，模拟用户访问的程序或脚本。</p>
<a id="more"></a>
<h3 id="网络爬虫实现的核心步骤"><a href="#网络爬虫实现的核心步骤" class="headerlink" title="网络爬虫实现的核心步骤"></a>网络爬虫实现的核心步骤</h3><p>无论多么复杂的爬虫都离不开以下核心的四步，当然极少数特例除外。</p>
<ul>
<li><p>确定数据URL</p>
</li>
<li><p>发送请求,获取响应</p>
</li>
<li><p>解析响应，获取数据</p>
</li>
<li><p>数据持久化</p>
</li>
</ul>
<h2 id="网络爬虫优化"><a href="#网络爬虫优化" class="headerlink" title="网络爬虫优化"></a>网络爬虫优化</h2><p>无论是何种方向，我们都希望以更少的代价获取更大的收益，相信优化这一个话题一直是大家所探讨的。</p>
<p>决定网络爬虫性能的指标有很多，在不考虑特殊情况及阀值情况下</p>
<p>网络请求更快，解析效率更快，数据持久化更快等，那么爬虫会更快，这个是必然的</p>
<p>那么网络爬虫该如何优化，且听我从以下几个方面进行分析。</p>
<ol>
<li>分布式爬虫：更多的worker</li>
<li>减少重复或无效的网络请求、减少或分割繁琐的请求流程</li>
<li>网络优化</li>
<li>解析优化</li>
<li>数据持久化</li>
</ol>
<h3 id="爬虫优化第一式-分布式爬虫"><a href="#爬虫优化第一式-分布式爬虫" class="headerlink" title="爬虫优化第一式-分布式爬虫"></a>爬虫优化第一式-分布式爬虫</h3><p>在网络爬虫的世界中，我们爬虫工程师开发的爬虫一般都是聚焦爬虫，而一个网站的数据量假设是个常量。那么爬虫的任务量也是个定值。那么更多的爬虫，一定是比单机单任务爬虫更快的。</p>
<blockquote>
<p>一般来说我们接触网站的数据增长量，还没有达到那种成几何倍数增长的情况。在这里只为论述大多情况下。特殊情况下例外</p>
</blockquote>
<p>分布式爬虫概念，在此便不再过多赘述，感兴趣的朋友可以自行搜索。</p>
<p>实现分布式爬虫的核心理念就是任务共有化统一调度。在这里爬虫领域，我们可以简单的理解为URL或URN的管理。只要管理好了URL或URN，分布式爬虫相信你实现起来也并不困难。分布式爬虫基础架构图如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gquzrwsspdj30r50do0sr.jpg" alt=""></p>
<p><strong>分布式爬虫优化之一，氪金：</strong></p>
<p>只要机器够多，配置够高，集群够强大。那么日入过亿so easy。</p>
<p><strong>分布式爬虫优化之二：部署优化</strong></p>
<p>在以上的基础上，对于资源利用并不能够达到一个很完美的情况。如果有上百台机器，一个一个去启动爬虫没开完，爬虫工程师们就累死在了半路上。</p>
<p><strong>部署优化之一:单机批量运行</strong></p>
<blockquote>
<p>在一台机器机器中是允许开启多个爬虫！！！</p>
</blockquote>
<p>使用shell脚本，进行批量运行。</p>
<p>使用subprocess，进行批量运行。</p>
<p><strong>部署优化之二：虚拟容器</strong></p>
<p>在以上的基础上，我还建议你使用 docker，Kubernetes进行多机器分布式爬虫的部署。只需要短短几个命令即可部署到服务器。</p>
<p>这样就可以实现快捷部署</p>
<h3 id="爬虫优化第二式：爬取策略"><a href="#爬虫优化第二式：爬取策略" class="headerlink" title="爬虫优化第二式：爬取策略"></a>爬虫优化第二式：爬取策略</h3><p>减少重复或无效的网络请求、减少或分割繁琐的请求流程。</p>
<p>首先我们来看个较经典的页面结构图，大部分页面都是一种B*树 或者图的数据结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv1hqdepcj31400u04qr.jpg" alt=""></p>
<div style="text-align: center;">首页简称Index，列表页简称List， 详情页简称detail</div>



<p>网页结构的不同采用不同遍历方式也不同，采用先深度后广度将是最快的“路径”。</p>
<p>如果detail可以一直获取到下一页</p>
<p>直接从起始页到最后一页。时间复杂度为O(N),N为总页数</p>
<p>如果只能列表页才能获取详情页</p>
<p>翻页获取下一页，可从先遍历List页后遍历获取详情页。时间复杂度为O(MN), M为列表页数，N为详情页数</p>
<p>如果是图，建议转化为树形结构进行考虑</p>
<blockquote>
<p>小技巧：</p>
<p>如何制定抓取策略？</p>
<p>建议自底向上的方式，先考虑详情页是否可以直达，后考虑列表页从而间接获取详情页</p>
</blockquote>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>如果是分布式爬虫，那么我们可以使用生产者-消费者模型的概念。ListCrwaler获取详情url，存入URL-Pool中</p>
<p>如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv21zh059j30f70asglk.jpg" alt=""></p>
<blockquote>
<p>存入到URL-pool中建议使用Set进行URL去重。当URL过大的时候我们可以剔除公共部分，仅保存Id。</p>
<p>若数据量极大，可使用<strong>BloomFilter算法</strong></p>
</blockquote>
<h3 id="爬虫优化第三式-请求优化"><a href="#爬虫优化第三式-请求优化" class="headerlink" title="爬虫优化第三式: 请求优化"></a>爬虫优化第三式: 请求优化</h3><h4 id="异常处理之超时"><a href="#异常处理之超时" class="headerlink" title="异常处理之超时"></a>异常处理之超时</h4><p>当连接超过某个阀值，可判定此次请求失败。个人偏爱timeout 为60s</p>
<h4 id="提高并发量"><a href="#提高并发量" class="headerlink" title="提高并发量"></a>提高并发量</h4><p>合适的并发量可以将资源使用到极致，合适的并发量可以从按照实际情况调。</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><h3 id="爬虫优化第四式：网络优化"><a href="#爬虫优化第四式：网络优化" class="headerlink" title="爬虫优化第四式：网络优化"></a>爬虫优化第四式：网络优化</h3><h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><p><strong>网络带宽</strong></p>
<h4 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h4><p><strong>域名系统</strong>（<a href="https://baike.baidu.com/item/英文">英文</a>：<strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem，<a href="https://baike.baidu.com/item/缩写">缩写</a>：<strong>DNS</strong>）是<a href="https://baike.baidu.com/item/互联网">互联网</a>的一项服务。它作为将<a href="https://baike.baidu.com/item/域名">域名</a>和<a href="https://baike.baidu.com/item/IP地址">IP地址</a>相互<a href="https://baike.baidu.com/item/映射">映射</a>的一个<a href="https://baike.baidu.com/item/分布式数据库">分布式数据库</a>，能够使人更方便地访问网页。</p>
<p>简易的访问步骤到获取到呈现页面</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv2nmieu3j30f90c1wec.jpg" alt=""></p>
<p>当大规模抓取每次都要做DNS解析时，浪费的时间是非常大的。所以如果能在本地做DNS缓存，每次系统都读本地DNS的话，这个时间消耗大大降低。</p>
<p><strong>实现DNS缓存的常见几种方法</strong></p>
<p>最简单的方法就是直接修改/etc/hosts文件，在文件里直接添加IP和域名，例如这样</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv30rtefqj30mt0bbjrk.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv3074tn5j30s60apmx7.jpg" alt=""></p>
<p>第二种方式：使用DNS缓存工具，例如DNSmasq</p>
<h3 id="爬虫优化第五式：解析优化"><a href="#爬虫优化第五式：解析优化" class="headerlink" title="爬虫优化第五式：解析优化"></a>爬虫优化第五式：解析优化</h3><p>智能解析算法</p>
<h3 id="爬虫优化第六式：数据持久化优化"><a href="#爬虫优化第六式：数据持久化优化" class="headerlink" title="爬虫优化第六式：数据持久化优化"></a>爬虫优化第六式：数据持久化优化</h3><p>一次插入多条</p>
<p>异步插入多条</p>
<h3 id="爬虫优化第七式：多数据源"><a href="#爬虫优化第七式：多数据源" class="headerlink" title="爬虫优化第七式：多数据源"></a>爬虫优化第七式：多数据源</h3><p>单一的数据源难免由于并发量过大，给目标网站造成DDos攻击。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分别从分布式爬虫，抓取策略、请求优化、网络优化、解析优化、与多数据源方面进行考虑。希望对你能够有所启发</p>
<p>最后在开启超大规模的爬虫建议计算对方的带宽压力，不要抓取太过分了。抓取归抓取，但不要影响对方网站正常运营。</p>
<div style="text-align: center;">以上便是鄙人所知所用的爬虫方法论，希望能帮助到你。</div>]]></content>
      <categories>
        <category>爬虫</category>
        <category>Crawler</category>
        <category>Web Spider</category>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Crawler</tag>
        <tag>Web Spider</tag>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>新mac使用技巧入门指北</title>
    <url>/2021/04/26/%E6%96%B0mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>当第一手拿到mac，第一件事也许是去。。。</p>
<p>然而我想要说的是，把基本的环境搭建一下，设置调配一下<br><a id="more"></a></p>
<h3 id="键盘、鼠标的灵敏度"><a href="#键盘、鼠标的灵敏度" class="headerlink" title="键盘、鼠标的灵敏度"></a>键盘、鼠标的灵敏度</h3><p>这也是个人习惯吧，我个人比较畅想那种打字、拖鼠标丝滑的感觉</p>
<p>偏好设置 -&gt; 鼠标灵敏度看自己感觉拉。</p>
<p>偏好设置 -&gt; 键盘</p>
<blockquote>
<p>个人建议拉满</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gpxcygvyc2j31100mctht.jpg" alt="image-20210426191253111"></p>
<h2 id="定制zsh编辑器"><a href="#定制zsh编辑器" class="headerlink" title="定制zsh编辑器"></a>定制zsh编辑器</h2><p>原生的mac，zsh是没有命令提示的，以及显示也并没有那么好看。自定制一下</p>
<h4 id="下载oh-my-zsh"><a href="#下载oh-my-zsh" class="headerlink" title="下载oh-my-zsh"></a>下载oh-my-zsh</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure>
<h4 id="复制-zshrc"><a href="#复制-zshrc" class="headerlink" title="复制 .zshrc"></a>复制 .zshrc</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="修改默认-shell-可选"><a href="#修改默认-shell-可选" class="headerlink" title="修改默认 shell(可选)"></a>修改默认 shell(可选)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>在终端中新建一个窗口(快捷键：command + n），你就发现不一样的shell，如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gpxd433qdsj317o0e0wes.jpg" alt="image-20210426191816929"></p>
<h4 id="配置命令补全的插件"><a href="#配置命令补全的插件" class="headerlink" title="配置命令补全的插件"></a>配置命令补全的插件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions ～/.oh-my-zsh/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<h4 id="编辑-zshrc-文件"><a href="#编辑-zshrc-文件" class="headerlink" title="编辑 .zshrc 文件"></a>编辑 .zshrc 文件</h4><p>找到<code>plugins=(git)</code>,修改成<code>plugins=(git zsh-autosuggestions)</code></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gpxee9jh16j30zc06wtb6.jpg" alt=""></p>
<h4 id="生效配置"><a href="#生效配置" class="headerlink" title="生效配置"></a>生效配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>此时你就可以看到一个全新的Terminal,快来试试吧。爽不爽自己知道</p>
<h2 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h2><p><a href="https://brew.sh/">HomeBrew官方地址</a></p>
<p>简单来说他是类似于<code>yum、apt</code>,mac的包管理工具，使用它我们可以非常简单、丝滑的下载大部分的包、或者软件</p>
<p>或许第一次可以尝试使用如下命令进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>由于种种原因，如果安装不上，可以使用华科大的源进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>安装完成后，检查一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew doctor</span><br></pre></td></tr></table></figure>
<p>设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git -C &quot;&#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot; remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core</span><br></pre></td></tr></table></figure>
<h3 id="kubectl-自动补全"><a href="#kubectl-自动补全" class="headerlink" title="kubectl 自动补全"></a>kubectl 自动补全</h3><blockquote>
<p>由于我习惯于zsh终端。这里给出zsh的，后面还有bash的</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &lt;(kubectl completion zsh)</span><br></pre></td></tr></table></figure>
<p>如果是<code>bash</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Automatic completion of <span class="built_in">command</span></span></span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>粗谈Redis事物</title>
    <url>/2021/01/23/%E7%B2%97%E8%B0%88Redis%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<h2 id="Redis-事务是什么东东"><a href="#Redis-事务是什么东东" class="headerlink" title="Redis 事务是什么东东"></a>Redis 事务是什么东东</h2><p>一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<blockquote>
<p>简单来说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　</p>
</blockquote>
<a id="more"></a>
<h2 id="Redis事务解析"><a href="#Redis事务解析" class="headerlink" title="Redis事务解析"></a>Redis事务解析</h2><h3 id="Redis事务的三个阶段："><a href="#Redis事务的三个阶段：" class="headerlink" title="Redis事务的三个阶段："></a>Redis事务的三个阶段：</h3><ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<h3 id="Redis事务相关命令："><a href="#Redis事务相关命令：" class="headerlink" title="Redis事务相关命令："></a><strong>Redis事务相关命令：</strong></h3><p>watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</p>
<p>multi : 标记一个事务块的开始（ queued ）</p>
<p>exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</p>
<p>discard : 取消事务，放弃事务块中的所有命令</p>
<p>unwatch : 取消watch对所有key的监控</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>说到Redis事物，那么便不得不谈一下它的锁,</p>
<p>悲观锁：很悲观，认为什么时候都会出现问题，无论做什么都会加锁</p>
<p>乐观锁：很乐观，认为什么时候都不会出现问题，所以不会上锁。更新数据的时候会去判断一下在此期间是否被修改此数据</p>
<ul>
<li>获取version</li>
<li>比较version</li>
<li>更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH money 			<span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI				  		<span class="comment"># 开始执行事物 </span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRby money 50		<span class="comment"># 用掉50  </span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 50		 	<span class="comment"># 减少50</span></span><br><span class="line">QUEUED	</span><br><span class="line">127.0.0.1:6379&gt; EXEC							<span class="comment"># 执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 950</span><br><span class="line">2) (<span class="built_in">integer</span>) 50</span><br></pre></td></tr></table></figure>
<p>执行期间数据money未改变，事物正常执行</p>
<blockquote>
<p>此处的watch 相当于乐观锁</p>
</blockquote>
<h2 id="Redis事务注意点："><a href="#Redis事务注意点：" class="headerlink" title="Redis事务注意点："></a>Redis事务注意点：</h2><p><strong>Redis事务没有隔离级别的概念</strong></p>
<p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到</p>
<p><strong>Redis不保证原子性</strong></p>
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>
<p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>NoSQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang切片-slice</title>
    <url>/2020/11/21/Golang%E5%88%87%E7%89%87-slice/</url>
    <content><![CDATA[<p>在上篇数据类型-Array中写到<strong>因为数组的长度是固定的并且数组长度属于类型的一部分</strong>,所以数组有很多的局限性<br><a id="more"></a></p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [5]<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"> sum := <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">     sum = sum + v</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个求和函数只能接受<code>[5]int</code>类型，其他的都不支持。 再比如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>数组a中已经有五个元素了，我们不能再继续往数组a中添加新元素了。</p>
</blockquote>
<h2 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h2><p>切片的本质就是对底层数组的封装，它包含了三个信息：</p>
<ul>
<li>底层数组的指针</li>
<li>切片的长度（len）</li>
<li>切片的容量（cap)</li>
</ul>
<p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkl8xaagu0j318e0l2abf.jpg" alt=""></p>
<p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkl8xvn3bdj318e0l2q4b.jpg" alt=""></p>
<h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化定义</span></span><br><span class="line"><span class="comment">// 基于var，var定义的时仅会声明，不会申请内存！！！</span></span><br><span class="line"><span class="keyword">var</span> 变量名 []类型</span><br><span class="line"><span class="comment">// make([]T, size, cap) make初始化分配内存</span></span><br><span class="line"><span class="built_in">make</span>([]类型, 切片中元素的数量, 切片的容量)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line">变量名 := []类型&#123;值<span class="number">1</span>，值<span class="number">2</span>。。。&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// var</span></span><br><span class="line">	<span class="keyword">var</span> s1 []<span class="keyword">int</span>             <span class="comment">//var定义的时仅会声明，不会申请内存</span></span><br><span class="line">	fmt.Println(s1)          <span class="comment">// []</span></span><br><span class="line">	fmt.Println(s1 == <span class="literal">nil</span>)   <span class="comment">// true</span></span><br><span class="line">	s1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(s1[<span class="number">0</span>:<span class="number">2</span>])     <span class="comment">// [1 2]</span></span><br><span class="line">	<span class="comment">// make</span></span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">6</span>)   <span class="comment">// make初始化分配内存</span></span><br><span class="line">	fmt.Println(s2)           <span class="comment">// [0 0 0 0]</span></span><br><span class="line">	fmt.Println(s2 == <span class="literal">nil</span>)    <span class="comment">// false</span></span><br><span class="line">	s2 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(s2[<span class="number">0</span>:<span class="number">2</span>])       <span class="comment">// [1 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="var-声明切片"><a href="#var-声明切片" class="headerlink" title="var 声明切片"></a>var 声明切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明切片类型</span></span><br><span class="line">	<span class="keyword">var</span> s1 []<span class="keyword">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line">  <span class="keyword">var</span> s2 = []<span class="keyword">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化(不规范写法，注意！！！)</span></span><br><span class="line">	<span class="keyword">var</span> s3 = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">	<span class="keyword">var</span> s4 = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">	fmt.Println(s1)              <span class="comment">//[]</span></span><br><span class="line">	fmt.Println(s2)              <span class="comment">//[]</span></span><br><span class="line">	fmt.Println(s3)              <span class="comment">//[false true]</span></span><br><span class="line">	fmt.Println(s4)              <span class="comment">//[false true]</span></span><br><span class="line">	fmt.Println(s1 == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">	fmt.Println(s2 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">	fmt.Println(s3 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">	fmt.Println(s4 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">	<span class="comment">// fmt.Println(s3 == s4)       //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Make-初始化切片"><a href="#Make-初始化切片" class="headerlink" title="Make 初始化切片"></a>Make 初始化切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// make 初始化切片</span></span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">6</span>)        </span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">4</span>, <span class="number">6</span>)     </span><br><span class="line">	s3 := <span class="built_in">make</span>([]<span class="keyword">bool</span>,<span class="number">2</span>, <span class="number">4</span>)        </span><br><span class="line">	fmt.Println(s1)                <span class="comment">// [0 0 0 0]</span></span><br><span class="line">	fmt.Println(s2)                <span class="comment">// [       ]</span></span><br><span class="line">	fmt.Println(s3)                <span class="comment">// [false false]</span></span><br><span class="line">	fmt.Println(s1 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line">	fmt.Println(s2 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line">	fmt.Println(s3 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line">	<span class="comment">//fmt.Println(s2 == s3)        // 切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h2><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure>
<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 切片的赋值拷贝</span></span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">	s2 := s1</span><br><span class="line">	s1[<span class="number">0</span>] = <span class="number">80</span></span><br><span class="line">	s2[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(s1)    <span class="comment">// [80 100]</span></span><br><span class="line">	fmt.Println(s2)    <span class="comment">// [80 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组(Array)是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Println(i, s[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(index, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片添加元素"><a href="#切片添加元素" class="headerlink" title="切片添加元素"></a>切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标变量 &#x3D; append(需被加入切片的变量名， 需追加的常量或者切片的变量名)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 添加单个元素</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">  <span class="comment">// 添加多个元素</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">  <span class="comment">// 添加切片</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>通过var声明的零值切片，在<code>append()</code>函数中可直接使用，无需初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以这样做，但没必要</span></span><br><span class="line">	s := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 没有必要初始化</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(s)		<span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">	<span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">int</span>) </span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="切片底层内存原理探究"><a href="#切片底层内存原理探究" class="headerlink" title="切片底层内存原理探究"></a>切片底层内存原理探究</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gklp4pox1sj30t608875i.jpg" alt=""></p>
<p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p><code>$GOROOT/src/runtime/slice.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> runtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;runtime/internal/math&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime/internal/sys&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 自定义类型定义了一个全新的类型。基于内置的基本类型定义，也可以通过struct定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice是一种新类型，同时也包含了struct所具有的特性</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123; <span class="comment">// 自定义类型名为slice，struct类型。</span></span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A notInHeapSlice is a slice backed by go:notinheap memory.</span></span><br><span class="line"><span class="comment">// notInHeapSlice是go：notinheap内存支持的切片</span></span><br><span class="line"><span class="keyword">type</span> notInHeapSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array *notInHeap</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicelen</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: len out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicecap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: cap out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeslicecopy allocates a slice of &quot;tolen&quot; elements of type &quot;et&quot;,</span></span><br><span class="line"><span class="comment">// then copies &quot;fromlen&quot; elements of type &quot;et&quot; into that new allocation from &quot;from&quot;.</span></span><br><span class="line"><span class="comment">// makeslicecopy会分配一片类型为“ et”的“ tolen”元素，然后将类型为“ et”的“ fromlen”元素复制到“ from”的新分配中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslicecopy</span><span class="params">(et *_type, tolen <span class="keyword">int</span>, fromlen <span class="keyword">int</span>, from unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tomem, copymem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(tolen) &gt; <span class="keyword">uintptr</span>(fromlen) &#123;</span><br><span class="line">		<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">		tomem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(tolen))</span><br><span class="line">		<span class="keyword">if</span> overflow || tomem &gt; maxAlloc || tolen &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		copymem = et.size * <span class="keyword">uintptr</span>(fromlen)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// fromlen is a known good length providing and equal or greater than tolen,</span></span><br><span class="line">		<span class="comment">// thereby making tolen a good slice length too as from and to slices have the</span></span><br><span class="line">		<span class="comment">// same element width.</span></span><br><span class="line">    <span class="comment">// fromlen是已知的良好长度，提供并等于或大于tolen，因此也使tolen具有良好的切片长度，因为from和to切片具有//相同的元素宽度。</span></span><br><span class="line">		tomem = et.size * <span class="keyword">uintptr</span>(tolen)</span><br><span class="line">		copymem = tomem</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> to unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		to = mallocgc(tomem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> copymem &lt; tomem &#123;</span><br><span class="line">			memclrNoHeapPointers(add(to, copymem), tomem-copymem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">    <span class="comment">// 注意：不能使用rawmem（这样可以避免内存清零），因为GC可以扫描未初始化的内存。</span></span><br><span class="line">		to = mallocgc(tomem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> copymem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// Only shade the pointers in old.array since we know the destination slice to</span></span><br><span class="line">			<span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">      <span class="comment">//因为我们知道到//的目标切片仅包含nil指针，所以仅在old.array中隐藏了指针，因为在分配过程中已将其清除。</span></span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(to), <span class="keyword">uintptr</span>(from), copymem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(makeslicecopy)</span><br><span class="line">		racereadrangepc(from, copymem, callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(from, copymem)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memmove(to, from, copymem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line">		<span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line">		<span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line">		<span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">		<span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">    <span class="comment">////注意：当有人进行make（[] T，bignumber）时，产生一个&#x27;len out of range&#x27;错误，而不是一个&#x27;cap cap out range&#x27;错误。 “上限超出范围”也是正确的，但是由于上限是隐式提供的，因此说len更清楚。 参见golang.org/issue/4085。</span></span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice64</span><span class="params">(et *_type, len64, cap64 <span class="keyword">int64</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="built_in">len</span> := <span class="keyword">int</span>(len64)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>) != len64 &#123;</span><br><span class="line">		panicmakeslicelen()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cap</span> := <span class="keyword">int</span>(cap64)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">cap</span>) != cap64 &#123;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> makeslice(et, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span></span><br><span class="line"><span class="comment">// and it returns a new slice with at least that capacity, with the old data</span></span><br><span class="line"><span class="comment">// copied into it.</span></span><br><span class="line"><span class="comment">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// NOT to the new requested capacity.</span></span><br><span class="line"><span class="comment">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span></span><br><span class="line"><span class="comment">// to calculate where to write new values during an append.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> When the old backend is gone, reconsider this decision.</span></span><br><span class="line"><span class="comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">		<span class="comment">// We assume that append doesn&#x27;t need to preserve old.array in this case.</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// Specialize for common values of et.size.</span></span><br><span class="line">	<span class="comment">// For 1 we don&#x27;t need any division/multiplication.</span></span><br><span class="line">	<span class="comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span></span><br><span class="line">	<span class="comment">// For powers of 2, use a variable shift.</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line">	<span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">		<span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">			<span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">		&#125;</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		capmem = roundupsize(capmem)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The check of overflow in addition to capmem &gt; maxAlloc is needed</span></span><br><span class="line">	<span class="comment">// to prevent an overflow which can be used to trigger a segfault</span></span><br><span class="line">	<span class="comment">// on 32bit architectures with this example program:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// var d T</span></span><br><span class="line">	<span class="comment">// var s []T</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// func main() &#123;</span></span><br><span class="line">	<span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line">	<span class="comment">//   print(len(s), &quot;\n&quot;)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line">		<span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// Only shade the pointers in old.array since we know the destination slice p</span></span><br><span class="line">			<span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem-et.size+et.ptrdata)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo</span><span class="params">(x <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(x<span class="number">-1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="keyword">int</span>, fmPtr unsafe.Pointer, fmLen <span class="keyword">int</span>, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fmLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := fmLen</span><br><span class="line">	<span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">		n = toLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(slicecopy)</span><br><span class="line">		racereadrangepc(fmPtr, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">		racewriterangepc(toPtr, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(fmPtr, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">		msanwrite(toPtr, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">		*(*<span class="keyword">byte</span>)(toPtr) = *(*<span class="keyword">byte</span>)(fmPtr) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memmove(toPtr, fmPtr, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(toPtr *<span class="keyword">byte</span>, toLen <span class="keyword">int</span>, fm <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(fm)</span><br><span class="line">	<span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">		n = toLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(slicestringcopy)</span><br><span class="line">		racewriterangepc(unsafe.Pointer(toPtr), <span class="keyword">uintptr</span>(n), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(unsafe.Pointer(toPtr), <span class="keyword">uintptr</span>(n))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memmove(unsafe.Pointer(toPtr), stringStructOf(&amp;fm).str, <span class="keyword">uintptr</span>(n))</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内存分配部分，重点部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">	newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">		newcap = doublecap</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">		<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">		<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">			newcap += newcap / <span class="number">4</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">		<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">		<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			newcap = <span class="built_in">cap</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>
</blockquote>
<h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 疑问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">	fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缘由：由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</span></span><br></pre></td></tr></table></figure>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br><span class="line"><span class="comment">// 其中：</span></span><br><span class="line">- srcSlice: 数据来源切片</span><br><span class="line">- destSlice: 目标切片</span><br></pre></td></tr></table></figure>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="built_in">copy</span>(s2, s1)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片s2</span></span><br><span class="line">	fmt.Println(s1) <span class="comment">//[1 2 3]</span></span><br><span class="line">	fmt.Println(s2) <span class="comment">// [1 2 3 0 0]</span></span><br><span class="line">	s2[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(s1) <span class="comment">//[1 2 3]</span></span><br><span class="line">	fmt.Println(s2) <span class="comment">//[10 2 3 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从切片中删除元素</span></span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line">	<span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">	a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">	fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
<h2 id="总结及注意点"><a href="#总结及注意点" class="headerlink" title="总结及注意点"></a>总结及注意点</h2><ul>
<li>底层数组的指针、切片的长度（len）、切片的容量（cap)</li>
<li><code>var</code>与<code>make</code>基于var，var定义的时仅会声明，不会申请内存。make初始化会分配内存。其内容为初始值。(string: 空、int：0、bool：false、Array：var时为nil\make时为”[]”的内部有Len-1个0)</li>
<li>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</li>
<li>Append可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面需要加…）。</li>
<li>当内存小于1024时，每次扩宽两倍。当1024每次增加原本的1/4倍</li>
<li>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis服务与连接那些事儿</title>
    <url>/2021/01/18/Redis%E6%9C%8D%E5%8A%A1%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="启动示例"><a href="#启动示例" class="headerlink" title="启动示例"></a>启动示例</h2><p>当我们需要使用Redis的时候需要把redis的服务开启。如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server</span><br><span class="line"><span class="comment"># 守护进程方式启动</span></span><br><span class="line">redis-server &amp;</span><br><span class="line"><span class="comment"># 使用自定义redis.conf启动</span></span><br><span class="line">redis-server path</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>redis-server</code>如图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmoqnuejzfj31so0mitc6.jpg" alt=""></p>
<p>这样虽然是启动了，但是这个终端却用不了了，我个人并不是很喜欢。那么有没有可以让他既可以运行，而且保证不会占用我们的终端呢</p>
<p>这里有两种方法</p>
<ul>
<li><p>使用<code>redis-server &amp;</code>明显启动示例即可</p>
</li>
<li><p>redis-server ——daemonize yes (以守护进程的方式运行redis)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmpopzvxl4j30s40cq0u4.jpg" alt=""></p>
</li>
</ul>
<blockquote>
<p>小技巧：</p>
<p>redis-server —配置名 配置的值</p>
<p>例如：redis-server —port 8765 此时你就可以在你的8765端口上运行redis</p>
<p>这样就可以无需修改redis.conf,就可以定制化的运行redis</p>
</blockquote>
<h3 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h3><p>既然看过redis的配置文档，不自己亲手试一试怎么能行。话不多说直接开干。以下为给出最基本的的redis.conf，当然如果有需要也按需添加一些。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;database&#x2F;6379</span><br><span class="line">cat &gt; &#x2F;database&#x2F;6379&#x2F;redis.conf&lt;&lt;EOF</span><br><span class="line">daemonize yes</span><br><span class="line">port 6379</span><br><span class="line">logfile &#x2F;database&#x2F;6379&#x2F;redis.log</span><br><span class="line">dir &#x2F;database&#x2F;6379</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>守护进程(后台)运行:daemonize yes<br>配置端口号 port 6379<br>配置日志 logfile /database/6379/redis.log<br>持久化文件存储位置 dir /database/6379<br>RDB持久化数据文件 dbfilename dump.rdb</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmppbthbjgj31c80kktbr.jpg" alt=""></p>
<p>以上就已经完成了redis服务启动的部分，那么我们接下来看看redis的连接部分</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地连接</span></span><br><span class="line">redis-cli	<span class="comment"># 相当于 redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">redis-cli -h host -p port -a passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0bbke7zj30e0044745.jpg" alt=""></p>
<p>如图：出现此“unicode”编码显示问题，改如何解决？</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0dsx7o1j30zw06adft.jpg" alt=""></p>
<p>本地连接直接使用<code>redis-cli</code>，直接在本地连接即可。此过不多赘述</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0glrkj0j31pc07udgu.jpg" alt=""></p>
<blockquote>
<p>DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions:<br>1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent.<br>2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to ‘no’, and then restarting the server.<br>3) If you started the server manually just for testing, restart it with the ‘—protected-mode no’ option.<br>4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.</p>
<p>译文：DENIED Redis正在保护模式下运行，因为已启用保护模式、未指定绑定地址、未向客户端请求身份验证密码。在这种模式下，只接受来自环回接口的连接。如果您想从外部计算机连接到Redis</p>
<p>只需通过从服务器运行的同一主机连接到Redis，从环回接口发送命令’CONFIG SET protected mode no’来禁用保护模式，但是如果这样做，请确保Redis不能从internet公开访问。使用CONFIG REWRITE将此更改永久化</p>
<p>您可以通过编辑Redis配置文件，将protectedmode选项设置为no，然后重新启动服务器来禁用protectedmode。</p>
<p>如果只是为了测试而手动启动服务器，请使用“-protected mode no”选项重新启动服务器</p>
<p>设置绑定地址或身份验证密码。</p>
<p>服务器就可以开始接受来自外部的连接。</p>
</blockquote>
<p>那么从以上得知，redis是默认关闭远程连接以及开启保护模式。开启远程连接的方式有以下几种</p>
<ol>
<li>在本地(打开redis服务)的机器，采用回环地址连接(即是127.0.0.1)，连接redis，后使用<code>CONFIG SET protected mode no</code>就可以允许远程连接(推荐)，使用CONFIG REWRITE将此更改永久化</li>
<li>在配置文件中关闭保护模式<code>protected mode no</code>,重启redis服务(不推荐)</li>
<li>关闭redis服务，使用<code>redis-server -protected mode no</code>，启动服务</li>
<li>配置ip访问或密码(最推荐)</li>
</ol>
<p>综上，我们来配置一下我们的<code>redis.conf</code>，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">port 6379</span><br><span class="line">logfile &#x2F;database&#x2F;6379&#x2F;redis.log</span><br><span class="line">dir &#x2F;database&#x2F;6379</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">requirepass 123321</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>说到性能与测试这两个都是，大家一直关心的问题。那么redis的性能测试该怎么做呢。咋这里我们了解一下<code>redis-brnchmark</code></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq49jlh69j31ao0nmjw9.jpg" alt=""></p>
<p>具体参数如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests&gt;] [-k &lt;boolean&gt;]</span><br><span class="line"></span><br><span class="line"> -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)</span><br><span class="line"> -p &lt;port&gt;          Server port (default 6379)</span><br><span class="line"> -s &lt;socket&gt;        Server socket (overrides host and port)</span><br><span class="line"> -a &lt;password&gt;      Password <span class="keyword">for</span> Redis Auth</span><br><span class="line"> --user &lt;username&gt;  Used to send ACL style <span class="string">&#x27;AUTH username pass&#x27;</span>. Needs -a.</span><br><span class="line"> -c &lt;clients&gt;       Number of parallel connections (default 50)</span><br><span class="line"> -n &lt;requests&gt;      Total number of requests (default 100000)</span><br><span class="line"> -d &lt;size&gt;          Data size of SET/GET value <span class="keyword">in</span> bytes (default 3)</span><br><span class="line"> --dbnum &lt;db&gt;       SELECT the specified db number (default 0)</span><br><span class="line"> --threads &lt;num&gt;    Enable multi-thread mode.</span><br><span class="line"> --cluster          Enable cluster mode.</span><br><span class="line"> --enable-tracking  Send CLIENT TRACKING on before starting benchmark.</span><br><span class="line"> -k &lt;boolean&gt;       1=keep alive 0=reconnect (default 1)</span><br><span class="line"> -r &lt;keyspacelen&gt;   Use random keys <span class="keyword">for</span> SET/GET/INCR, random values <span class="keyword">for</span> SADD,</span><br><span class="line">                    random members and scores <span class="keyword">for</span> ZADD.</span><br><span class="line">  Using this option the benchmark will expand the string __rand_int__</span><br><span class="line">  inside an argument with a 12 digits number <span class="keyword">in</span> the specified range</span><br><span class="line">  from 0 to keyspacelen-1. The substitution changes every time a <span class="built_in">command</span></span><br><span class="line">  is executed. Default tests use this to hit random keys <span class="keyword">in</span> the</span><br><span class="line">  specified range.</span><br><span class="line"> -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).</span><br><span class="line"> -e                 If server replies with errors, show them on stdout.</span><br><span class="line">                    (no more than 1 error per second is displayed)</span><br><span class="line"> -q                 Quiet. Just show query/sec values</span><br><span class="line"> --precision        Number of decimal places to display <span class="keyword">in</span> latency output (default 0)</span><br><span class="line"> --csv              Output <span class="keyword">in</span> CSV format</span><br><span class="line"> -l                 Loop. Run the tests forever</span><br><span class="line"> -t &lt;tests&gt;         Only run the comma separated list of tests. The <span class="built_in">test</span></span><br><span class="line">                    names are the same as the ones produced as output.</span><br><span class="line"> -I                 Idle mode. Just open N idle connections and <span class="built_in">wait</span>.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line"> Run the benchmark with the default configuration against 127.0.0.1:6379:</span><br><span class="line">   $ redis-benchmark</span><br><span class="line"></span><br><span class="line"> Use 20 parallel clients, <span class="keyword">for</span> a total of 100k requests, against 192.168.1.1:</span><br><span class="line">   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20</span><br><span class="line"></span><br><span class="line"> Fill 127.0.0.1:6379 with about 1 million keys only using the SET <span class="built_in">test</span>:</span><br><span class="line">   $ redis-benchmark -t <span class="built_in">set</span> -n 1000000 -r 100000000</span><br><span class="line"></span><br><span class="line"> Benchmark 127.0.0.1:6379 <span class="keyword">for</span> a few commands producing CSV output:</span><br><span class="line">   $ redis-benchmark -t ping,<span class="built_in">set</span>,get -n 100000 --csv</span><br><span class="line"></span><br><span class="line"> Benchmark a specific <span class="built_in">command</span> line:</span><br><span class="line">   $ redis-benchmark -r 10000 -n 10000 <span class="built_in">eval</span> <span class="string">&#x27;return redis.call(&quot;ping&quot;)&#x27;</span> 0</span><br><span class="line"></span><br><span class="line"> Fill a list with 10000 random elements:</span><br><span class="line">   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__</span><br><span class="line"></span><br><span class="line"> On user specified <span class="built_in">command</span> lines __rand_int__ is replaced with a random <span class="built_in">integer</span></span><br><span class="line"> with a range of values selected by the -r option.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在线修改配置"><a href="#在线修改配置" class="headerlink" title="在线修改配置"></a>在线修改配置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG GET	*(配置名，例如daemonize，protected-mode等)				<span class="comment"># 查看配置</span></span><br><span class="line">CONFIG RESETSTAT	<span class="comment"># 命令用于重置 INFO 命令中的某些统计数据</span></span><br><span class="line">CONFIG REWRITE		<span class="comment"># 将修改的设置回写配置文件</span></span><br><span class="line">CONFIG SET			  <span class="comment"># 设置参数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG GET	*</span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">  1) <span class="string">&quot;rdbchecksum&quot;</span>                                                                                                           </span><br><span class="line">  2) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  3) <span class="string">&quot;daemonize&quot;</span>                                                                                                             </span><br><span class="line">  4) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  5) <span class="string">&quot;io-threads-do-reads&quot;</span>                                                                                                   </span><br><span class="line">  6) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line">  7) <span class="string">&quot;lua-replicate-commands&quot;</span>                                                                                                </span><br><span class="line">  8) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  9) <span class="string">&quot;always-show-logo&quot;</span>                                                                                                      </span><br><span class="line"> 10) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 11) <span class="string">&quot;protected-mode&quot;</span>                                                                                                        </span><br><span class="line"> 12) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 13) <span class="string">&quot;rdbcompression&quot;</span>                                                                                                        </span><br><span class="line"> 14) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 15) <span class="string">&quot;rdb-del-sync-files&quot;</span>                                                                                                    </span><br><span class="line"> 16) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 17) <span class="string">&quot;activerehashing&quot;</span>                                                                                                       </span><br><span class="line"> 18) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 19) <span class="string">&quot;stop-writes-on-bgsave-error&quot;</span>                                                                                           </span><br><span class="line"> 20) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 21) <span class="string">&quot;dynamic-hz&quot;</span>                                                                                                            </span><br><span class="line"> 22) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 23) <span class="string">&quot;lazyfree-lazy-eviction&quot;</span>                                                                                                </span><br><span class="line"> 24) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 25) <span class="string">&quot;lazyfree-lazy-expire&quot;</span>                                                                                                  </span><br><span class="line"> 26) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 27) <span class="string">&quot;lazyfree-lazy-server-del&quot;</span>                                                                                              </span><br><span class="line"> 28) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 29) <span class="string">&quot;lazyfree-lazy-user-del&quot;</span>                                                                                                </span><br><span class="line"> 30) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 31) <span class="string">&quot;repl-disable-tcp-nodelay&quot;</span>                                                                                              </span><br><span class="line"> 32) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 33) <span class="string">&quot;repl-diskless-sync&quot;</span>                                                                                                    </span><br><span class="line"> 34) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 35) <span class="string">&quot;gopher-enabled&quot;</span>                                                                                                        </span><br><span class="line"> 36) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 37) <span class="string">&quot;aof-rewrite-incremental-fsync&quot;</span></span><br><span class="line"> 38) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 39) <span class="string">&quot;no-appendfsync-on-rewrite&quot;</span></span><br><span class="line"> 40) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 41) <span class="string">&quot;cluster-require-full-coverage&quot;</span></span><br><span class="line"> 42) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 43) <span class="string">&quot;rdb-save-incremental-fsync&quot;</span></span><br><span class="line"> 44) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 45) <span class="string">&quot;aof-load-truncated&quot;</span></span><br><span class="line"> 46) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 47) <span class="string">&quot;aof-use-rdb-preamble&quot;</span></span><br><span class="line"> 48) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 49) <span class="string">&quot;cluster-replica-no-failover&quot;</span></span><br><span class="line"> 50) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 51) <span class="string">&quot;cluster-slave-no-failover&quot;</span></span><br><span class="line"> 52) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 53) <span class="string">&quot;replica-lazy-flush&quot;</span></span><br><span class="line"> 54) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 55) <span class="string">&quot;slave-lazy-flush&quot;</span></span><br><span class="line"> 56) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 57) <span class="string">&quot;replica-serve-stale-data&quot;</span></span><br><span class="line"> 58) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 59) <span class="string">&quot;slave-serve-stale-data&quot;</span></span><br><span class="line"> 60) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 61) <span class="string">&quot;replica-read-only&quot;</span></span><br><span class="line"> 62) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 63) <span class="string">&quot;slave-read-only&quot;</span></span><br><span class="line"> 64) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 65) <span class="string">&quot;replica-ignore-maxmemory&quot;</span></span><br><span class="line"> 66) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 67) <span class="string">&quot;slave-ignore-maxmemory&quot;</span></span><br><span class="line"> 68) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 69) <span class="string">&quot;jemalloc-bg-thread&quot;</span></span><br><span class="line"> 70) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 71) <span class="string">&quot;activedefrag&quot;</span></span><br><span class="line"> 72) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 73) <span class="string">&quot;syslog-enabled&quot;</span></span><br><span class="line"> 74) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 75) <span class="string">&quot;cluster-enabled&quot;</span></span><br><span class="line"> 76) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 77) <span class="string">&quot;appendonly&quot;</span></span><br><span class="line"> 78) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 79) <span class="string">&quot;cluster-allow-reads-when-down&quot;</span></span><br><span class="line"> 80) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 81) <span class="string">&quot;aclfile&quot;</span></span><br><span class="line"> 82) <span class="string">&quot;&quot;</span></span><br><span class="line"> 83) <span class="string">&quot;unixsocket&quot;</span></span><br><span class="line"> 84) <span class="string">&quot;&quot;</span></span><br><span class="line"> 85) <span class="string">&quot;pidfile&quot;</span></span><br><span class="line"> 86) <span class="string">&quot;/var/run/redis.pid&quot;</span></span><br><span class="line"> 87) <span class="string">&quot;replica-announce-ip&quot;</span></span><br><span class="line"> 88) <span class="string">&quot;&quot;</span></span><br><span class="line"> 89) <span class="string">&quot;slave-announce-ip&quot;</span></span><br><span class="line"> 90) <span class="string">&quot;&quot;</span></span><br><span class="line"> 91) <span class="string">&quot;masteruser&quot;</span></span><br><span class="line"> 92) <span class="string">&quot;&quot;</span></span><br><span class="line"> 93) <span class="string">&quot;masterauth&quot;</span></span><br><span class="line"> 94) <span class="string">&quot;&quot;</span></span><br><span class="line"> 95) <span class="string">&quot;cluster-announce-ip&quot;</span></span><br><span class="line"> 96) <span class="string">&quot;&quot;</span></span><br><span class="line"> 97) <span class="string">&quot;syslog-ident&quot;</span></span><br><span class="line"> 98) <span class="string">&quot;redis&quot;</span></span><br><span class="line"> 99) <span class="string">&quot;dbfilename&quot;</span></span><br><span class="line">100) <span class="string">&quot;dump.rdb&quot;</span></span><br><span class="line">101) <span class="string">&quot;appendfilename&quot;</span></span><br><span class="line">102) <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line">103) <span class="string">&quot;server_cpulist&quot;</span></span><br><span class="line">104) <span class="string">&quot;&quot;</span></span><br><span class="line">105) <span class="string">&quot;bio_cpulist&quot;</span></span><br><span class="line">106) <span class="string">&quot;&quot;</span></span><br><span class="line">107) <span class="string">&quot;aof_rewrite_cpulist&quot;</span></span><br><span class="line">108) <span class="string">&quot;&quot;</span></span><br><span class="line">109) <span class="string">&quot;bgsave_cpulist&quot;</span></span><br><span class="line">110) <span class="string">&quot;&quot;</span></span><br><span class="line">111) <span class="string">&quot;ignore-warnings&quot;</span></span><br><span class="line">112) <span class="string">&quot;ARM64-COW-BUG&quot;</span></span><br><span class="line">113) <span class="string">&quot;supervised&quot;</span></span><br><span class="line">114) <span class="string">&quot;no&quot;</span></span><br><span class="line">115) <span class="string">&quot;syslog-facility&quot;</span></span><br><span class="line">116) <span class="string">&quot;local0&quot;</span></span><br><span class="line">117) <span class="string">&quot;repl-diskless-load&quot;</span></span><br><span class="line">118) <span class="string">&quot;disabled&quot;</span></span><br><span class="line">119) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line">120) <span class="string">&quot;notice&quot;</span></span><br><span class="line">121) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">122) <span class="string">&quot;noeviction&quot;</span></span><br><span class="line">123) <span class="string">&quot;appendfsync&quot;</span></span><br><span class="line">124) <span class="string">&quot;everysec&quot;</span></span><br><span class="line">125) <span class="string">&quot;oom-score-adj&quot;</span></span><br><span class="line">126) <span class="string">&quot;no&quot;</span></span><br><span class="line">127) <span class="string">&quot;databases&quot;</span></span><br><span class="line">128) <span class="string">&quot;16&quot;</span></span><br><span class="line">129) <span class="string">&quot;port&quot;</span></span><br><span class="line">130) <span class="string">&quot;6379&quot;</span></span><br><span class="line">131) <span class="string">&quot;io-threads&quot;</span></span><br><span class="line">132) <span class="string">&quot;1&quot;</span></span><br><span class="line">133) <span class="string">&quot;auto-aof-rewrite-percentage&quot;</span></span><br><span class="line">134) <span class="string">&quot;100&quot;</span></span><br><span class="line">135) <span class="string">&quot;cluster-replica-validity-factor&quot;</span></span><br><span class="line">136) <span class="string">&quot;10&quot;</span></span><br><span class="line">137) <span class="string">&quot;cluster-slave-validity-factor&quot;</span></span><br><span class="line">138) <span class="string">&quot;10&quot;</span></span><br><span class="line">139) <span class="string">&quot;list-max-ziplist-size&quot;</span></span><br><span class="line">140) <span class="string">&quot;-2&quot;</span></span><br><span class="line">141) <span class="string">&quot;tcp-keepalive&quot;</span></span><br><span class="line">142) <span class="string">&quot;300&quot;</span></span><br><span class="line">143) <span class="string">&quot;cluster-migration-barrier&quot;</span></span><br><span class="line">144) <span class="string">&quot;1&quot;</span></span><br><span class="line">145) <span class="string">&quot;active-defrag-cycle-min&quot;</span></span><br><span class="line">146) <span class="string">&quot;1&quot;</span></span><br><span class="line">147) <span class="string">&quot;active-defrag-cycle-max&quot;</span></span><br><span class="line">148) <span class="string">&quot;25&quot;</span></span><br><span class="line">149) <span class="string">&quot;active-defrag-threshold-lower&quot;</span></span><br><span class="line">150) <span class="string">&quot;10&quot;</span></span><br><span class="line">151) <span class="string">&quot;active-defrag-threshold-upper&quot;</span></span><br><span class="line">152) <span class="string">&quot;100&quot;</span></span><br><span class="line">153) <span class="string">&quot;lfu-log-factor&quot;</span></span><br><span class="line">154) <span class="string">&quot;10&quot;</span></span><br><span class="line">155) <span class="string">&quot;lfu-decay-time&quot;</span></span><br><span class="line">156) <span class="string">&quot;1&quot;</span></span><br><span class="line">157) <span class="string">&quot;replica-priority&quot;</span></span><br><span class="line">158) <span class="string">&quot;100&quot;</span></span><br><span class="line">159) <span class="string">&quot;slave-priority&quot;</span></span><br><span class="line">160) <span class="string">&quot;100&quot;</span></span><br><span class="line">161) <span class="string">&quot;repl-diskless-sync-delay&quot;</span></span><br><span class="line">162) <span class="string">&quot;5&quot;</span></span><br><span class="line">163) <span class="string">&quot;maxmemory-samples&quot;</span></span><br><span class="line">164) <span class="string">&quot;5&quot;</span></span><br><span class="line">165) <span class="string">&quot;timeout&quot;</span></span><br><span class="line">166) <span class="string">&quot;0&quot;</span></span><br><span class="line">167) <span class="string">&quot;replica-announce-port&quot;</span></span><br><span class="line">168) <span class="string">&quot;0&quot;</span></span><br><span class="line">169) <span class="string">&quot;slave-announce-port&quot;</span></span><br><span class="line">170) <span class="string">&quot;0&quot;</span></span><br><span class="line">171) <span class="string">&quot;tcp-backlog&quot;</span></span><br><span class="line">172) <span class="string">&quot;511&quot;</span></span><br><span class="line">173) <span class="string">&quot;cluster-announce-bus-port&quot;</span></span><br><span class="line">174) <span class="string">&quot;0&quot;</span></span><br><span class="line">175) <span class="string">&quot;cluster-announce-port&quot;</span></span><br><span class="line">176) <span class="string">&quot;0&quot;</span></span><br><span class="line">177) <span class="string">&quot;repl-timeout&quot;</span></span><br><span class="line">178) <span class="string">&quot;60&quot;</span></span><br><span class="line">179) <span class="string">&quot;repl-ping-replica-period&quot;</span></span><br><span class="line">180) <span class="string">&quot;10&quot;</span></span><br><span class="line">181) <span class="string">&quot;repl-ping-slave-period&quot;</span></span><br><span class="line">182) <span class="string">&quot;10&quot;</span></span><br><span class="line">183) <span class="string">&quot;list-compress-depth&quot;</span></span><br><span class="line">184) <span class="string">&quot;0&quot;</span></span><br><span class="line">185) <span class="string">&quot;rdb-key-save-delay&quot;</span></span><br><span class="line">186) <span class="string">&quot;0&quot;</span></span><br><span class="line">187) <span class="string">&quot;key-load-delay&quot;</span></span><br><span class="line">188) <span class="string">&quot;0&quot;</span></span><br><span class="line">189) <span class="string">&quot;active-expire-effort&quot;</span></span><br><span class="line">190) <span class="string">&quot;1&quot;</span></span><br><span class="line">191) <span class="string">&quot;hz&quot;</span></span><br><span class="line">192) <span class="string">&quot;10&quot;</span></span><br><span class="line">193) <span class="string">&quot;min-replicas-to-write&quot;</span></span><br><span class="line">194) <span class="string">&quot;0&quot;</span></span><br><span class="line">195) <span class="string">&quot;min-slaves-to-write&quot;</span></span><br><span class="line">196) <span class="string">&quot;0&quot;</span></span><br><span class="line">197) <span class="string">&quot;min-replicas-max-lag&quot;</span></span><br><span class="line">198) <span class="string">&quot;10&quot;</span></span><br><span class="line">199) <span class="string">&quot;min-slaves-max-lag&quot;</span></span><br><span class="line">200) <span class="string">&quot;10&quot;</span></span><br><span class="line">201) <span class="string">&quot;maxclients&quot;</span></span><br><span class="line">202) <span class="string">&quot;10000&quot;</span></span><br><span class="line">203) <span class="string">&quot;active-defrag-max-scan-fields&quot;</span></span><br><span class="line">204) <span class="string">&quot;1000&quot;</span></span><br><span class="line">205) <span class="string">&quot;slowlog-max-len&quot;</span></span><br><span class="line">206) <span class="string">&quot;128&quot;</span></span><br><span class="line">207) <span class="string">&quot;acllog-max-len&quot;</span></span><br><span class="line">208) <span class="string">&quot;128&quot;</span></span><br><span class="line">209) <span class="string">&quot;lua-time-limit&quot;</span></span><br><span class="line">210) <span class="string">&quot;5000&quot;</span></span><br><span class="line">211) <span class="string">&quot;cluster-node-timeout&quot;</span></span><br><span class="line">212) <span class="string">&quot;15000&quot;</span></span><br><span class="line">213) <span class="string">&quot;slowlog-log-slower-than&quot;</span></span><br><span class="line">214) <span class="string">&quot;10000&quot;</span></span><br><span class="line">215) <span class="string">&quot;latency-monitor-threshold&quot;</span></span><br><span class="line">216) <span class="string">&quot;0&quot;</span></span><br><span class="line">217) <span class="string">&quot;proto-max-bulk-len&quot;</span></span><br><span class="line">218) <span class="string">&quot;536870912&quot;</span></span><br><span class="line">219) <span class="string">&quot;stream-node-max-entries&quot;</span></span><br><span class="line">220) <span class="string">&quot;100&quot;</span></span><br><span class="line">221) <span class="string">&quot;repl-backlog-size&quot;</span></span><br><span class="line">222) <span class="string">&quot;1048576&quot;</span></span><br><span class="line">223) <span class="string">&quot;maxmemory&quot;</span></span><br><span class="line">224) <span class="string">&quot;0&quot;</span></span><br><span class="line">225) <span class="string">&quot;hash-max-ziplist-entries&quot;</span></span><br><span class="line">226) <span class="string">&quot;512&quot;</span></span><br><span class="line">227) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line">228) <span class="string">&quot;512&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小技巧：</p>
<p>config get 支持模糊匹配，例如包含所有re开头的配置名，<code>config get re*</code>,</p>
<p>所有配置名包含<code>re</code>的配置，可以使用<code>config get *re*</code></p>
</blockquote>
<h3 id="在线修改密码"><a href="#在线修改密码" class="headerlink" title="在线修改密码"></a>在线修改密码</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmqn2c3zruj31e00943zd.jpg" alt=""></p>
<p>原本的密码是<code>123321</code>,这里我们将它修改为<code>123123123</code>,再一次去连接它。发现此时的密码已经修改</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmqn3y1i0ej30wy0agdgx.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>NoSQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv 让你的虚拟环境更加funny一点</title>
    <url>/2020/12/22/pipenv-%E8%AE%A9%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%9B%B4%E5%8A%A0funny%E4%B8%80%E7%82%B9/</url>
    <content><![CDATA[<h2 id="什么是虚拟环境？"><a href="#什么是虚拟环境？" class="headerlink" title="什么是虚拟环境？"></a>什么是虚拟环境？</h2><ul>
<li>由<a href="https://cuiqingcai.com/[https://baike.baidu.com/item/虚拟环境/6529153?fr=aladdin](https://baike.baidu.com/item/虚拟环境/6529153?fr=aladdin">百度百科</a> ) 得知： 以专利的实时动态程序行为修饰与模拟算法，直接利用本机的 OS，模拟出自带与本机相容 OS 的虚拟机（Vista 下可模拟 Vista、XP，Windows 7 下则可模拟 Windows 7、Vista、XP），也称为 “虚拟环境”</li>
<li><p>功能： 每一个环境都相当于一个新的 Python 环境。你可以在这个新的环境里安装库，运行代码等</p>
<a id="more"></a>
<h2 id="为什么需要使用虚拟环境？"><a href="#为什么需要使用虚拟环境？" class="headerlink" title="为什么需要使用虚拟环境？"></a>为什么需要使用虚拟环境？</h2></li>
<li><p>众所周知 Python 的强大在于其兼容性，其强大的社区等。正因为第三方库多，层次不齐造成了许多的第三方库并不兼容</p>
</li>
<li>真实环境与虚拟环境二者相对关联，并非绝对关联，可以在虚拟环境里面随便造。</li>
<li>虚拟环境中进行了隔离，更方便我们部署上线</li>
</ul>
<h2 id="什么时候需要使用虚拟环境？"><a href="#什么时候需要使用虚拟环境？" class="headerlink" title="什么时候需要使用虚拟环境？"></a>什么时候需要使用虚拟环境？</h2><p><strong>例如：</strong></p>
<ul>
<li>项目依赖版本不同时 </li>
<li>所需包与其他包(非此项目所需，但却存在)产生冲突时</li>
<li>等等</li>
</ul>
<h2 id="为什么虚拟环境使用pipenv好一点？"><a href="#为什么虚拟环境使用pipenv好一点？" class="headerlink" title="为什么虚拟环境使用pipenv好一点？"></a>为什么虚拟环境使用<code>pipenv</code>好一点？</h2><p><strong>Pipenv</strong>是一种工具，旨在将所有包装领域（捆扎机，作曲家，npm，货物，纱线等）中的最佳产品引入Python世界。<em>Windows是我们世界上的头等公民。</em></p>
<p>它会自动为您的项目创建和管理virtualenv，并<code>Pipfile</code>在您安装/卸载软件包时从您的软件包中添加/删除软件包。它还会生成非常重要的<code>Pipfile.lock</code>，用于生成确定性构建。</p>
<p>Pipenv的主要目的是为应用程序的用户和开发人员提供一种简单的方法来设置工作环境。有关库和应用程序之间的区别以及使用<code>setup.py</code>vs<code>Pipfile</code>定义依赖<a href="https://docs.pipenv.org/advanced/#pipfile-vs-setuppy">项的区别</a>，请参见<a href="https://docs.pipenv.org/advanced/#pipfile-vs-setuppy">☤Pipfile vs setup.py</a>。</p>
<p>Pipenv试图解决的问题是多方面的：</p>
<ul>
<li>您不再需要使用<code>pip</code>和<code>virtualenv</code>分开。他们一起工作。</li>
<li>管理<code>requirements.txt</code>文件可能会出现问题，因此Pipenv使用<code>Pipfile</code>和<code>Pipfile.lock</code>将抽象依赖声明与上次测试的组合分开。</li>
<li>哈希值随处可见。安全。自动公开安全漏洞。</li>
<li>强烈建议使用最新版本的依赖项，以最大程度地减少由于过时的组件引起的安全风险。</li>
<li>让您深入了解依赖关系图（例如）。<code>$ pipenv graph</code></li>
<li>通过加载<code>.env</code>文件来简化开发工作流程。</li>
</ul>
<h2 id="pipenv安装"><a href="#pipenv安装" class="headerlink" title="pipenv安装"></a>pipenv安装</h2><p>建议使用<code>pip3</code>, mac还是服务器上的Linux一般都会有<code>python2.x</code>版本。在这种场景大多情况下，<code>pip</code>指向<code>python2.x</code>,并非<code>python3.x</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br><span class="line"><span class="comment"># 推荐使用pip来安装</span></span><br><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure>
<p>其他几种安装方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you’re on MacOS, you can install Pipenv easily with Homebrew:</span></span><br><span class="line">brew install pipenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or, if you’re using Fedora 28:</span></span><br><span class="line">sudo dnf install pipenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># if you&#x27;re using centos</span></span><br><span class="line">sudo yum install -y pipenv</span><br></pre></td></tr></table></figure>
<p>反正安装都一样,无论是使用其他的包管理工具还是pip，都可以</p>
<h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3 环境创建</span></span><br><span class="line">pipenv --python 3.x</span><br><span class="line">pipenv --three</span><br><span class="line">pipenv install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建完成后，虚拟环境的pip。并不是你真实环境的pip版本，如果有需要，需要升级一下pip 的版本</span></span><br><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，首先必须得安装了相对应的Python 版本才能创建虚拟环境。可能点萌萌哒。举个栗子，例如我的电脑环境中只有python3.7，而我想创建一个python2.7 这样是不能创建的</p>
<p>Pip3安装的pipenv 只能python3 只能使用</p>
</blockquote>
<h2 id="安装删除第三方库"><a href="#安装删除第三方库" class="headerlink" title="安装删除第三方库"></a>安装删除第三方库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv install packageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多个包，中间以空格分隔即可</span></span><br><span class="line">pipenv install packageName-1 packageName-2 packageNama-3</span><br><span class="line"></span><br><span class="line">pipenv uninstall packageName</span><br></pre></td></tr></table></figure>
<h2 id="Terminal激活虚拟环境"><a href="#Terminal激活虚拟环境" class="headerlink" title="Terminal激活虚拟环境"></a>Terminal激活虚拟环境</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此时终端会在最前面显示<code>(xxx)</code>, xxx一般为项目文件名。证明退出成功</li>
<li>并不需要关心虚拟环境的具体位置，只需要在当前目录下。有<code>Pipfile</code>即可</li>
</ul>
</blockquote>
<h2 id="Terminal中退出虚拟环境"><a href="#Terminal中退出虚拟环境" class="headerlink" title="Terminal中退出虚拟环境"></a>Terminal中退出虚拟环境</h2><p>在其他包的虚拟环境中退出可能是使用<code>deactivate</code>,在conda 中使用<code>conda deactivate</code>,而在pipenv 中直接使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 即可退出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用deactivate，然后在使用<code>pipenv shell</code>,造成本终端页面进入虚拟环境失败。请参考勘误2</p>
</blockquote>
<h2 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h2><p>在此项目目录下只需一下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv --rm </span><br></pre></td></tr></table></figure>
<h2 id="镜像源安装第三方包"><a href="#镜像源安装第三方包" class="headerlink" title="镜像源安装第三方包"></a>镜像源安装第三方包</h2><p>我相信你也和我一样遇见过或尽力过下载第三方包失效包很慢，或者干脆出现<code>timeout</code>导致第三方包下载失败的情况，那么接下来让我们来使用国内的镜像源进行安装第三方包。速度嗖嗖嗖～</p>
<h3 id="单一的安装"><a href="#单一的安装" class="headerlink" title="单一的安装"></a>单一的安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以requests 为栗子</span></span><br><span class="line"> pipenv install requests  --pypi-mirror https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>使用pipenv创建虚拟环境之后会在项目目录下生成<code>Pipfile</code>,的文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pipfile</span></span><br><span class="line">[[<span class="built_in">source</span>]]</span><br><span class="line">url = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;</span></span><br><span class="line">verify_ssl = <span class="literal">true</span></span><br><span class="line">name = <span class="string">&quot;pypi&quot;</span></span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">requests = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version = <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取包依赖"><a href="#获取包依赖" class="headerlink" title="获取包依赖"></a>获取包依赖</h3><p>我们可以使用命令来清晰地呈现出当前安装的 Python 包版本及之间的依赖关系，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure>
<blockquote>
<p>~ ProjectNote % pipenv graph<br>lxml==4.6.2<br>requests==2.25.1</p>
<ul>
<li>certifi [required: &gt;=2017.4.17, installed: 2020.12.5]</li>
<li>chardet [required: &gt;=3.0.2,&lt;5, installed: 4.0.0]</li>
<li>idna [required: &gt;=2.5,&lt;3, installed: 2.10]</li>
<li>urllib3 [required: &gt;=1.21.1,&lt;1.27, installed: 1.26.2]</li>
</ul>
</blockquote>
<h3 id="产生-Pipfile-lock"><a href="#产生-Pipfile-lock" class="headerlink" title="产生 Pipfile.lock"></a>产生 Pipfile.lock</h3><p>有时候可能 Pipfile.lock 文件不存在或被删除了，这时候我们可以使用如下命令生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure>
<p>以上就是pipenv基础使用了，但这还不够哦。接下来让我们深入探究一下</p>
<h2 id="不知道但常用"><a href="#不知道但常用" class="headerlink" title="不知道但常用"></a>不知道但常用</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: pipenv [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --<span class="built_in">where</span>                         Output project home information.</span><br><span class="line">  --venv                          Output virtualenv information.</span><br><span class="line">  --py                            Output Python interpreter information.</span><br><span class="line">  --envs                          Output Environment Variable options.</span><br><span class="line">  --rm                            Remove the virtualenv.</span><br><span class="line">  --bare                          Minimal output.</span><br><span class="line">  --completion                    Output completion (to be executed by the</span><br><span class="line">                                  shell).</span><br><span class="line"></span><br><span class="line">  --man                           Display manpage.</span><br><span class="line">  --support                       Output diagnostic information <span class="keyword">for</span> use <span class="keyword">in</span></span><br><span class="line">                                  GitHub issues.</span><br><span class="line"></span><br><span class="line">  --site-packages / --no-site-packages</span><br><span class="line">                                  Enable site-packages <span class="keyword">for</span> the virtualenv.</span><br><span class="line">                                  [env var: PIPENV_SITE_PACKAGES]</span><br><span class="line"></span><br><span class="line">  --python TEXT                   Specify <span class="built_in">which</span> version of Python virtualenv</span><br><span class="line">                                  should use.</span><br><span class="line"></span><br><span class="line">  --three / --two                 Use Python 3/2 when creating virtualenv.</span><br><span class="line">  --clear                         Clears caches (pipenv, pip, and pip-tools).</span><br><span class="line">                                  [env var: PIPENV_CLEAR]</span><br><span class="line"></span><br><span class="line">  -v, --verbose                   Verbose mode.</span><br><span class="line">  --pypi-mirror TEXT              Specify a PyPI mirror.</span><br><span class="line">  --version                       Show the version and <span class="built_in">exit</span>.</span><br><span class="line">  -h, --<span class="built_in">help</span>                      Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage Examples:</span><br><span class="line">   Create a new project using Python 3.7, specifically:</span><br><span class="line">   $ pipenv --python 3.7</span><br><span class="line"></span><br><span class="line">   Remove project virtualenv (inferred from current directory):</span><br><span class="line">   $ pipenv --rm</span><br><span class="line"></span><br><span class="line">   Install all dependencies <span class="keyword">for</span> a project (including dev):</span><br><span class="line">   $ pipenv install --dev</span><br><span class="line"></span><br><span class="line">   Create a lockfile containing pre-releases:</span><br><span class="line">   $ pipenv lock --pre</span><br><span class="line"></span><br><span class="line">   Show a graph of your installed dependencies:</span><br><span class="line">   $ pipenv graph</span><br><span class="line"></span><br><span class="line">   Check your installed dependencies <span class="keyword">for</span> security vulnerabilities:</span><br><span class="line">   $ pipenv check</span><br><span class="line"></span><br><span class="line">   Install a <span class="built_in">local</span> setup.py into your virtual environment/Pipfile:</span><br><span class="line">   $ pipenv install -e .</span><br><span class="line"></span><br><span class="line">   Use a lower-level pip <span class="built_in">command</span>:</span><br><span class="line">   $ pipenv run pip freeze</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  check      Checks <span class="keyword">for</span> PyUp Safety security vulnerabilities and against PEP</span><br><span class="line">             508 markers provided <span class="keyword">in</span> Pipfile.</span><br><span class="line"></span><br><span class="line">  clean      Uninstalls all packages not specified <span class="keyword">in</span> Pipfile.lock.</span><br><span class="line">  graph      Displays currently-installed dependency graph information.</span><br><span class="line">  install    Installs provided packages and adds them to Pipfile, or (<span class="keyword">if</span> no</span><br><span class="line">             packages are given), installs all packages from Pipfile.</span><br><span class="line"></span><br><span class="line">  lock       Generates Pipfile.lock.</span><br><span class="line">  open       View a given module <span class="keyword">in</span> your editor.</span><br><span class="line">  run        Spawns a <span class="built_in">command</span> installed into the virtualenv.</span><br><span class="line">  scripts    Lists scripts <span class="keyword">in</span> current environment config.</span><br><span class="line">  shell      Spawns a shell within the virtualenv.</span><br><span class="line">  sync       Installs all packages specified <span class="keyword">in</span> Pipfile.lock.</span><br><span class="line">  uninstall  Uninstalls a provided package and removes it from Pipfile.</span><br><span class="line">  update     Runs lock, <span class="keyword">then</span> sync.</span><br></pre></td></tr></table></figure>
<h3 id="在真实环境中使用虚拟环境中包并运行"><a href="#在真实环境中使用虚拟环境中包并运行" class="headerlink" title="在真实环境中使用虚拟环境中包并运行"></a>在真实环境中使用虚拟环境中包并运行</h3><blockquote>
<p>场景如下：</p>
<p>假设正式环境中为一个干净的仓库,有且仅有初始的包</p>
<p>虚拟环境中有所需要的第三方包。</p>
<p>如何实现在真实环境中使用虚拟环境中的第三方包并运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv run python xxx.py</span><br></pre></td></tr></table></figure>
<h3 id="产生-Pipfile-lock-1"><a href="#产生-Pipfile-lock-1" class="headerlink" title="产生 Pipfile.lock"></a>产生 Pipfile.lock</h3><p>有时候可能 Pipfile.lock 文件不存在或被删除了，这时候我们可以使用以下命令生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure>
<h2 id="批量安装第三方依赖包"><a href="#批量安装第三方依赖包" class="headerlink" title="批量安装第三方依赖包"></a>批量安装第三方依赖包</h2><p>部署的时候只需要将此执行一下命令即可安装所有的依赖包，它是依靠Pipfile.lock的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv sync</span><br></pre></td></tr></table></figure>
<h3 id="示例-使用pipenv-对接docker或其他的部署"><a href="#示例-使用pipenv-对接docker或其他的部署" class="headerlink" title="示例:使用pipenv 对接docker或其他的部署"></a>示例:使用pipenv 对接docker或其他的部署</h3><p>只说不做假把式，只做不说傻把式。搞了这么多，来个case实现与项目接轨吧。这里为以docker部署为栗子</p>
<p>首先在项目中我们也使用虚拟环境去开发,当然也建议这样去做。没错，我是在教你做事。嘻嘻～</p>
<p>此时的项目应该差不多如下,此时两个为必须存在一个是<code>Pipfile</code>, 一个是项目文件(文件夹)。<code>deploy</code>，<code>Dockerfile</code>为后实现</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glvroonkofj30ly07i0so.jpg" alt=""></p>
<p>书写Dockerfile，拿docker部署没有Dockerfile是不阔能滴</p>
<p>Dockerfile实现如下,可以按需修改</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sh deploy.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;pipenv&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;python3&quot;</span>, <span class="string">&quot;testfile.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>Deploy.sh如下</p>
<p>其实deploy 其中的内容可以直接放到dockerfile中，我自己喜欢这样。更加清晰一点。啊，如此清晰的逻辑与结构，无敌～。我又在教你做事，大哥别杀我</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保持pip版本为最新版，及安装pipenv</span></span><br><span class="line">python3 -m pip install --upgrade pip  &amp;&amp; pip3 install pipenv</span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">pipenv --python 3.8</span><br><span class="line"><span class="comment"># 安装环境依赖(第三方包)</span></span><br><span class="line">pipenv update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是，我建议你使用<code>pipenv update</code>,更加保险。</p>
<p>什么， 你问我为什么不用sync？</p>
<p>既然你诚心诚意的发问了，那我就大发慈悲的告诉你吧。哈哈～</p>
<p><code>pipenv update</code>相当于执行了<code>pipenv lock</code>和<code>pipenv sync</code>两个命令</p>
<p>如果用<code>pipenv sync</code>，而此时的你如果没有<code>Pipfile.lock</code>,那岂不是很尬</p>
</blockquote>
<p>Docker build 执行结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  99.33kB</span><br><span class="line">Step 1/5 : FROM python:3.8</span><br><span class="line"> ---&gt; d1bfb3dd9268</span><br><span class="line">Step 2/5 : WORKDIR /code</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 74cda17b1483</span><br><span class="line">Removing intermediate container 74cda17b1483</span><br><span class="line"> ---&gt; ecfd46d28538</span><br><span class="line">Step 3/5 : COPY . /code</span><br><span class="line"> ---&gt; 8a89f329a4f9</span><br><span class="line">Step 4/5 : RUN pip install pipenv &amp;&amp; sh deploy.sh</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> cea95051d481</span><br><span class="line">Collecting pipenv</span><br><span class="line">  Downloading pipenv-2020.11.15-py2.py3-none-any.whl (3.9 MB)</span><br><span class="line">Requirement already satisfied: setuptools&gt;=36.2.1 <span class="keyword">in</span> /usr/<span class="built_in">local</span>/lib/python3.8/site-packages (from pipenv) (51.0.0)</span><br><span class="line">Requirement already satisfied: pip&gt;=18.0 <span class="keyword">in</span> /usr/<span class="built_in">local</span>/lib/python3.8/site-packages (from pipenv) (20.3.3)</span><br><span class="line">Collecting virtualenv-clone&gt;=0.2.5</span><br><span class="line">  Downloading virtualenv_clone-0.5.4-py2.py3-none-any.whl (6.6 kB)</span><br><span class="line">Collecting certifi</span><br><span class="line">  Downloading certifi-2020.12.5-py2.py3-none-any.whl (147 kB)</span><br><span class="line">Collecting virtualenv</span><br><span class="line">  Downloading virtualenv-20.2.2-py2.py3-none-any.whl (5.7 MB)</span><br><span class="line">Collecting appdirs&lt;2,&gt;=1.4.3</span><br><span class="line">  Downloading appdirs-1.4.4-py2.py3-none-any.whl (9.6 kB)</span><br><span class="line">Collecting distlib&lt;1,&gt;=0.3.1</span><br><span class="line">  Downloading distlib-0.3.1-py2.py3-none-any.whl (335 kB)</span><br><span class="line">Collecting filelock&lt;4,&gt;=3.0.0</span><br><span class="line">  Downloading filelock-3.0.12-py3-none-any.whl (7.6 kB)</span><br><span class="line">Collecting six&lt;2,&gt;=1.9.0</span><br><span class="line">  Downloading six-1.15.0-py2.py3-none-any.whl (10 kB)</span><br><span class="line">Installing collected packages: six, filelock, distlib, appdirs, virtualenv-clone, virtualenv, certifi, pipenv</span><br><span class="line">Successfully installed appdirs-1.4.4 certifi-2020.12.5 distlib-0.3.1 filelock-3.0.12 pipenv-2020.11.15 six-1.15.0 virtualenv-20.2.2 virtualenv-clone-0.5.4</span><br><span class="line">Creating a virtualenv <span class="keyword">for</span> this project...</span><br><span class="line">Pipfile: /code/Pipfile</span><br><span class="line">Using /usr/<span class="built_in">local</span>/bin/python3.8 (3.8.6) to create virtualenv...</span><br><span class="line">⠦ Creating virtual environment...created virtual environment CPython3.8.6.final.0-64 <span class="keyword">in</span> 1079ms</span><br><span class="line">  creator CPython3Posix(dest=/root/.<span class="built_in">local</span>/share/virtualenvs/code-_Py8Si6I, clear=False, no_vcs_ignore=False, global=False)</span><br><span class="line">  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/root/.<span class="built_in">local</span>/share/virtualenv)</span><br><span class="line">    added seed packages: pip==20.3.1, setuptools==51.0.0, wheel==0.36.1</span><br><span class="line">  activators BashActivator,CShellActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator</span><br><span class="line">                                                                                                                                                                           ✔ Successfully created virtual environment! </span><br><span class="line">Virtualenv location: /root/.<span class="built_in">local</span>/share/virtualenvs/code-_Py8Si6I</span><br><span class="line">Installing dependencies from Pipfile.lock (d2a522)...</span><br><span class="line">To activate this project<span class="string">&#x27;s virtualenv, run pipenv shell.</span></span><br><span class="line"><span class="string">Alternatively, run a command inside the virtualenv with pipenv run.</span></span><br><span class="line"><span class="string">All dependencies are now up-to-date!</span></span><br><span class="line"><span class="string">Removing intermediate container cea95051d481</span></span><br><span class="line"><span class="string"> ---&gt; 5bc79a1c17b6</span></span><br><span class="line"><span class="string">Step 5/5 : CMD [&quot;pipenv&quot;, &quot;run&quot;, &quot;python3&quot;, &quot;testfile.py&quot;]</span></span><br><span class="line"><span class="string"> ---&gt; Running in d86af926715c</span></span><br><span class="line"><span class="string">Removing intermediate container d86af926715c</span></span><br><span class="line"><span class="string"> ---&gt; a64b6bc63353</span></span><br><span class="line"><span class="string">Successfully built a64b6bc63353</span></span><br><span class="line"><span class="string">Successfully tagged test:1</span></span><br><span class="line"><span class="string">(ProjectNote) stringle-004@zhixiankeji-004s-MacBook-Pro ProjectNote % docker run  test:1</span></span><br><span class="line"><span class="string">&lt;Response [200]&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus=autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 clabg s_btn&quot; autofocus&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=https://www.hao123.com name=tj_trhao1 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.bacom name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tlogin class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;</span>&lt;a href=<span class="string">&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (windowocation.search === &quot;</span><span class="string">&quot; ? &quot;</span>?<span class="string">&quot; : &quot;</span>&amp;<span class="string">&quot;)+ &quot;</span>bdorz_come=1<span class="string">&quot;)+ &#x27;&quot;</span> name=<span class="string">&quot;tj_login&quot;</span> class=<span class="string">&quot;lb&quot;</span>&gt;登录&lt;/a&gt;<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">                &lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;tml&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Element html at 0x7fbfe776d100&gt;</span></span><br></pre></td></tr></table></figure>
<p>Docker 构建注意事项：</p>
<ol>
<li><p>```sh</p>
<h1 id="Pipfile文件"><a href="#Pipfile文件" class="headerlink" title="Pipfile文件"></a>Pipfile文件</h1><p>[requires]<br>python_version = “3.8”</p>
<h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>FROM python:3.8</p>
<p>这两个后面跟的版本号必须一致，否则将会构建失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用&#96;pipenv update &#96;而不是&#96;pipenv sync&#96;,为什么，我就不告诉你了。看上面就好</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 勘误</span><br><span class="line"></span><br><span class="line">### 1.pip版本过低造成安装失败</span><br><span class="line"></span><br><span class="line">还记得我之前在服务器上，无论怎么安装就是安装不上，无论是其他包还是&#96;pipenv&#96;.后来硬是找不到什么原因。直到。。。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sh</span><br><span class="line"># 查看pip 版本</span><br><span class="line">pip3 -V</span><br><span class="line"># or</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>输出结果类似如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~ % pip3 -V</span><br><span class="line">pip 20.3.3 from /usr/<span class="built_in">local</span>/lib/python3.9/site-packages/pip (python 3.9)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果pip 的版本还不是20版本的，需要进行升级</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">python3 -m pip install --upgrade pip [--user]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">python3 -m pip install -U pip [--user]</span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip3 install -U pip</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>其中[—user] 为可选参数，最好加上。一般情况下不加也没事</p>
</li>
<li><p><code>-m</code>:run library module as a script (terminates option list) 将库模块作为脚本运行（终止选项列表）</p>
</li>
</ul>
</blockquote>
<h3 id="2-虚拟环境重载错误"><a href="#2-虚拟环境重载错误" class="headerlink" title="2.虚拟环境重载错误"></a>2.虚拟环境重载错误</h3><p>之前使用其他的python虚拟环境工具的时候，使用<code>deactivate</code>,退出虚拟环境。而<code>pipenv</code>, 并不是这样</p>
<p>使用<code>deactivate</code>,退出虚拟环境后又使用`pipenv shell, 进入虚拟环境，结果显示…</p>
<blockquote>
<p>Shell for UNKNOWN_VIRTUAL_ENVIRONMENT already activated.<br>No action taken to avoid nested environments.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先exit 一下即可，然后使用</span></span><br><span class="line">pipenv shell</span><br><span class="line"><span class="comment"># 即可重新进入虚拟环境</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建虚拟环境需注意<br>pipenv 并不支持嵌套的虚拟环境，默认使用此文件的父级目录中的pipfile</p>
<blockquote>
<p>比如：在projectfile中有文件src-1，pipfile, src-2,如果进入src-1 中执行<code>pipenv install</code>or<code>pipenv --python 3.8</code>or <code>pipenv  tree</code>,中任何一个命令都会优先使用projectfile/pipfile</p>
</blockquote>
</li>
</ol>
<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p><a href="https://docs.pipenv.org/">pipenv官方文档</a></p>
<p><a href="https://pypi.org/project/pipenv/">pipenv pypi</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>sql,何必在忆-基础篇</title>
    <url>/2021/01/11/sql-%E4%BD%95%E5%BF%85%E5%9C%A8%E5%BF%86-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>还记得那是在2018年的十月的某个日子，虽早已入秋，但夏日的炎热却丝毫不减退散。那时的我正捧着一本<code>SQL Server程序设计</code>的白蓝皮书与九栋315的狗子们，匆匆的走向<code>j1-402</code>进行了我们人生中第一次<code>SQL数据库的学习</code>，时光总是戏人，现实总是玩笑。当初的几个伙伴都走向了各行各业，而唯有我编程课，问啥啥不会，写啥啥就废的我进入了IT行业。说来实在嘲讽，缅怀那些我错过的编程课，致那些年说过无数次“让我学<code>SQL</code>,根本不可能”，我承认我打脸了。正如此章的title一般，“SQL语句， 何必在忆？”</p>
<p>很久之前就学了SQL，然而又忘记，今天正式系统的性的回顾一下，温故而知新。可以为师矣<br><a id="more"></a></p>
<h2 id="表属性"><a href="#表属性" class="headerlink" title="表属性"></a>表属性</h2><h3 id="表的属性"><a href="#表的属性" class="headerlink" title="表的属性"></a>表的属性</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">存储引擎:</span><br><span class="line">InnoDB（默认的）</span><br><span class="line">字符集和排序规则:</span><br><span class="line">utf8</span><br><span class="line">utf8mb4</span><br></pre></td></tr></table></figure>
<h3 id="列的属性"><a href="#列的属性" class="headerlink" title="列的属性"></a>列的属性</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">约束(一般建表时添加):</span><br><span class="line">primary key ：主键约束</span><br><span class="line">设置为主键的列，此列的值必须非空且唯一，主键在一个表中只能有一个，但是可以有多个列一起构成。 作为聚簇索引</span><br><span class="line">not null      ：非空约束</span><br><span class="line">列值不能为空，也是表设计的规范，尽可能将所有的列设置为非空。可以设置默认值为0</span><br><span class="line">unique key ：唯一键</span><br><span class="line">列值不能重复</span><br><span class="line">unsigned ：无符号</span><br><span class="line">针对数字列，非负数。</span><br><span class="line"></span><br><span class="line">其他属性:</span><br><span class="line">key :索引</span><br><span class="line">可以在某列上建立索引，来优化查询,一般是根据需要后添加</span><br><span class="line">default           :默认值</span><br><span class="line">列中，没有录入值时，会自动使用default的值填充</span><br><span class="line">auto_increment:自增长</span><br><span class="line">针对数字列，顺序的自动填充数据（默认是从1开始，将来可以设定起始点和偏移量）</span><br><span class="line">comment : 注释</span><br></pre></td></tr></table></figure>
<h3 id="sql-mode"><a href="#sql-mode" class="headerlink" title="sql_mode"></a>sql_mode</h3><p>作用：影响sql执行行为，规范SQL语句的书写方式(例如除数不能为0)</p>
<p>可以使用select @sql_mode查看(各版本有所出入)</p>
<h3 id="字符集-charset-及校对规则-Collation"><a href="#字符集-charset-及校对规则-Collation" class="headerlink" title="字符集(charset)及校对规则(Collation)"></a>字符集(charset)及校对规则(Collation)</h3><h4 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h4><ul>
<li>utf8：最大存储长度，单个字符最多3字节</li>
<li>utf8mb4：最大存储长度，单个字符最多4字节</li>
</ul>
<p>常用于建库建表时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database dbname charset utf8mb4;</span><br><span class="line"># 查看数据库的字符集合</span><br><span class="line">show create database dbname;</span><br></pre></td></tr></table></figure>
<h4 id="校对规则"><a href="#校对规则" class="headerlink" title="校对规则"></a>校对规则</h4><p>每种字符集，有多种校对规则(排序)，例如常见的ASCII编码表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show collation;</span><br></pre></td></tr></table></figure>
<p>作用：影响排序的操作</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="text类型"><a href="#text类型" class="headerlink" title="text类型"></a>text类型</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd63x1tzoj311o0u0go0.jpg" alt=""></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd64lw40rj313c0kegn5.jpg" alt=""></p>
<p><code>*</code>:这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。</p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd66b11g5j313o0piabh.jpg" alt=""></p>
<p><code>*</code>即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</p>
<h2 id="什么是SQL语句"><a href="#什么是SQL语句" class="headerlink" title="什么是SQL语句"></a>什么是SQL语句</h2><p>SQL语句是结构化查询语言(Structured Query Language)的简称,是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>
<h2 id="SQL语句的类型"><a href="#SQL语句的类型" class="headerlink" title="SQL语句的类型"></a>SQL语句的类型</h2><p>数据查询语言（<a href="https://baike.baidu.com/item/DQL">DQL</a>:Data Query Language）：其语句，也称为“数据检索<a href="https://baike.baidu.com/item/语句">语句</a>”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字<a href="https://baike.baidu.com/item/SELECT/10735068">SELECT</a>是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其它类型的SQL语句一起使用。</p>
<p><a href="https://baike.baidu.com/item/数据操作语言">数据操作语言</a>（DML：Data Manipulation Language）：其语句包括动词<a href="https://baike.baidu.com/item/INSERT">INSERT</a>、<a href="https://baike.baidu.com/item/UPDATE">UPDATE</a>和<a href="https://baike.baidu.com/item/DELETE">DELETE</a>。它们分别用于添加、修改和删除。</p>
<p>事务控制语言（TCL）：它的语句能确保被DML语句影响的表的所有行及时得以更新。包括COMMIT（提交）命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。</p>
<p><a href="https://baike.baidu.com/item/数据控制语言">数据控制语言</a>（DCL）：它的语句通过GRANT或REVOKE实现权限控制，确定单个用户和用户组对<a href="https://baike.baidu.com/item/数据库对象">数据库对象</a>的访问。某些RDBMS可用GRANT或REVOKE控制对<a href="https://baike.baidu.com/item/表单">表单</a>个列的访问。</p>
<p>数据定义语言（<a href="https://baike.baidu.com/item/DDL/21997">DDL</a>）：其语句包括动词CREATE,ALTER和DROP。在数据库中创建新表或修改、删除表（CREATE TABLE 或 DROP TABLE）；为表加入索引等。</p>
<p>指针控制语言（CCL）：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p>
<p>比较常用的有<code>DDL(数据定义语言)</code>`DCL(数据控制语言)<code>\</code>DML(数据操作语言)<code>\</code>DQL(数据查询语言)`</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?         (\?) Synonym for &#96;help&#39;.           # 帮助信息                                                                                </span><br><span class="line">clear     (\c) Clear the current input statement.  清空此行sql                                                                         </span><br><span class="line">connect   (\r) Reconnect to the server. Optional arguments are db and host.                                                  </span><br><span class="line">delimiter (\d) Set statement delimiter.                                                                                      </span><br><span class="line">edit      (\e) Edit command with $EDITOR.                                                                                    </span><br><span class="line">ego       (\G) Send command to mysql server, display result vertically. 格式化输出</span><br><span class="line">exit      (\q) Exit mysql. Same as quit.	退出登陆 ctrl(control) + d </span><br><span class="line">go        (\g) Send command to mysql server.</span><br><span class="line">help      (\h) Display this help.</span><br><span class="line">nopager   (\n) Disable pager, print to stdout.</span><br><span class="line">tee       (\T) Set outfile [to_outfile]. Append everything into given outfile. # 记录日志（语句+结果） eg:tee &#x2F;tmp&#x2F;mysql.log</span><br><span class="line">notee     (\t) Don&#39;t write into outfile. 不记录日志</span><br><span class="line">pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.</span><br><span class="line">print     (\p) Print current command.</span><br><span class="line">prompt    (\R) Change your mysql prompt.</span><br><span class="line">quit      (\q) Quit mysql.</span><br><span class="line">rehash    (\#) Rebuild completion hash.</span><br><span class="line">source    (\.) Execute an SQL script file. Takes a file name as an argument. 导入脚步，相当于 &lt;</span><br><span class="line">status    (\s) Get status information from the server.</span><br><span class="line">system    (\!) Execute a system shell command.</span><br><span class="line">use       (\u) Use another database. Takes database name as argument.</span><br><span class="line">charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.</span><br><span class="line">warnings  (\W) Show warnings after every statement.</span><br><span class="line">nowarning (\w) Don&#39;t show warnings after every statement.</span><br><span class="line">resetconnection(\x) Clean session context.</span><br></pre></td></tr></table></figure>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h4 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h4><p>在日常中DDL多用于库、表的管理.</p>
<p><strong>库名与库属性</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 增</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname</span><br><span class="line">eg: <span class="keyword">create</span> <span class="keyword">database</span> dbname <span class="keyword">charset</span> utf8mb4</span><br><span class="line"><span class="comment">## 删</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> dbname</span><br><span class="line"><span class="comment">## 改 (从小到大改， utf8 -&gt; utf8mb4, 严格超集)</span></span><br><span class="line"><span class="keyword">alter</span>  <span class="keyword">database</span> dbname 将修改的属性名 将要修改的属性值</span><br><span class="line"><span class="comment">## 查</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建库规范：<br>1.库名不能有大写字母,不能太长(&lt;30字符) 多平台兼容性问题<br>2.建库要加字符集<br>3.库名不能有数字开头<br>4.库名要和业务相关</p>
</blockquote>
<p><strong>表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tableName(</span><br><span class="line">列<span class="number">1</span>  属性（数据类型、约束、其他属性） ，</span><br><span class="line">列<span class="number">2</span>  属性，</span><br><span class="line">列<span class="number">3</span>  属性</span><br><span class="line">)</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line"><span class="keyword">id</span>      <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">sname   <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">sage    <span class="built_in">TINYINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">sgender ENUM(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;n&#x27;</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;n&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;性别&#x27;</span> ,</span><br><span class="line">sfz     <span class="built_in">CHAR</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>  <span class="keyword">COMMENT</span> <span class="string">&#x27;身份证&#x27;</span>,</span><br><span class="line">intime  <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>() <span class="keyword">COMMENT</span> <span class="string">&#x27;入学时间&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span> <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">id INT NOT NULL PRIMARY KEY AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;全局id&#x27;</span>, </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TableName2 <span class="keyword">LIKE</span> TableName1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tableName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span>(<span class="keyword">DROP</span>) 属性（数据类型、约束、其他属性）</span><br><span class="line">eg:</span><br><span class="line"><span class="comment"># 在stuent表中添加qq列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> qq <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;qq&#x27;</span>;</span><br><span class="line"><span class="comment"># 在sname后加微信列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> wechat <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>  <span class="keyword">COMMENT</span> <span class="string">&#x27;微信号&#x27;</span> <span class="keyword">AFTER</span> sname ;</span><br><span class="line"><span class="comment"># 在id列前加一个新列num</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">num</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;数字&#x27;</span> <span class="keyword">FIRST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">num</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> qq;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> wechat;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sgender 改为 sg 数据类型改为 CHAR 类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">change</span> sgender sg <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;n&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用的时候，一定要注意：</span><br><span class="line">修改数据类型，修改字段位置  <span class="comment">---用modify</span></span><br><span class="line">修改名字 <span class="comment">--就用change</span></span><br><span class="line"><span class="comment"># 范围大用change，小用modify。</span></span><br><span class="line"><span class="comment"># 均需要加入类型，限制</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>表名小写</li>
<li>不能是数字开头</li>
<li>注意字符集和存储引擎</li>
<li>表名和业务有关</li>
<li>选择合适的数据类型，简短的、长度合适的数据类型</li>
<li>每个列都要有注释</li>
<li>每个列设置为非空，无法保证非空，用0来填充。</li>
<li>必须有主键</li>
</ol>
</blockquote>
<h4 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h4><p>控制就是操作权限，而在DCL之中，主要有两个语法：GRANT,REVOKE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用户管理</span><br><span class="line">create user xxx@&quot;白名单&quot; indentified by &quot;password&quot;</span><br><span class="line">drop user</span><br><span class="line">alter user</span><br><span class="line">select user,host from mysql.user;</span><br><span class="line"># 权限</span><br><span class="line">## 查看所有权限列表</span><br><span class="line">show privileges;</span><br><span class="line">all </span><br><span class="line">with grant option</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">show grant UserName@&quot;白名单&quot;</span><br><span class="line">select * from mysql.user\G; </span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmfo1pre7wj31hy0u0afz.jpg" alt=""></p>
<p><strong>DCL</strong></p>
<p>授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant 权限 on 对象 to 用户 identified by “密码”</span><br><span class="line"># mysql 8.0+:(中文表示，可自定制)</span><br><span class="line">create user 用户 identified by “密码”</span><br><span class="line">grant 权限1，权限2，权限3... on 对象 to 用户 identified by “密码”</span><br></pre></td></tr></table></figure>
<p>权限:<br>    ALL: 管理员(不包含“    Grant option”，给他人授权)<br>    权限1，权限2，权限3…： 普通人员(开发人员)<br>    Grant option</p>
<p>对象范围:  库，表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">“.”</th>
<th style="text-align:center">—-&gt; chmod  -R 755 /</th>
<th style="text-align:center">管理员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">userName.*</td>
<td style="text-align:center">—-&gt; chmod  -R 755 userName/</td>
<td style="text-align:center">普通用户</td>
</tr>
<tr>
<td style="text-align:center">userName.t1</td>
<td style="text-align:center">—-&gt; chmod  -R 755 userName/t1</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 授权</span><br><span class="line">grant create update, select ... on 库名.表的范围[*(所有), 表名1] to userName@“白名单”</span><br></pre></td></tr></table></figure>
<p>Mysql授权表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">user</th>
<th style="text-align:center"><em>.</em></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">db</td>
<td style="text-align:center">db.*</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Tables_priv</td>
<td style="text-align:center">db.table</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Colums</td>
<td style="text-align:center">列</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Procs_priv</td>
<td style="text-align:center">存储过程中的权限</td>
</tr>
</tbody>
</table>
</div>
<p>回收权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revoke 权限 on 库 from 用户@“白名单”</span><br><span class="line"># 具体eg如上</span><br></pre></td></tr></table></figure>
<p>拓展，忘记root密码了该怎么办？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需知</span><br><span class="line"># --skip-grant-tables 跳过授权表</span><br><span class="line"># --skip-network  关闭TCP&#x2F;IP连接</span><br><span class="line"></span><br><span class="line"># 1.关闭数据库(任选其一)</span><br><span class="line">service mysqld stop</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;mysqld stop</span><br><span class="line">pkill mysqld</span><br><span class="line"></span><br><span class="line"># 2.跳过验证(任选其一)</span><br><span class="line">service mysqld start --skip-grant-tables</span><br><span class="line">service mysqld restart --skip-grant-tables</span><br><span class="line">mysql_safe --skip-grant-tables &amp;</span><br><span class="line"></span><br><span class="line"># 3.禁止远程连接</span><br><span class="line">service mysqld start --skip-grant-tables --skip-network </span><br><span class="line">service mysqld restart --skip-grant-tables --skip-network</span><br><span class="line"></span><br><span class="line"># 4.修改密码</span><br><span class="line">## 4.1手动加载授权表</span><br><span class="line">flush privileges</span><br><span class="line">## 4.2修改密码</span><br><span class="line">alter user root@&quot;localhost&quot; indentified by &quot;new Passwd&quot;</span><br><span class="line"></span><br><span class="line"># 5.重启数据库</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><strong>原理探究</strong></p>
<p>说到这个，那就不得不从mysql的<code>server</code>层说起了，mysql的架构图如下(仅关键部分)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgl5sg1n2j30rq0ic3yp.jpg" alt=""></p>
<p>当我们忘记密码的时候,改怎么办呢？</p>
<p>这就对于我们平时对于mysql的模型有所考察了，如果你知道mysql的他内部到底是如何运行的,那么只需要在合适的地方，按照我们所想的给他“绕道而行”，是否就可以绕过这个密码验证了呢？答案是当然可以的。</p>
<p>首先我们介绍一下上面这副图中执行流程，当我们启动mysql服务的时候，系统会自动帮我们做一下这些事儿</p>
<ol>
<li>首先提供可连接的协议，也就是提供服务</li>
<li>打开用户与密码校验，以处理将要连接的客户</li>
<li>验证成功，分配独立的连接线程</li>
</ol>
<p>如果我们需要跳过密码校验,那么只需要做以下几件事。</p>
<ol>
<li>让系统重启</li>
<li>在重启的过程中停掉用户与密码校验</li>
</ol>
<p>这样我们就可以连接了，但是还不够。尽然已经停掉了。此时的我们无法修改密码.(跳过验证，而不是把验证功能移除了)</p>
<p>那么我们此时还需要把验证功能加载进来，然后对验证的表进行修改。</p>
<h4 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h4><p>这个也是我们日常中用的最多的地方，应为建库表，改权限，改密码。修改等等什么的并不是每次都要嘛.这个也很好理解</p>
<blockquote>
<p>DML 数据操作语言 对表中的数据行进行增、删、改</p>
</blockquote>
<p><strong>insert</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">单行数据</span><br><span class="line">INSERT INTO tableName(key1, key2, key3..) VALUES(value1, value2,value3...) [SELECT * FROM tableName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行数据</span></span><br><span class="line">INSERT INTO tableName(key1, key2, key3..) VALUES \</span><br><span class="line">(value1, value2,value3...)</span><br><span class="line">(value1, value2,value3...)</span><br><span class="line">(value1, value2,value3...);</span><br><span class="line">...</span><br><span class="line">[SELECT * FROM tableName]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入时, key1,key2,key3 必须与value1，value2， value3 数量一致</p>
<p>插入对应字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO tableName(key1, key3..) VALUES(value1, value3...) [SELECT * FROM tableName]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>update</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新前我们一般都会先查表内数据</span><br><span class="line"># 查询出对应表已存在所有行</span><br><span class="line">DESC tableName;</span><br><span class="line"># 查询对应表已存在数据</span><br><span class="line">SELECT * FROM tableName;	# * 可替换成字段名，查对应字段</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line">UPDATE student SET 字段名&#x3D;&#39;新值&#39; [WHERE 限定条件];</span><br></pre></td></tr></table></figure>
<p>Eg:</p>
<p>创建一张新的student表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建表</span><br><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line"> &#96;id&#96; int NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,</span><br><span class="line"> &#96;sname&#96; varchar(255) CHARACTER SET utf8 NOT NULL COMMENT &#39;姓名&#39;,</span><br><span class="line"> &#96;sage&#96; tinyint unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,</span><br><span class="line"> &#96;intime&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入学时间&#39;,</span><br><span class="line"> PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci COMMENT&#x3D;&#39;学生表&#39;</span><br><span class="line"></span><br><span class="line"># 插入演示数据</span><br><span class="line">INSERT INTO student(sname,sage) VALUES(&quot;赵一&quot;, 1),</span><br><span class="line">(&quot;王二&quot;, 2),</span><br><span class="line">(&quot;张三&quot;, 3),</span><br><span class="line">(&quot;李四&quot;, 4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据库</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgmsbglbmj30ey09it8s.jpg" alt=""></p>
<p>需求一:</p>
<p>李四改名为“里斯”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sname&#x3D;&quot;里斯&quot; WHERE sname &#x3D; &quot;李四&quot;;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">UPDATE student SET sname&#x3D;&quot;里斯&quot; WHERE id&#x3D;4;</span><br><span class="line">UPDATE student SET sname&#x3D;&quot;里斯&quot; WHERE sage&#x3D;4;</span><br></pre></td></tr></table></figure>
<p>修改后，如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgmx1cum6j30ey09eq30.jpg" alt=""></p>
<p>需求二:</p>
<p>将所有表内成员的年龄+10;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sage&#x3D;sage + 10</span><br><span class="line"># UPDATE student SET sage+&#x3D;10(错误写法,开发时候用的什么sage ++， sage +&#x3D;，在这里都不允许)</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgn1b1f0bj30f009ct8s.jpg" alt=""></p>
<p>需求三:将所有表内成员的年龄+10,除了里斯</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sage&#x3D;sage + 10 WHERE sname !&#x3D; &quot;里斯&quot;;</span><br><span class="line"># 当然也可以这样写;</span><br><span class="line">UPDATE student SET sage&#x3D;sage + 10 WHERE sname &#x3D; &quot;赵一&quot; OR sname &#x3D; &quot;王二&quot; OR sname&#x3D;&quot;张三&quot; ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AND: 执行均满足</p>
<p>OR: 满足其一执行</p>
<p>where 见下文</p>
</blockquote>
<p><strong>delete</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"># 删除指定数据</span><br><span class="line">DELETE FROM tableName  [WHERE <span class="keyword">id</span>=<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"># 清空标中所有数据</span><br><span class="line">DELETE FROM student;</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别:<br>delete: DML操作, 是逻辑性质删除,逐行进行删除,速度慢.<br>truncate: DDL操作,对与表段中的数据页进行清空,速度快.</p>
</blockquote>
<p>伪删除：用update来替代delete，最终保证业务中查不到（select）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.添加状态列</span><br><span class="line">ALTER TABLE stuent ADD state TINYINT NOT NULL DEFAULT 1 ;</span><br><span class="line">SELECT * FROM stuent;</span><br><span class="line">2. UPDATE 替代 DELETE</span><br><span class="line">UPDATE stuent SET state&#x3D;0 WHERE id&#x3D;6;</span><br><span class="line">3. 业务语句查询</span><br><span class="line">SELECT * FROM stu WHERE state&#x3D;1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>拓展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM student;</span><br><span class="line">DROP TABLE student;</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<p>以上三条删除语句有何区别？</p>
<p>同：三者都是删除语句，均可删除</p>
<p>异:</p>
<p>DELETE FROM student:</p>
<p>逻辑上<code>逐行</code>删除，数据过多，操作很慢</p>
<p>并没有真正的从磁盘上删除，知识在磁盘上打上标记，磁盘空间不立即释放。HWM高位线不会降低</p>
<p>DROP TABLE student;</p>
<p>将表结构(元数据)和数据行，物理层次删除</p>
<p>truncate truncate table student;</p>
<p>清空表段中的所有数据页，物理层次删除全表数据，磁盘空间立即释放。HWM高位线降低</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmhjljoy2gj30j20643zc.jpg" alt=""></p>
</blockquote>
<h4 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h4><p>show类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show CREATE DATABASE databaseName;</span><br><span class="line"></span><br><span class="line">show table;</span><br><span class="line">show CREATE TABLE table;</span><br><span class="line"></span><br><span class="line">desc tableName;</span><br></pre></td></tr></table></figure>
<p><strong>select类</strong> </p>
<blockquote>
<p>获取表中的数据行</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">select</span> @<span class="keyword">@xxx</span> 查看系统参数</span><br><span class="line">SELECT @@port;</span><br><span class="line"><span class="selector-tag">SELECT</span> @<span class="keyword">@basedir</span>;</span><br><span class="line"><span class="selector-tag">SELECT</span> @<span class="keyword">@datadir</span>;</span><br><span class="line"><span class="selector-tag">SELECT</span> @<span class="keyword">@socket</span>;</span><br><span class="line"><span class="selector-tag">SELECT</span> @<span class="keyword">@server_id</span>;</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">select</span> 函数</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">NOW</span>();</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">DATABASE</span>();</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">USER</span>();</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">CONCAT</span>(&quot;<span class="selector-tag">hello</span> <span class="selector-tag">world</span>&quot;);</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">CONCAT</span>(<span class="selector-tag">USER</span>,&quot;@&quot;,HOST) FROM mysql.user;</span><br><span class="line"><span class="selector-tag">SELECT</span> <span class="selector-tag">GROUP_CONCAT</span>(<span class="selector-tag">USER</span>,&quot;@&quot;,HOST) FROM mysql.user;</span><br></pre></td></tr></table></figure>
<p>手册 <a href="https://dev.mysql.com/doc/refman/8.0/en/sql-function-reference.html">https://dev.mysql.com/doc/refman/8.0/en/sql-function-reference.html</a></p>
<p>select配合子句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">FROM 表1，表2...,</span><br><span class="line">WHERE 过滤条件1，过滤条件2，过滤条件3 ...</span><br><span class="line">GROUP BY 条件列1，条件列2，条件列3 ...</span><br><span class="line">	# selct_list 列名</span><br><span class="line">HAVING 过滤条件1，过滤条件2，过滤条件3 ...</span><br><span class="line">ORDER BY 条件列1，条件列2，条件列3 ...</span><br><span class="line">LIMIT 限制条件;</span><br></pre></td></tr></table></figure>
<p><strong>单表子句-from</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列1,列2 FROM 表</span><br><span class="line">SELECT  *  FROM 表</span><br><span class="line"></span><br><span class="line"># EG</span><br><span class="line"># 查询student中所有的数据(不要对大表进行操作)</span><br><span class="line">SELECT * FROM stu ;</span><br><span class="line"># 查询stu表中,学生姓名和入学时间</span><br><span class="line">SELECT sname , intime FROM stuent;</span><br></pre></td></tr></table></figure>
<p><strong>单表子句-where</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT col1,col2 FROM TABLE WHERE colN 条件;</span><br><span class="line"># where 操作符(&gt;、&lt;、&gt;&#x3D;、 &lt;&#x3D;、 &lt;&gt;、in、like、and、or)</span><br><span class="line">SELECT col1,col2 FROM TABLE WHERE &#x3D; 条件;</span><br><span class="line"></span><br><span class="line"># where 模糊查询</span><br><span class="line">SELECT * FROM city WHERE district LIKE &#39;guang%&#39;;    </span><br><span class="line">%  : 表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</span><br><span class="line">_  : 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句</span><br><span class="line">[] : 表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</span><br><span class="line"></span><br><span class="line"># where配合between...and...</span><br><span class="line">SELECT * FROM city  WHERE population &gt;1000000 AND population &lt;2000000;</span><br><span class="line">SELECT * FROM city  WHERE population BETWEEN 1000000 AND 2000000;</span><br></pre></td></tr></table></figure>
<p> <strong>group by</strong></p>
<p>根据 by后面的条件进行分组，方便统计，by后面跟一个列或多个列</p>
<p>未分组分组列，使用聚合函数</p>
<p>聚合函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">**<span class="built_in">max</span>()**      ：最大值</span><br><span class="line">**<span class="built_in">min</span>()**      ：最小值</span><br><span class="line">**avg()**      ：平均值</span><br><span class="line">**sum()**      ：总和</span><br><span class="line">**<span class="built_in">count</span>()**    ：个数</span><br><span class="line">group_concat() : 列转行</span><br></pre></td></tr></table></figure>
<p><strong>HAVING</strong></p>
<p>需要在group by 之后，在做判断过滤使用(类似于where)</p>
<p><strong>order by</strong></p>
<blockquote>
<p>实现先排序，by后添加条件列(默认从小到大)</p>
<p>逆序：后加DESC</p>
</blockquote>
<p><strong>distinct：去重复</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT countrycode FROM city ;</span><br><span class="line"><span class="function">SELECT <span class="title">DISTINCT</span><span class="params">(countrycode)</span> FROM city  </span>;</span><br></pre></td></tr></table></figure>
<p>联合查询- union all</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">-- 中国或美国城市信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM city </span><br><span class="line"><span class="function">WHERE countrycode <span class="title">IN</span> (<span class="params"><span class="string">&#x27;CHN&#x27;</span> ,<span class="string">&#x27;USA&#x27;</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">SELECT * FROM city WHERE countrycode=<span class="string">&#x27;CHN&#x27;</span></span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM city WHERE countrycode=<span class="string">&#x27;USA&#x27;</span></span><br><span class="line"></span><br><span class="line">说明:一般情况下,我们会将 IN 或者 OR 语句 改写成 UNION ALL,来提高性能</span><br><span class="line">UNION     去重复</span><br><span class="line">UNION ALL 不去重复</span><br></pre></td></tr></table></figure>
<p><strong>LIMIT 限制条件</strong></p>
<p>限制查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> 限制条件</span><br><span class="line">eg:</span><br><span class="line"><span class="comment">--- 只输出前1000条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line"><span class="comment">--- 只输出前1000-2000条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">1000</span>, <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">1000</span>, <span class="number">2000</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">2000</span> <span class="keyword">OFFSET</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p><strong>join 多表连接查询</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmhk5wso0sj31080ak76b.jpg" alt=""></p>
<p><strong>内连接</strong></p>
<p>查询li4家的地址</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.name,B.address <span class="keyword">FROM</span></span><br><span class="line">A <span class="keyword">JOIN</span>  B</span><br><span class="line"><span class="keyword">ON</span> A.id=B.id	<span class="comment">--- 关联列</span></span><br><span class="line"><span class="keyword">WHERE</span> A.name=<span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.name,B.address <span class="keyword">FROM</span></span><br><span class="line">A <span class="keyword">JOIN</span>  B</span><br><span class="line"><span class="keyword">ON</span> A.id=B.id</span><br><span class="line"><span class="keyword">WHERE</span> A.name=<span class="string">&#x27;li4&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>外连接</strong></p>
<p>驱动表建议使用 数据少的表 为驱动表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.name,B.address <span class="keyword">FROM</span></span><br><span class="line">A <span class="keyword">JOIN</span>  B</span><br><span class="line"><span class="keyword">ON</span> A.id=B.id	<span class="comment">--- 关联列</span></span><br><span class="line"><span class="keyword">WHERE</span> A.name=<span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.name,B.address <span class="keyword">FROM</span></span><br><span class="line">A <span class="keyword">left</span> <span class="keyword">JOIN</span>  B</span><br><span class="line"><span class="keyword">ON</span> A.id=B.id</span><br><span class="line"><span class="keyword">WHERE</span> A.name=<span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---  A left JOIN  B 其中a位驱动表</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点go并发那些事儿</title>
    <url>/2021/02/03/%E7%9B%98%E7%82%B9go%E5%B9%B6%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="盘点Golang并发那些事儿之一"><a href="#盘点Golang并发那些事儿之一" class="headerlink" title="盘点Golang并发那些事儿之一"></a>盘点Golang并发那些事儿之一</h2><blockquote>
<p>一生很短，Let’s Go</p>
<p>人生苦短，我用Python</p>
</blockquote>
<p>Golang、Golang、Golang 真的够浪，今天我们一起盘点一下<code>Golang</code>并发那些事儿，准确来说是<code>goroutine</code>,关于多线程并发，咱们暂时先放一放(主要是俺现在还不太会，不敢出来瞎搞)。关于<code>golang</code>优点如何，咱们也不扯那些虚的。反正都是大佬在说，俺只是个吃瓜群众，偶尔打打酱油，逃～。<br><a id="more"></a><br>说到并发，等等一系列的骚概念就出来了，为了做个照顾一下自己的菜，顺便复习一下</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p><strong>进程</strong>（英语：process），是指计算机中已运行的<code>程序</code>。进程曾经是<code>`分时系统</code>的基本运作单位。在面向进程设计的系统（如早期的<code>UNIX</code>，<code>Linux 2.4</code>及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、<code>Linux</code> 2.6及更新的版本）中，进程本身不是基本运行单位，而是<strong>线程</strong>的容器。</p>
<p>程序本身只是指令、数据及其组织形式的描述，相当于一个名词，进程才是程序（那些指令和数据）的真正运行实例，可以想像说是现在进行式。若干进程有可能与同一个程序相关系，且每个进程皆可以同步或<strong>异步</strong>的方式独立运行。现代<strong>计算机系统</strong>可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称<strong>时分复用</strong>），以在一个<strong>处理器</strong>上表现出同时<strong>平行性</strong>运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的<strong>平行</strong>线程，可在多CPU主机或网络上真正<strong>同时</strong>运行（在不同的CPU上）。</p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>操作系统需要有一种方式来创建进程。</p>
<p>以下4种主要事件会创建进程</p>
<ol>
<li>系统初始化    （简单可理解为关机后的开机）</li>
<li>正在运行的程序执行了创建进程的系统调用（例如：朋友发了一个网址，你点击后开启浏览器进入网页中）</li>
<li>用户请求创建一个新进程（例如：打开一个程序，打开QQ、微信）</li>
<li>一个批量作业的初始化</li>
</ol>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>进程在创建后，开始运行与处理相关任务。但并不会永恒存在，终究会完成或退出。那么以下四种情况会发生进程的终止</p>
<ol>
<li>正常退出（自愿）</li>
<li>错误退出（自愿）</li>
<li>崩溃退出（非自愿）</li>
<li>被其他杀死（非自愿）</li>
</ol>
<p>正常退出：你退出浏览器，你点了一下它<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9kz2montj301i01aa9t.jpg" alt=""></p>
<p>错误退出：你此时正在津津有味的看着电视剧，突然程序内部发生bug，导致退出<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9l4ovbrdj31u70u0jsv.jpg" alt=""></p>
<p>崩溃退出：你程序崩溃了<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9ldqess0j31ds0sogmr.jpg" alt=""></p>
<p>被其他杀死：例如在windows上，使用任务管理器关闭进程</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ol>
<li>运行态(实际占用CPU)</li>
<li>就绪态(可运行、但其他进程正在运行而暂停)</li>
<li>阻塞态(除非某种外部的时间发生，否则进程不能运行)</li>
</ol>
<p>前两种状态在逻辑上是类似的。处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有分配CPU，一旦分配到了CPU即可运行</p>
<p>第三种状态与前两种不同，处于该状态的进程不能运行，即是CPU空闲也不行。</p>
<blockquote>
<p>如有兴趣，可进一步了解进程的实现、多进程设计模型</p>
</blockquote>
<h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><p>进程池技术的应用至少由以下两部分组成：</p>
<p><strong>资源进程</strong></p>
<p>预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。</p>
<p><strong>管理进程</strong></p>
<p>管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。</p>
<p>资源进程跟管理进程的概念很好理解，管理进程如何有效的管理资源进程，分配任务给资源进程，回收空闲资源进程，管理进程要有效的管理资源进程，那么管理进程跟资源进程间必然需要交互，通过IPC，信号，<a href="https://baike.baidu.com/item/信号量">信号量</a>，<a href="https://baike.baidu.com/item/消息队列">消息队列</a>，管道等进行交互。</p>
<blockquote>
<p>进程池：准确来说它并不实际存在于我们的操作系统中，而是IPC，信号，<a href="https://baike.baidu.com/item/信号量">信号量</a>，<a href="https://baike.baidu.com/item/消息队列">消息队列</a>，管道等对多进程进行管理，从而减少不断的开启、关闭等操作。以求达到减少不必要的资源损耗</p>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>线程</strong>（英语：thread）是<strong>操作系统</strong>能够进行运算<strong>调度</strong>的最小单位。大部分情况下，它被包含在<strong>进程</strong>之中，是<strong>进程</strong>中的实际运作单位。一条线程指的是<strong>进程</strong>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在<strong>Unix System V</strong>及<strong>SunOS</strong>中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程</p>
<p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，<strong>文件描述符</strong>和<strong>信号处理</strong>等等。但同一进程中的多个线程有各自的<code>调用栈</code>（call stack），自己的<code>寄存器环境</code>（register context），自己的线程本地存储（thread-local storage）。</p>
<p>一个进程可以有很多线程来处理，每条线程并行执行不同的任务。如果进程要完成的任务很多，这样需很多线程，也要调用很多核心，在多核或多<strong>CPU</strong>，或支持<strong>Hyper-threading</strong>的CPU上使用多线程程序设计的好处是显而易见的，即提高了程序的执行吞吐率。以人工作的样子想像，核心相当于人，人越多则能同时处理的事情越多，而线程相当于手，手越多则工作效率越高。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，虽然多任务比不上多核，但因为具备多线程的能力，从而提高了程序的执行效率。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><strong>线程池</strong>（英语：thread pool）：一种<a href="https://zh.wikipedia.org/wiki/线程">线程</a>使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。</p>
<p>任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。</p>
<p>线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。 </p>
<ul>
<li>半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。</li>
<li>领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。在<a href="https://zh.wikipedia.org/wiki/ACE自适配通信环境">ACE</a>(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。</li>
</ul>
<p>线程池的<strong>伸缩性</strong>对性能有较大的影响。</p>
<ul>
<li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li>
<li>销毁太多线程，将导致之后浪费时间再次创建它们。</li>
<li>创建线程太慢，将会导致长时间的等待，性能变差。</li>
<li>销毁线程太慢，导致其它线程<strong>资源</strong>饥饿。</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，英文叫作 Coroutine，又称微线程、纤程，协程是一种用户态的轻量级线程。</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。</p>
<p>协程本质上是个单进程，协程相对于多进程来说，无需线程上下文切换的开销，无需原子操作锁定及同步的开销，编程模型也非常简单。</p>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p>多个任务，执行完毕后再执行另一个。</p>
<p>例如：吃完饭后散步(先坐下吃饭、吃完后去散步)</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多个任务、交替执行</p>
<p>例如：做饭，一会放水洗菜、一会吸收(菜比较脏，洗下菜写下手，傲娇～)</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>共同出发</p>
<p>边吃饭、边看电视</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。</p>
<p>常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU 切换上下文时，所有的进程都无法真正处理事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的。</p>
<p>非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。</p>
<p>非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。</p>
<p>例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。</p>
<p>简言之，同步意味着有序。</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。</p>
<p>例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。</p>
<h2 id="可异步与不可异步"><a href="#可异步与不可异步" class="headerlink" title="可异步与不可异步"></a>可异步与不可异步</h2><p>经过以上了解，又是进程、又是线程、等等一系列的骚东西，那是真的难受。不过相信你已经有个初步的概率，那么这里我们将更加深入的去了解<code>可异步</code>与<code>不可异步</code>。</p>
<p>在此之前先总结一下，以上各种演进的路线，其实加速无非就是一句话，提高效率。（废话～）</p>
<p>那么提高效率的是两大因素，增加投入以求增加产出、尽可能避免不必要的损耗（例如：减少上下文切换等等）。</p>
<p>如何区分它是可异步代码还是不可异步呢，其实很简单那就是，它是否能够自主完成不需要我们参与的部分。</p>
<p>我们从结果反向思考，</p>
<p>例如我们发送一个网络请求，这之间拥有网络I/O阻塞，那么测试我们将它挂起、转而去做其他事情，等他响应了，我们在进行此阶段的下一步的操作。那么这个是可异步的</p>
<p>另外：写作业与上洗手间，我此时正在写着作业，突然，我想上洗手间了，走。上完洗手间后又回来继续写作业，在我去洗手间这段时间作业是不会有任何进展，所以我们可以理解为这是非异步</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>东扯一句，西扯一句，终于该上真家伙了，废话不多说。</p>
<p>如何实现只需定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行。</p>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了</p>
<h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>
<h3 id="goroutine模型"><a href="#goroutine模型" class="headerlink" title="goroutine模型"></a>goroutine模型</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的，  不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，  不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。  另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，  再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<h2 id="goroutine的创建"><a href="#goroutine的创建" class="headerlink" title="goroutine的创建"></a>goroutine的创建</h2><p>使用<code>goroutine</code>非常简单，只需要在调用函数的时在函数名前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>goroutine</code>必定对应一个函数，当然也可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<p>语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> 函数()[普通函数和匿名函数即可]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你此时兴致勃勃的想立马试试，我只想和你说，“少侠，请稍等～”，我话还没说完。以上我只说了如何创建<code>goroutine</code>，可没说这样就是这样用的。嘻嘻～</p>
<p>首先我们先看看不用<code>goroutine</code>的代码，示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># example</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;HelloWord~, stamp is&quot;, i)</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		example(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main~&quot;</span>)</span><br><span class="line">	spendTime := time.Since(startTime)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Spend Time:&quot;</span>, spendTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入结果如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnalxc9lv8j31hk0oet9n.jpg" alt=""></p>
</blockquote>
<p>那么我们来使用<code>goroutine</code>，运行</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func example(i int) &#123;</span><br><span class="line">	fmt.Println(&quot;HelloWord~, stamp is&quot;, i)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; normal</span><br><span class="line">func main() &#123;</span><br><span class="line">	startTime :&#x3D; time.Now()</span><br><span class="line">	&#x2F;&#x2F; 创建十个goroutine</span><br><span class="line">	for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go example(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;Main~&quot;)</span><br><span class="line">	spendTime :&#x3D; time.Since(startTime)</span><br><span class="line">	fmt.Println(&quot;Spend Time:&quot;, spendTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnalzq72m1j30zk0u0q56.jpg" style="zoom:50%;" /></p>
</blockquote>
<p>乍一看，好家伙速度提升了简直不是一个量级啊，秒啊～</p>
<p>仔细看你会发现，7,9 跑去哪儿呢？不见了，盯～</p>
<p>谜底在下一篇揭晓～</p>
<p>期待下一篇，盘点Golang并发那些事儿之二，<code>goroutine</code>并发控制得心应手</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点go并发那些事儿之二-并发控制得心应手</title>
    <url>/2021/02/04/%E7%9B%98%E7%82%B9go%E5%B9%B6%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8B%E4%BA%8C-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%BE%97%E5%BF%83%E5%BA%94%E6%89%8B/</url>
    <content><![CDATA[<h2 id="盘点Golang并发那些事儿之二"><a href="#盘点Golang并发那些事儿之二" class="headerlink" title="盘点Golang并发那些事儿之二"></a>盘点Golang并发那些事儿之二</h2><p>上一节提到，golang中直接使用关键字<code>go</code>创建<code>goroutine</code>,无法满足我们的需求。主要问题如下</p>
<ul>
<li>无法有效的并发执行完成</li>
<li>无法有效的控制并发</li>
</ul>
<p>首先我们再来看看下面这个栗子，代码如下<br><a id="more"></a><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example-goroutine anonymous</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymous1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="comment">// 创建十个goroutine</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;HelloWord~, stamp is&quot;</span>, i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main~&quot;</span>)</span><br><span class="line">	spendTime := time.Since(startTime)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Spend Time:&quot;</span>, spendTime)</span><br><span class="line">	<span class="comment">// 防止goroutine提前退出</span></span><br><span class="line">	<span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine anonymous</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	anonymous2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbcfbzjn2j31890u0wgd.jpg" style="zoom:25%;" /></p>
<p>此时你会发现有些任务被多次执行了，但有些任务却又没有被执行。以上例子虽加速了运行，但带来的损失却也是巨大的。例如银行转账等，一旦出现以上情况多次付款也随之而来了。弊大于利</p>
<p>首先我们来分析以上代码，为什么会出现此种情况？虽然是个废品，但也是俺辛辛苦苦的写的不是，让俺做个明白鬼。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbcxvhqt1j30oc0s0q33.jpg" style="zoom:50%;" /></p>
<p>我们从里面往外分析<code>anonymous1</code>首先他是个匿名函数 + 立即执行函数，且变量<code>i</code>并不是传递的参数，而是外部循环带进来的。由上图，我们知道，执行流程为先创建goroutine，执行逻辑，返回结果。</p>
<blockquote>
<p>请思考：</p>
<p>goroutine，越多越好么？为什么</p>
<p>如何避免以上情景？如何避免提前退出？</p>
</blockquote>
<h2 id="信道-Channel"><a href="#信道-Channel" class="headerlink" title="信道-Channel"></a>信道-Channel</h2><p>信道的英文是channel，在golang当中的关键字是chan。它的用途是用来<strong>在goroutine之间传输数据</strong>，这里你可能要问了，为什么一定得是goroutine之间传输数据呢，函数之间传递不行吗？</p>
<p>因为正常的传输数据直接以参数的形式传递就可以了，只有在并发场景当中，多个线程彼此隔离的情况下，才需要一个特殊的结构传输数据。</p>
<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<blockquote>
<p>channel底层的实现为互斥锁</p>
</blockquote>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"><span class="comment">// example-var</span></span><br><span class="line"><span class="comment">// 只声明</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">chan</span> []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">chan</span> []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">a = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//example-2(推荐使用)</span></span><br><span class="line">管道名称 := <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型 [缓冲区size])</span><br></pre></td></tr></table></figure>
<h3 id="无缓冲channel"><a href="#无缓冲channel" class="headerlink" title="无缓冲channel"></a>无缓冲channel</h3><p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, Gopher. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">const</span> jobNumber = <span class="number">100</span> * <span class="number">100</span></span><br><span class="line">	<span class="comment">// create chan</span></span><br><span class="line">	intCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= jobNumber; i++ &#123;</span><br><span class="line">		<span class="comment">// create goroutine same number for jobNumber</span></span><br><span class="line">		<span class="keyword">go</span> hello(intCh)</span><br><span class="line">		intCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Completed, Spend Time :&quot;</span>, time.Since(startTime))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbiwoqycdj312e0u0mzi.jpg" style="zoom:50%;" /></p>
<p>这速度可谓是非常的快啊</p>
<h3 id="带缓冲Channel"><a href="#带缓冲Channel" class="headerlink" title="带缓冲Channel"></a>带缓冲Channel</h3><p>带缓冲的 channel(buffered channel) 是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：</p>
<p><strong>无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证</strong></p>
<p>来段代码压压惊</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, Gopher. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello1</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, Gopher1. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">const</span> jobNumber = <span class="number">100</span> * <span class="number">100</span></span><br><span class="line">	<span class="comment">// create chan</span></span><br><span class="line">	intCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= jobNumber; i++ &#123;</span><br><span class="line">		<span class="comment">// create goroutine same number for jobNumber</span></span><br><span class="line">		<span class="keyword">go</span> hello(intCh)</span><br><span class="line">		<span class="keyword">go</span> hello1(intCh)</span><br><span class="line">		intCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Completed, Spend Time :&quot;</span>, time.Since(startTime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjwzeu0mj31bn0u0q55.jpg" style="zoom:50%;" /></p>
<p>这速度杠杠滴哈，别急，同时也让我和你说执行流程，老规矩，上图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk988aw2j30o00oajrf.jpg" style="zoom:50%;" /></p>
<p>首先开始执行把需要传递的数据打到channle里面，然后goroutine去取，执行。那么有留下几个问题</p>
<blockquote>
<p>还可以加速么？</p>
<p>加速的方法？</p>
<p>可能带来什么新的问题？</p>
<p>如何解决？</p>
</blockquote>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。</p>
<p>单向 channel 的声明也很简单，只需要在声明的时候带上 &lt;- 操作符即可，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>使用单向 channel 的较多场景一般在函数参数中使用较多，这样可以防止一些操作影响了 channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example channel</span></span><br><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//example function</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exs</span><span class="params">(accept &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, recipient <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> accept &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received only sent channel a:&quot;</span>, result)</span><br><span class="line">		recipient &lt;- result + <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;Send Only&quot;, recipient)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> processNumber = <span class="number">100</span></span><br><span class="line">	sender := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, processNumber)</span><br><span class="line">	recipient := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, processNumber)</span><br><span class="line">	<span class="keyword">for</span> e := <span class="number">0</span>; e &lt; <span class="number">10</span>; e++ &#123;</span><br><span class="line">		<span class="keyword">go</span> exs(sender, recipient)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s := <span class="number">0</span>; s &lt; processNumber; s++ &#123;</span><br><span class="line">		sender &lt;- s</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; processNumber; r++ &#123;</span><br><span class="line">		<span class="comment">//&lt;-recipient</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;recipient&quot;</span>, &lt;-recipient)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小技巧：箭头该谁指谁?这可把我整的不好了，别慌，我告诉你，到底该谁指谁。其实很简单</p>
<p>箭头一致向左指</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &lt;- chan &lt;- b</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存入</span><br><span class="line">chan &lt;- b</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取出</span><br><span class="line">a :&#x3D; &lt;- chan </span><br></pre></td></tr></table></figure>
<p>Chan其实就是起到一个中间人的作用，箭头指向chan，那就是放入，chan指出去 就是拿出来。</p>
<p>相信你应该记住了吧，反正我记住了</p>
</blockquote>
<h3 id="多路复用Channel"><a href="#多路复用Channel" class="headerlink" title="多路复用Channel"></a>多路复用Channel</h3><p>假设要从网上下载一个文件，启动了 5个 goroutine 进行下载，并把结果发送到 5 个 channel 中。其中，哪个先下载好，就会使用哪个 channel 的结果。</p>
<p>在这种情况下，如果我们尝试获取第一个 channel 的结果，程序就会被阻塞，无法获取剩下4个 channel 的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在 Go 语言中，通过 select 语句可以实现多路复用，其语句格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构和 switch 非常像，都有 case 和 default，只不过 select 的 case 是一个个可以操作的 channel。</p>
<blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分</p>
<p>支，接收数据并处理。</p>
<p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select&#123;&#125;</code>会一直等待，可用于阻塞main函数。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example select</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：关于数据流动、传递等情况的优先使用<code>channle</code>， 它是并发安全的，且性能优异</p>
<h2 id="Sync深入并发控制"><a href="#Sync深入并发控制" class="headerlink" title="Sync深入并发控制"></a>Sync深入并发控制</h2><h3 id="sync-waitGroup"><a href="#sync-waitGroup" class="headerlink" title="sync.waitGroup"></a>sync.waitGroup</h3><p>在此之前我们先去，解决一个开启<code>goroutine</code>，提前退出的例子</p>
<p>示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&#x2F;&#x2F;&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">func main() &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 10 ; i++ &#123;</span><br><span class="line">		go exampleOut(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func exampleOut(i int)  &#123;</span><br><span class="line">	fmt.Println(&quot;Hello, Gopher, I am [Id]&quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbroyfdoyj319q0u00ue.jpg" style="zoom:50%;" /></p>
<p>仔细看，你会发现根本就没有输出，原因是它开启<code>goroutine</code>，也需要时间。main函数并会等待，当然我们也可以手动添加一个停止，但这个并不能有效的阻止(你我都知道需要多久才能把<code>goroutine</code>执行完成),那有没有办法。。。</p>
<p>答案当然是有滴，它就是<code>sync.WaitGroup</code></p>
<blockquote>
<p>WaitGroup等待goroutine的集合完成。主goroutine调用添加以设置要等待的goroutine的数量。然后，每个goroutine都会运行并在完成后调用Done。同时，可以使用Wait来阻塞，直到所有goroutine完成。</p>
<p>你可以理解为计数器</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `sync.WaitGroup`一共有三个方法,他们分别是：</span></span><br><span class="line">Add(delta <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//Add将可能为负数的增量添加到WaitGroup计数器中。如果计数器为零，则释放等待时阻塞的所有goroutine</span></span><br><span class="line">Done()</span><br><span class="line"><span class="comment">// 完成将WaitGroup计数器减一。</span></span><br><span class="line"> Wait()</span><br><span class="line"><span class="comment">// 等待块，直到WaitGroup计数器为零。</span></span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitGroup</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明WaitGroup</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// WaitGroup 计数器 + 1</span></span><br><span class="line">		<span class="comment">// 其delta为你开启的`groutine`数量</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> exampleOut(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待 WaitGroup 计数器为0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exampleOut</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// WaitGroup 计数器 - 1</span></span><br><span class="line">	wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, Gopher, I am [Id]&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>无论是前面的<code>channle</code>还是sync都是为了干一件事，那就是并发控制，也许你也和我一样有以下几个问题</p>
<ul>
<li>我们为什么需要并发控制，不要可以么？</li>
<li>并发控制到底是控制什么？</li>
<li>并发控制有哪几种方案，他们分别适用于哪种场景？</li>
<li>如何做好并发控制呢？</li>
</ul>
<p>以上几点就是我们此节需要了解、以及解决的问题</p>
<p>首先解决我们一起探究第一个问题，为什么需要并发控制？</p>
<p>首先有这么一个问题、以及相关的解决措施，绝对不是脱裤子放屁，多此一举。需要并发控制的原因有很多，总结一句话那就是资源竞争</p>
<blockquote>
<p>资源竞争</p>
<p>在一个 goroutine 中，如果分配的内存没有被其他 goroutine 访问，只在该 goroutine 中被使用，那么不存在资源竞争的问题。</p>
<p>但如果同一块内存被多个 goroutine 同时访问，就会产生不知道谁先访问也无法预料最后结果的情况。这就是资源竞争，这块内存可以称为共享的资源</p>
<p>还记得在channel中，我讲到 Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>，这点尤为重要需要我们去记住与掌握</p>
</blockquote>
<p>首先我们来看一个累加求和的例子，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x <span class="keyword">int64</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		x = x + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>期待输出值为<code>25000</code>，sum + 10 加和 5000次,执行五次，我们口算答案是<code>5000</code>,可输出结果却是<code>3048</code>,而且每次答案还不一样。好家伙</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbt36anhqj319i0u0q43.jpg" style="zoom:50%;" /></p>
<p>这是为什么呢?,靓仔疑惑～</p>
<p>其根本的原因就是资源恶意竞争</p>
<blockquote>
<p>精囊妙计：</p>
<p>使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">go</span> run -race demo3.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么该怎么解决呢？</p>
<p><code>sync.Mutex</code>互斥锁，顾名思义，指的是在同一时刻只有一个<code>goroutine</code>执行某段代码，其他<code>goroutine</code>都要等待该<code>goroutine</code>执行完毕后才能继续执行。</p>
<p>在下面的示例中，我声明了一个互斥锁 mutex，然后修改 add 函数，对 sum+=i 这段代码加锁保护。这样这段访问共享资源的代码片段就并发安全了，可以得到正确的结果</p>
<p><code>sync.Mutex</code>为我们提供了两个方法，加锁与解锁,修改时先获取锁，修改后释放锁</p>
<p>代码修改如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x    <span class="keyword">int64</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">		x += <span class="number">1</span></span><br><span class="line">		lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>女少啊～</p>
<blockquote>
<p>在以上示例代码中<code>x += 1</code>，部分被称之为临界区</p>
<p>在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个<code>goroutine</code>访问的特性。 当有协程进入临界区段时，其他协程必须等待，这样就保证了临界区的并发安全。</p>
</blockquote>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x      <span class="keyword">int64</span></span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// lock.Lock()   											// 加互斥锁</span></span><br><span class="line">	rwlock.Lock() 												<span class="comment">// 加写锁</span></span><br><span class="line">	x = x + <span class="number">1</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond) 		<span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">	rwlock.Unlock()                   		<span class="comment">// 解写锁</span></span><br><span class="line">	<span class="comment">// lock.Unlock()                      // 解互斥锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// lock.Lock()                  			// 加互斥锁</span></span><br><span class="line">	rwlock.RLock()               					<span class="comment">// 加读锁</span></span><br><span class="line">	time.Sleep(<span class="number">1</span>) 												<span class="comment">// 假设读操作耗时1秒</span></span><br><span class="line">	rwlock.RUnlock()             					<span class="comment">// 解读锁</span></span><br><span class="line">	<span class="comment">// lock.Unlock()                			// 解互斥锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们解决了多个 goroutine 同时读写的资源竞争问题，但是又遇到另外一个问题——性能。因为每次读写共享资源都要加锁，所以性能低下，这该怎么解决呢？</p>
<p>现在我们分析读写这个特殊场景，有以下几种情况：</p>
<ol>
<li>写的时候不能同时读，因为这个时候读取的话可能读到脏数据（不正确的数据）；</li>
<li>读的时候不能同时写，因为也可能产生不可预料的结果；</li>
<li>读的时候可以同时读，因为数据不会改变，所以不管多少个 goroutine 读都是并发安全的。</li>
</ol>
<p>所以就可以通过读写锁 sync.RWMutex 来优化这段代码，提升性能。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>在实际的工作中，你可能会有这样的需求：让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<p>针对这种情形，Go 语言为我们提供了 sync.Once 来保证代码只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 如果要执行的函数f需要传递参数就需要搭配闭包来使用。</span></span><br></pre></td></tr></table></figure>
<p>这是 Go 语言自带的一个示例，虽然启动了 10 个<code>goroutine</code>来执行 onceBody 函数，但是因为用了 once.Do 方法，所以函数 onceBody 只会被执行一次。也就是说在高并发的情况下，sync.Once 也会保证 onceBody 函数只执行一次。</p>
<p>sync.Once 适用于创建某个对象的单例、只加载一次的资源等只执行一次的场景。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; example</span><br><span class="line">func main() &#123;</span><br><span class="line">   doOnce()</span><br><span class="line">&#125;</span><br><span class="line">func doOnce() &#123;</span><br><span class="line">   var once sync.Once</span><br><span class="line">   onceBody :&#x3D; func() &#123;</span><br><span class="line">      fmt.Println(&quot;Only once&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;用于等待&#96;goroutine&#96;执行完毕</span><br><span class="line">   done :&#x3D; make(chan bool)</span><br><span class="line">   &#x2F;&#x2F;启动10个协程执行once.Do(onceBody)</span><br><span class="line">   for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">      go func() &#123;</span><br><span class="line">         &#x2F;&#x2F;把要执行的函数(方法)作为参数传给once.Do方法即可</span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- true</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">      &lt;-done</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; make(map[string]int)</span><br><span class="line"></span><br><span class="line">func get(key string) int &#123;</span><br><span class="line">	return m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func set(key string, value int) &#123;</span><br><span class="line">	m[key] &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	wg :&#x3D; sync.WaitGroup&#123;&#125;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(n int) &#123;</span><br><span class="line">			key :&#x3D; strconv.Itoa(n)</span><br><span class="line">			set(key, n)</span><br><span class="line">			fmt.Printf(&quot;k&#x3D;:%v,v:&#x3D;%v\n&quot;, key, get(key))</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报错误。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbtrqdjtaj31ak0u0gng.jpg" alt=""></p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<p>一个简单的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n)</span><br><span class="line">			value, _ := m.Load(key)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h4 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">func LoadInt32(addr <em>int32) (val int32) func LoadInt64(addr </em>int64) (val int64) func LoadUint32(addr <em>uint32) (val uint32) func LoadUint64(addr </em>uint64) (val uint64) func LoadUintptr(addr <em>uintptr) (val uintptr) func LoadPointer(addr </em>unsafe.Pointer) (val unsafe.Pointer)</td>
<td style="text-align:center">读取操作</td>
</tr>
<tr>
<td style="text-align:center">func StoreInt32(addr <em>int32, val int32) func StoreInt64(addr </em>int64, val int64) func StoreUint32(addr <em>uint32, val uint32) func StoreUint64(addr </em>uint64, val uint64) func StoreUintptr(addr <em>uintptr, val uintptr) func StorePointer(addr </em>unsafe.Pointer, val unsafe.Pointer)</td>
<td style="text-align:center">写入操作</td>
</tr>
<tr>
<td style="text-align:center">func AddInt32(addr <em>int32, delta int32) (new int32) func AddInt64(addr </em>int64, delta int64) (new int64) func AddUint32(addr <em>uint32, delta uint32) (new uint32) func AddUint64(addr </em>uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>
<td style="text-align:center">修改操作</td>
</tr>
<tr>
<td style="text-align:center">func SwapInt32(addr <em>int32, new int32) (old int32) func SwapInt64(addr </em>int64, new int64) (old int64) func SwapUint32(addr <em>uint32, new uint32) (old uint32) func SwapUint64(addr </em>uint64, new uint64) (old uint64) func SwapUintptr(addr <em>uintptr, new uintptr) (old uintptr) func SwapPointer(addr </em>unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td style="text-align:center">交换操作</td>
</tr>
<tr>
<td style="text-align:center">func CompareAndSwapInt32(addr <em>int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr </em>int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <em>uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr </em>uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <em>uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr </em>unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>
<td style="text-align:center">比较并交换操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Inc()</span><br><span class="line">	Load() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	counter <span class="keyword">int64</span></span><br><span class="line">	lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.Inc()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">	test(c1)</span><br><span class="line">	c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">	test(&amp;c2)</span><br><span class="line">	c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">	test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><blockquote>
<p>Cond实现了一个条件变量，它是goroutines等待或宣布事件发生的集合点。每个Cond都有一个关联的Locker L（通常是Mutex或RWMutex），在更改条件和调用Wait方法时必须将其保留。第一次使用后，不得复制条件</p>
</blockquote>
<p>在 Go 语言中，sync.WaitGroup 用于最终完成的场景，关键点在于一定要等待所有<code>goroutine</code>都执行完毕。</p>
<p>而 sync.Cond 可以用于发号施令，一声令下所有<code>goroutine</code>都可以开始执行，关键点在于<code>goroutine</code>开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<p>sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。</p>
<p>sync.Cond 有三个方法，它们分别是：</p>
<ol>
<li><strong>Wait</strong>，Wait原子地解锁c.L并中止调用goroutine的执行。稍后恢复执行后，等待锁定c.L才返回。与其他系统不同，等待不会返回，除非被广播或信号唤醒。</li>
<li><strong>Signal</strong>，信号唤醒一个等待在c的goroutin</li>
<li><strong>Broadcast</strong>，唤醒所有等待c的goroutine</li>
</ol>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;10个人赛跑，1个裁判发号施令</span><br><span class="line">func race() &#123;</span><br><span class="line">	cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	wg.Add(11)</span><br><span class="line">	for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(num int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			fmt.Println(num, &quot;号已经就位&quot;)</span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			cond.Wait() &#x2F;&#x2F;等待发令枪响</span><br><span class="line">			fmt.Println(num, &quot;号开始跑……&quot;)</span><br><span class="line">			cond.L.Unlock()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;等待所有goroutine都进入wait状态</span><br><span class="line">	time.Sleep(2 * time.Second)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer wg.Done()</span><br><span class="line">		fmt.Println(&quot;裁判已经就位，准备发令枪&quot;)</span><br><span class="line">		fmt.Println(&quot;比赛开始，大家准备跑&quot;)</span><br><span class="line">		cond.Broadcast() &#x2F;&#x2F;发令枪响</span><br><span class="line">	&#125;()</span><br><span class="line">	&#x2F;&#x2F;防止函数提前返回退出</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节我们巴拉巴拉搞了很多，到底什么情况用哪个。相信你也可能和我一样半懵半醒，那么我们来总结一下。他们的使用场景,啥是啥？</p>
<p>需知：<strong>goroutine与线程</strong></p>
<ul>
<li>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可增长的栈</span><br><span class="line">OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</span><br><span class="line"></span><br><span class="line">goroutine调度</span><br><span class="line">GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</span><br><span class="line"></span><br><span class="line">G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</span><br><span class="line">P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</span><br><span class="line">M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</span><br><span class="line">P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</span><br><span class="line"></span><br><span class="line">P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong></p>
<ul>
<li>Channel:关于数据流动、传递等情况的优先使用<code>channle</code>， 它是并发安全的，且性能优异, channel底层的实现为互斥锁</li>
<li><p>sync.Once：让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
</li>
<li><p>Sync.WaitGroup:用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。有了它我们再也不用为了等待协程执行完成而添加<code>time.sleep</code>了</p>
</li>
<li>Sync.Mutew: 当资源发现竞争时，我们可以使用<code>Sync.Mutew</code>，加互斥锁保证并发安全</li>
<li>Sync.RWMutew: <code>Sync.Mutew</code>进阶使用，当读多写少的时候，可以使用读写锁来保证并发安全，同时也提高了并发效率</li>
<li>sync.Map:高并发的情况下，原始的map并不安全，使用sync.Map可用让我们的map在并发情况下也保证安全</li>
<li>sync.Cond:sync.Cond 可以用于发号施令，一声令下所有<code>goroutine</code>都可以开始执行，关键点在于<code>goroutine</code>开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</li>
</ul>
<p>说了这么多，这么多花里胡哨的，注意一点，Sync.Mutew，互斥锁，所有的锁的爸爸，原子操作。互斥锁的叔叔。</p>
<p>感谢您的阅读，如果感觉不错。也可以点赞、收藏、在读、当然推荐给身边的哥们也是不错的选择，同时欢迎关注我。一起从0到1</p>
<p>期待下一章节，铁索连环-context</p>
<p>以及下下章节：并发模式</p>
<p>我会在<code>并发模式</code>中与你探讨：</p>
<p><code>channle</code>缓存区多大比较合适,</p>
<p>Goroutine Work Pool，减少<code>Goroutine</code>过多重复的创建与销毁</p>
<p>Pipeline 模式：流水线工作模式，对任务中的部分进行剖析</p>
<p>扇出和扇入模式：对流水线工作模式进行优化，实现更高效的<code>扇出和扇入模式</code></p>
<p>Futures 模式:未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取</p>
<p>同时再一次去搞一下，到底什么是可异步、并发的代码，并加以分析与优化</p>
<p>未来已来。Let‘s Go～</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈生活中那些与学习的事儿</title>
    <url>/2021/01/01/%E8%B0%88%E8%B0%88%E7%94%9F%E6%B4%BB%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>前几天有个公众号的小伙伴找到我，问到我<code>大佬大佬，你是怎么学习的啊</code>，我的回答是<code>老大哥，俺也不知道啊。应该是先这样在这样然后在这样</code>(男性同胞啊)。那到底那样啊？说实话我真不知道，我还真的不晓得什么样的学习方法、为人处事，等等是正确的。如果你问我“有没有一招KO所有”，那我只能回答你“想啥呢？如果真的有为什么只能你会，对不对？”。有时候选择比努力更加重要，方法比努力重要。没有方向所有的风都是逆风，一个个的大佬叫着，说真的很多时候我比谁都尴尬，如履薄冰。害怕你问的问题，我也不会。毕竟俺也是挺平凡的一个靓仔(“呸，丑东西～”)<br><a id="more"></a><br>偏了偏了，咱们回到正题上其实说到学习方法、高效率有什么非常非常好的方法，说真的似乎还真的有。不过我想将我现目前所认知的所有告诉你，</p>
<p>说到这些我按照我目前所认知的归纳为三大部分，<code>高效率</code>、<code>时间管理</code>、<code>学习方法</code>、<code>如何分析</code>，来吧来吧，看看我到底想对你说些什么呢？</p>
<h2 id="谈谈高效率"><a href="#谈谈高效率" class="headerlink" title="谈谈高效率"></a>谈谈高效率</h2><blockquote>
<p>你所浪费的今天，是昨天死去的人奢望的明天。</p>
<p>你所厌恶的现在，正是未来的你回不去的曾经。</p>
</blockquote>
<p>时间总是公平的，你我的一天都只有24hour，一分不多一秒不少，如何合理的利用，高效的利用。高额的产出就成了我们都想突破思考的问题。那位独秀同学请先坐下，哥的容貌就比你帅一点点。这个是认真的，嘻嘻～。</p>
<p>首先我们来看这样的一个物理公式，效率 = 输入功除以输出功，也就是投入与产出的比值。理论上讲一分耕耘一分收获。但实际上却并不一定是这样。阻挡我们“高产”的东西有很多，例如生活中的各种琐事、各种朋友圈、短视频、等等等等都耗费着那宝贵的时间</p>
<h4 id="全身心投入是高效率的开始"><a href="#全身心投入是高效率的开始" class="headerlink" title="全身心投入是高效率的开始"></a>全身心投入是高效率的开始</h4><p>说到全身心的投入，那自然离不开控制自己了。正因为生活中的琐事等等真的非常的多，以至于我们无法较为投入。我分享我几个感觉不错的建议</p>
<ul>
<li>放下手机</li>
<li>安静的环境</li>
<li>适宜的氛围</li>
</ul>
<p>放下手机，很好理解。手机静音，把手机放在不太容易看的见的地方，从而抑制看手机、玩手机的想法。将思维定在此时此刻想做的事上。朋友圈上隔壁王阿姨家的猫又生了几个崽，等下又去吃什么好吃的。微信上又有个小姐姐好漂亮，好可爱，怎么办，怎么办好喜欢，怎么办。关你什么事儿？做到雨女无瓜。对吧，有这样的感觉就nice。</p>
<p>选择、制造安静的环境，很多朋友啊真的是稍微有点动静就心猿意马，然后一大堆的想法就出来了。然后就似脱缰野马，未有归途。然后就没有然后了呗。脑子一想，这几分钟就过去了，眼睛一睁一闭着一天就过去了，眼睛一睁不闭这辈子就过去了。不知道你们是不是这样的，我就是了。所以控制不住自己受环境所影响的，那就选择，或者制造相对应的环境。让自己能够全身心投入那伟大神圣的事业</p>
<h3 id="人脑规律是高效率的进阶"><a href="#人脑规律是高效率的进阶" class="headerlink" title="人脑规律是高效率的进阶"></a>人脑规律是高效率的进阶</h3><p>说到这个真的是玄之又玄的东西，早晨记忆力更好，下午思维逻辑更清晰。不知道你们是什么样的情况。我的脑子基本是符合这个神圣的定律。就比如我早晨的时候会看一些，技术文档、大佬的公众号、等等这些。效果真的非常不错。下午的话我会去攻克难题，无论上是项目上的，还是等等。如果在这“最清醒”的状态都搞不出来，那么平时也别想。当然每个人都情况会有所不同，具体视情况而定</p>
<h3 id="手脚并用是高效率的高阶"><a href="#手脚并用是高效率的高阶" class="headerlink" title="手脚并用是高效率的高阶"></a>手脚并用是高效率的高阶</h3><p>这个其实说’五到’会更加适合，而并不是仅仅是手脚并用。你以为跑步呢。腿撒开跑，手撒开摇。这个并不是这样的。借用鲁迅先生的思想“五到”，眼到，口到，心到，手到，脑到。其实最重要的还是人到（手动狗头～）</p>
<p>眼到：集中在目标，不可看别处。</p>
<p>口到：认真读书，有感情。</p>
<p>心到：最重要便是心，用心去看去学，不可三心二意。</p>
<p>手到：做做批注，实际操作一下，在有感受后旁边写上自己的体会。</p>
<p>脑到：提出不懂的问题，善于思考,追根求源。</p>
<h2 id="谈谈学习方法"><a href="#谈谈学习方法" class="headerlink" title="谈谈学习方法"></a>谈谈学习方法</h2><p>说到非常可行的学习方法，其实真的很简单。相信大家也都听说过无数次了。<code>预习</code>，<code>学习</code>，<code>复习</code>。是不是so easy？哇唔，大道至简，我会了。</p>
<blockquote>
<p>屌丝逆袭，赢取白富美，出任CEO，走向人生巅峰的小手在向我召唤。我等下一不小心就成功了怎么办？</p>
<p>那我又只能告诉你，快醒醒。你以为你是万年难得一见的骨骼惊奇，头铁是吧？这才哪到哪啊，八字还没一撇呢，更别说捺了</p>
</blockquote>
<p>其实做到以上三点并不看起来的那么简单，真的是那种咫尺天涯，知易行难。</p>
<p>那么怎么样的学习方法才是较为正确，且高效率的呢？接下来让我们去了解一下“十步学习法”，真真实实的将预习、学习、复习精准落实起来。我个人感觉挺高效的，不过事先说明“十步学习法”并不是我发现、我创建的。不过我确实从中受益良多，话不多见，开干～</p>
<h3 id="十步学习法"><a href="#十步学习法" class="headerlink" title="十步学习法"></a>十步学习法</h3><p><img src="https://img-blog.csdnimg.cn/20201025051513142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6cDcwODE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>对于“十步学习法”的前六个步骤，我们需要集中精力完成足够多的前期调研，确保自己明确知道要学哪些内容，以及如何确认自己已达成目标。这六个步骤只需要针对将要学习的每个主题做一次。第 7 步到第 10 步则要针对在第 5 步所制定的学习计划中的每个模块重复。</p>
<p>虽然前六个步骤只需要做一次，但它们却是最重要的，因为它们将对我们未来的成败起决定性作用。在这六个步骤中，我们需要为自己实际的学习主题做好一切准备。</p>
<h4 id="第一步：了解全局"><a href="#第一步：了解全局" class="headerlink" title="第一步：了解全局"></a>第一步：了解全局</h4><p>我们要做的就是了解将要学习的主题的全局。这个主题宏观上是什么样的？</p>
<p>我们能够从中学到足够丰富的知识以了解自己认知以外的, 以及我们自己认知之外的有多少？</p>
<p>要完成这一步，对想要学的内容做一些基础性了解。</p>
<blockquote>
<p>关键词:广泛</p>
</blockquote>
<h4 id="第二步：确定范围"><a href="#第二步：确定范围" class="headerlink" title="第二步：确定范围"></a>第二步：确定范围</h4><p>当我们对自己所要学习的主题及其相关的知识都有了一个大致的了解后，此时需要集中精力去明确自己到底要学什么?</p>
<p>明确具体的范围是至关重要的，唯有这样才能了解项目的全局，以求做好相应的准备。</p>
<blockquote>
<p>关键词: 深度</p>
</blockquote>
<h4 id="第三步：定义目标"><a href="#第三步：定义目标" class="headerlink" title="第三步：定义目标"></a>第三步：定义目标</h4><p>在开始学习前，明确“成功”的 含义极为重要。如果不知道成功是什么，很难找准目标，也很难知道自己什么时候已经真正达到目标。在尝试学习任何东西之前，我们都应该清晰清除的明白,完成之后我能完成什么样的事情? 当知道自己的目标是什么的时候，就可以更轻松地使用倒推的方式，明确实现目标所需的步骤。</p>
<p>这一步的目标是形成一份简明清晰的陈述，勾勒出学习后的成功图景。好的成功标准应该是具体的，无二义性的. 根据一\二步制定,绘出自己<code>成功</code>将能达到的实际效果.</p>
<blockquote>
<p>关键词: 具体</p>
</blockquote>
<h4 id="第四步：寻找资源"><a href="#第四步：寻找资源" class="headerlink" title="第四步：寻找资源"></a>第四步：寻找资源</h4><p>要尝试收集到多种多样的资源以帮助我们学习，以求更加深入的了解此知识或技术</p>
<p>需要找到尽可能多的与自己所选主题相关的资源，此时可无需考虑这些资源的质量。</p>
<p>信息来源(不分先后)：</p>
<ul>
<li><p>专家</p>
</li>
<li><p>图书</p>
</li>
<li>源代码</li>
<li>示例项目</li>
<li>博客文章</li>
<li>在线视频</li>
<li>在线文档</li>
<li>… …</li>
</ul>
<blockquote>
<p>关键词: 尋找</p>
</blockquote>
<h4 id="第五步：创建学习计划"><a href="#第五步：创建学习计划" class="headerlink" title="第五步：创建学习计划"></a>第五步：创建学习计划</h4><p>此時需创建相對應学习規劃。可以把学习路径类比成写书时的<strong>大纲</strong>。</p>
<p>打造自己的学习计划，一个好办法就是观察别人是如何教我们感兴趣的主题的。可以参考在第四步中搜集到的图书目录，如果 5 位 以上的作者都把内容分解为相同的模块和顺序，那么就可以遵循这样的方法制订自己的学习计划。</p>
<blockquote>
<p>关键词: 大綱</p>
</blockquote>
<h4 id="第六步：筛选资源"><a href="#第六步：筛选资源" class="headerlink" title="第六步：筛选资源"></a>第六步：筛选资源</h4><p>此時已经知道了要学什么及以什么顺序学，</p>
<p>將第四步中收集的全部资源瀏覽\篩選，找出哪些内容能够覆盖我们的学习计划，还应当看看评论，试着找出品质最高的资源。</p>
<blockquote>
<p>关键词: 篩選</p>
</blockquote>
<h4 id="第七步：开始学习，浅尝辄止"><a href="#第七步：开始学习，浅尝辄止" class="headerlink" title="第七步：开始学习，浅尝辄止"></a>第七步：开始学习，浅尝辄止</h4><p>大多数情況下在过程中会犯两类相對错误：</p>
<ul>
<li>第一类错误是在知之不多的情况下就盲目开始，即行动太快；</li>
<li>第二类错误是在行动之前准备太多，即行动太晚。</li>
</ul>
<p>要想在这两者之间取得平衡，我们掌握的知识要恰到好处，足以能够开始学习，但又不会多到让人无力探索，这样的学习效果是最佳的。</p>
<p>目标為获得足够多与所学主题相关的信息，从而能让我们可以开始学习，并在下一步中动手操作。</p>
<blockquote>
<p>关键词: 節奏</p>
</blockquote>
<h4 id="第八步：动手操作，边玩边学"><a href="#第八步：动手操作，边玩边学" class="headerlink" title="第八步：动手操作，边玩边学"></a>第八步：动手操作，边玩边学</h4><p>这一步中我们无需提前了解全部内容，要做的首要的一件事就是亲自操作和亲身体验。采用这种方法，可以通过探索和实践进行学习。</p>
<p>在操作过程中，我们的大脑自然地会产生各种问题：</p>
<ul>
<li><p>它是如何工作的？</p>
</li>
<li><p>如果我这么做，可能会发生什么？</p>
</li>
<li><p>我该如何解决这个问题？</p>
</li>
</ul>
<p>这些问题能够引导我们走向真正重要的方向。当我们回过头寻找问题的答案时，不只是这些问题迎刃而解，而且我们记得的东西要比学习的东西多很多.</p>
<blockquote>
<p>关键词: 思考</p>
</blockquote>
<h4 id="第九步：全面掌握，学以致用"><a href="#第九步：全面掌握，学以致用" class="headerlink" title="第九步：全面掌握，学以致用"></a>第九步：全面掌握，学以致用</h4><p>好奇心是学习特别是自学的重要组成部分。</p>
<p>这一步的目标就是让我们找回好奇心驱动的学习。在这一步，我们依然没有必要把收集到的所有资料都仔细地看一遍。只需要阅读或观看与当前所学相关的知识。最后，试着把自己正在学习的内容与最终目标关联起来。我们掌握的每个模块，都应该以某种方式推动你向着终极目标前进。</p>
<blockquote>
<p>關鍵詞:全面</p>
</blockquote>
<h4 id="第十步：乐为人师，融会贯通"><a href="#第十步：乐为人师，融会贯通" class="headerlink" title="第十步：乐为人师，融会贯通"></a>第十步：乐为人师，融会贯通</h4><p>三人行,必有我師</p>
<p>走出自己的舒适区，将所学到的教给别人,爭取教會。要想确定你确实掌握了某些知识，这是唯一的办法；同时，在将自己所学介绍给他人时，这也是查缺补漏的好办法。</p>
<blockquote>
<p>關鍵詞: 學教</p>
</blockquote>
<h2 id="谈谈描述问题与解决问题"><a href="#谈谈描述问题与解决问题" class="headerlink" title="谈谈描述问题与解决问题"></a>谈谈描述问题与解决问题</h2><p>其实描述问题我这个“八何分析法”是个非常不错的思路结构，如果你能够清晰的描述你的问题，无论是对于自己还是需要得到有效的帮助去解决问题都会事半功倍</p>
<h3 id="描述问题-八何分析法"><a href="#描述问题-八何分析法" class="headerlink" title="描述问题(八何分析法)"></a>描述问题(八何分析法)</h3><p>What，Where，When，Who，Why，How，How much，How feel</p>
<ul>
<li><p>Why：为何——为什么要做？为什么要如此做（有没有更好的办法）？（做这项工作的原因或理由）</p>
</li>
<li><p>What：何事——什么事？做什么？准备什么？（即明确工作的内容和要达成的目标）</p>
</li>
<li><p>Where：何处——在何处着手进行最好？在哪里做？（工作发生的地点）？</p>
</li>
<li><p>When：何时——什么时候开始？什么时候完成？ 什么时候检查？（时间）</p>
</li>
<li><p>Who：何人——谁去做？ （由谁来承担、执行？）谁负责？谁来完成？（参加人、负责人）？</p>
</li>
<li><p>How：如何——如何做？如何提高效率？如何实施？方法怎样？（用什么方法进行）？</p>
</li>
<li><p>How much：何价——成本如何？达到怎样的效果（做到什么程度）？ 数量如果？质量水平如何？费用产出如何？</p>
</li>
<li><p>How feel：感觉—体验如何？开发者、使用者、领导最终的体验是否满意？</p>
</li>
</ul>
<p>概括：即为什么？是什么？何处？何时？由谁做？怎样做？成本多少？结果会怎样？也就是：要明确工作/任务的原因、内容、空间位置、时间、执行对象、方法、成本。加上工作结果（how do you feel）：工作结果预测，就成为5W3H。</p>
<p>这样可能会更加符合人脑记忆，时间(when)、地点（where）、人物（who）、what、why，How，How much，How feel</p>
<h3 id="问题分割及解决之道"><a href="#问题分割及解决之道" class="headerlink" title="问题分割及解决之道"></a>问题分割及解决之道</h3><p>在能够清晰的描述问题之后，相信你对于问题出现的地方就有个大概的定位，那么接下来就是分割问题。剖析大问题成一个个小问题，解决一个个最后这个问题就能能够轻松的被解决。同时找到最佳解决方案。</p>
<p>比如我需要做个简单的学生管理系统，那么我们就可以分解出这样几个小问题。</p>
<ol>
<li>学生信息</li>
<li>管理账号</li>
<li>菜单栏目</li>
<li>实现功能<ol>
<li>查看</li>
<li>添加</li>
<li>修改</li>
<li>删除</li>
<li>退出</li>
</ol>
</li>
</ol>
<p>这样是不是比完成学生管理系统好实现的多。那么我们只需要一个个实现以上几个功能就可以实现一个简单的学生管理系统了。so easy。当然这样还不足以上线，只能在本地跑一跑，玩一玩。那么如果真的做成项目的话。只需要一个个扩宽就可以了。</p>
<p>比如</p>
<p>学生信息,那么我们自然而然的想到数据库，又由于这写之间的关系。我个人是建议使用SQL数据库。后面数据量大了之后在进行分库分表，甚至SQL集群等等。这项目不就慢慢起来了么</p>
<p>菜单栏，这个就是个展示的面板嘛，抛到前端(主要是前端了)。然后在分割成什么主页啊，信息页啊。等等，这样是不是越来越大了</p>
<p>然后顺着这种思路，自然而然的从一个小的case到项目了</p>
<h2 id="谈谈如何规划"><a href="#谈谈如何规划" class="headerlink" title="谈谈如何规划"></a>谈谈如何规划</h2><p>说了那么多终于到了这里也终于到了取舍分离的阶段，一生中有很多事，大事小事。等等，那么如果做个区分，相信你我在未来的道路上会更加清晰明了。那么我们谈谈该如何规划、制定吧。</p>
<p>说到这个就不得不提一下，“四象限分析法”，如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm7j0i3g5jj30cs0cs3yf.jpg" alt=""></p>
<h3 id="界限"><a href="#界限" class="headerlink" title="界限"></a>界限</h3><p>第一象限</p>
<p>这个象限包含的是一些紧急而重要的事情，这一类的事情具有时间的紧迫性和影响的重要性，无法回避也不能拖延，必须首先处理优先解决。它表现为重大项目的谈判，重要的会议工作等。</p>
<p>第二象限</p>
<p>第二象限包含的事件是那些紧急但不重要的事情，这些事情很紧急但并不重要，因此这一象限的事件具有很大的欺骗性。很多人认识上有误区，认为紧急的事情都显得重要，实际上，像无谓的电话、附和别人期望的事、打麻将三缺一等事件都并不重要。这些不重要的事件往往因为它紧急，就会占据人们的很多宝贵时间。</p>
<p>第三象限</p>
<p>第三象限的事件大多是些琐碎的杂事，没有时间的紧迫性，没有任何的重要性，这种事件与时间的结合纯粹是在扼杀时间，是在浪费生命。发呆、上网、闲聊、游逛，这是饱食终日无所事事的人的生活方式。</p>
<p>第四象限</p>
<p>第四象限不同于第一象限，这一象限的事件不具有时间上的紧迫性，但是，它具有重大的影响，对于个人或者企业的存在和发展以及周围环境的建立维护，都具有重大的意义。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>1.优先解决第一象限</p>
<p>首先要有准确的判断能力，确定是既紧急又重要的事情，然后优先处理。</p>
<p>2.区分一二象限</p>
<p>第一象限和第二象限难以区分，第二象限对人们的欺骗性是最大的，它很紧急的事实造成了它很重要的假象，耗费了人们大量的时间。依据紧急与否是很难区分这两个象限的，要区分它们就必须借助另一标准，看这件事是否重要。也就是按照自己的人生目标和人生规划来衡量这件事的重要性。如果它重要就属于第一象限的内容；如果它不重要，就属于第二象限的内容。</p>
<p>3.投资第四象限</p>
<p>第一象限的事情重要而且紧急，由于时间原因人们往往不能做得很好。第四象限的事情很重要，而且会有充足的时间去准备，有充足的时间去做好。可见，投资第四象限，它的回报才是最大的。</p>
<p>4.放弃第三象限</p>
<p>第三象限都是既不重要也不紧急的琐事，但它们往往使人们难以脱身，所以人们经常会跌进第三象限而无法自拔。例如，玩游戏、看娱乐视频等，只要一玩起来就很难脱身，而且要耗费很长的时间才能达成结果。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ol>
<li>马上做：如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。</li>
<li>计划做：尽可能地把时间花在重要但不紧急（第四象限）的事情上，这样才能减少第一象限的工作量。</li>
<li>授权做：对于紧急但不重要的事情的处理原则是授权，让别人去做。</li>
<li>减少做：不重要也不紧急的事情尽量少做。</li>
</ol>
<p>其实说实话，很多东西都不是自己的，自己也是做一个总结吧。希望你我在人生的道路上一路高歌猛进，加油～</p>
<p>积跬Coder敬上<br>致辞</p>
]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor-程序管理更加得心应手</title>
    <url>/2021/01/12/Supervisor-%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E6%9B%B4%E5%8A%A0%E5%BE%97%E5%BF%83%E5%BA%94%E6%89%8B/</url>
    <content><![CDATA[<h2 id="Supervisor初探篇"><a href="#Supervisor初探篇" class="headerlink" title="Supervisor初探篇"></a>Supervisor初探篇</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Supervisor是一个客户机/服务器系统(也就是非常经典的C/S结构)，它允许用户在类UNIX操作系统上<code>控制</code>许多进程。<br><a id="more"></a></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p><strong>简单便捷</strong></p>
<blockquote>
<p>通过简单易懂的配置文件配置Supervisor，即可对任务的管理与监控，它提供了重新启动失败的进程和自动日志轮换等功能。</p>
</blockquote>
</li>
<li><p><strong>集中</strong></p>
<blockquote>
<p>提供了一个开始，停止和监视的地方。可以单独或成组控制过程。配置Supervisor以提供本地或远程命令行和Web界面。</p>
</blockquote>
</li>
<li><p><strong>高效</strong></p>
<blockquote>
<p>通过fork / exec启动其子进程，并且子进程不守护。进程终止时，操作系统会立即向Supervisor发送信号</p>
</blockquote>
</li>
<li><p>可扩展</p>
<blockquote>
<p>Supervisor具有一个简单的事件通知协议，该协议可以使用任何语言编写的程序对其进行监视，并且具有用于控制的XML-RPC接口</p>
</blockquote>
</li>
<li><p>兼容强</p>
<blockquote>
<p>除Windows之外，Supervisor几乎适用于所有事物。它已在Linux，Mac OS X，Solaris和FreeBSD上经过测试和支持。它完全用Python编写</p>
</blockquote>
</li>
<li><p>久经考验</p>
<blockquote>
<p>尽管Supervisor如今非常活跃，但它不是新软件。Supervisor已经存在了很多年，并且已经在许多服务器上使用</p>
</blockquote>
</li>
</ul>
<p>听我说了这么多，相信你也和我一样迫不及待想了解它。嘿呀，不要着急。在学习使用它之前，我们对它的基础组成有个了解，以便于稍后更加得心应手的使用</p>
<h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><ul>
<li>supervisord</li>
<li>supervisorctl</li>
<li>Web Server</li>
<li>XML-RPC Interface</li>
</ul>
<p>在简介中提到<code>Supervisor是一个客户机/服务器系统(也就是非常经典的C/S结构)</code>,那么也在此介绍一下各个组件</p>
<p><strong>Supervisord:</strong> 服务端的主管被称为<strong>supervisord</strong>。它负责自行调用启动子程序，响应来自客户端的命令，重新启动崩溃或退出的子进程，记录其子进程<code>stdout</code>和<code>stderr</code> 输出以及生成和处理与子进程生存期中的点相对应的“事件”。</p>
<blockquote>
<p>服务器进程使用的配置文件位于<code>/etc/supervisord.conf中</code>，通过适当的文件系统权限确保此文件的安全(它包含未加密的用户名和密码,它可能是我们服务器的root密码)</p>
</blockquote>
<p><strong>Supervisorctl</strong>:客户端的主管被称为 <strong>supervisorctl</strong>, 它提供了类似于shell的界面,以便于我们使用命令对服务端的主管进行管理与控制。从supervisorctl我们可以连接到不同的supervisord进程（一次一个），获取受其控制的子进程的状态，停止和启动子进程，以及获取正在运行的supervisord进程的列表</p>
<blockquote>
<p>命令行客户机通过UNIX域套接字或internet（TCP）套接字与服务器通信。服务器可以断言客户端的用户应该在允许他执行命令之前提供身份验证凭据。客户机进程通常使用与服务器相同的配置文件，但是任何带有[supervisorctl]节的配置文件都可以工作。</p>
</blockquote>
<p>如果在internet套接字上启动supervisord，则可以通过浏览器访问功能类似于supervisorctl web用户界面。访问服务器URL（例如。<a href="http://ip：prot）激活配置文件的[inet">http://ip：prot）激活配置文件的[inet</a> http server]部分后，通过web界面查看和控制进程状态。</p>
<p><strong>XML-RPC接口</strong>：服务于Web UI的同一HTTP服务器提供XML-RPC接口，该接口可用于询问和控制管理程序及其运行的程序。<a href="http://supervisord.org/api.html#xml-rpc"><em>XML-RPC API文档</em></a>。</p>
<hr>
<h2 id="Supervisor使用技巧篇"><a href="#Supervisor使用技巧篇" class="headerlink" title="Supervisor使用技巧篇"></a>Supervisor使用技巧篇</h2><h3 id="Supervisor的安装"><a href="#Supervisor的安装" class="headerlink" title="Supervisor的安装"></a>Supervisor的安装</h3><p>supervisor支持了大多包管理工具进行安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip(推荐)</span></span><br><span class="line">pip install supervisor</span><br><span class="line"><span class="comment"># mac </span></span><br><span class="line">brew install supervisor</span><br><span class="line"><span class="comment"># ubantu</span></span><br><span class="line">apt install supervisor</span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure>
<h3 id="Supervisor的使用"><a href="#Supervisor的使用" class="headerlink" title="Supervisor的使用"></a>Supervisor的使用</h3><p>这里我们建立一个测试用的py文件，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		logger.info(i)</span><br><span class="line">		randomTime = uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		logger.info(<span class="string">f&#x27;Sleep <span class="subst">&#123;randomTime&#125;</span>s&#x27;</span>)</span><br><span class="line">		time.sleep(randomTime)</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">			sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时可以正常运行</p>
<blockquote>
<p>温馨提示：这样的死循环记得一定要给休眠或者退出条件，要不将会有快乐的事情发生哦</p>
</blockquote>
<p>运行如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml27kbhxdj30z20u0tbj.jpg" alt=""></p>
<p><strong>对接Supervisor</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supervisord.conf</span></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span>								 ;守护进程，默认fales</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=debug               ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[program:demo]</span><br><span class="line">process_name=tester</span><br><span class="line"><span class="built_in">command</span>=python3 demo.py</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br></pre></td></tr></table></figure>
<p>使用<code>supervisord -c supervisord.conf</code>，运行程序。</p>
<p>输出日志入下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-01-12 17:57:21,705 INFO supervisord started with pid 1257</span><br><span class="line">2021-01-12 17:57:22,712 INFO spawned: &#39;tester&#39; with pid 1260</span><br><span class="line">2021-01-12 17:57:22,856 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:22.855 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:22.856 | INFO     | __main__:test:12 - Sleep 0.681474110840254s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,542 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.541 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,542 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.541 | INFO     | __main__:test:12 - Sleep 0.34284895238537105s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,887 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.886 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,887 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.887 | INFO     | __main__:test:12 - Sleep 0.08220508414530214s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,970 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.969 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,971 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:23.970 | INFO     | __main__:test:12 - Sleep 0.39740491822333646s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:24,372 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:24.371 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:24,372 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:24.371 | INFO     | __main__:test:12 - Sleep 0.9054854146830564s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,280 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.279 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,281 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.280 | INFO     | __main__:test:12 - Sleep 0.4563320839294708s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,742 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.741 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,742 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.741 | INFO     | __main__:test:12 - Sleep 0.19482948337371853s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,939 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.938 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,940 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:25.939 | INFO     | __main__:test:12 - Sleep 0.7755167696398192s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,719 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:26.718 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,719 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:26.718 | INFO     | __main__:test:12 - Sleep 0.24748008436152524s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,972 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:26.971 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,973 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:26.972 | INFO     | __main__:test:12 - Sleep 0.6178291278890581s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:27,607 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690064 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:27,607 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266190928 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:27,608 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:27,608 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:28,613 INFO spawned: &#39;tester&#39; with pid 1263</span><br><span class="line">2021-01-12 17:57:28,720 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:28.719 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:28.720 | INFO     | __main__:test:12 - Sleep 0.8226218737496696s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:29,543 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:29.542 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:29,544 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:29.543 | INFO     | __main__:test:12 - Sleep 0.6507710747677439s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,195 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:30.195 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,196 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:30.195 | INFO     | __main__:test:12 - Sleep 0.3645783421505362s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,565 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:30.564 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,565 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:30.565 | INFO     | __main__:test:12 - Sleep 0.47083797385643844s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,037 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:31.036 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,037 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:31.037 | INFO     | __main__:test:12 - Sleep 0.4875197581833751s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,531 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:31.530 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,531 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:31.530 | INFO     | __main__:test:12 - Sleep 0.9094546698090918s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,444 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:32.443 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,445 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:32.444 | INFO     | __main__:test:12 - Sleep 0.47064821128443857s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,921 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:32.920 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,922 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:32.921 | INFO     | __main__:test:12 - Sleep 0.7673175029063347s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:33,691 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:33.690 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:33,692 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:33.691 | INFO     | __main__:test:12 - Sleep 0.9317641783846109s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,625 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:34.624 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,625 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:34.625 | INFO     | __main__:test:12 - Sleep 0.2558276039626808s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,899 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690000 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:34,899 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:34,899 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:34,900 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:36,912 INFO spawned: &#39;tester&#39; with pid 1264</span><br><span class="line">2021-01-12 17:57:37,022 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:37.021 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:37.021 | INFO     | __main__:test:12 - Sleep 0.5475564566091946s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:37,572 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:37.571 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:37,573 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:37.572 | INFO     | __main__:test:12 - Sleep 0.6326087978849619s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,207 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:38.206 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,207 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:38.207 | INFO     | __main__:test:12 - Sleep 0.3225720045649825s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,531 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:38.530 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,531 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:38.530 | INFO     | __main__:test:12 - Sleep 0.5121026075892807s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,044 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:39.043 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,045 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:39.044 | INFO     | __main__:test:12 - Sleep 0.6613469797067474s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,710 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:39.709 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,710 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:39.709 | INFO     | __main__:test:12 - Sleep 0.5058071583137449s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,220 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:40.219 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,220 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:40.219 | INFO     | __main__:test:12 - Sleep 0.2779679640725812s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,502 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:40.502 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,503 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:40.502 | INFO     | __main__:test:12 - Sleep 0.7282026322383534s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,231 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:41.231 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,232 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:41.231 | INFO     | __main__:test:12 - Sleep 0.37634579152866654s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,610 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:41.610 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,610 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:41.610 | INFO     | __main__:test:12 - Sleep 0.02539488384007338s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,660 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690256 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:41,660 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:41,660 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:41,660 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:44,666 INFO spawned: &#39;tester&#39; with pid 1265</span><br><span class="line">2021-01-12 17:57:44,775 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:44.774 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:44.774 | INFO     | __main__:test:12 - Sleep 0.540035521075991s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,315 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:45.315 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,316 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:45.315 | INFO     | __main__:test:12 - Sleep 0.6011099895313317s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,922 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:45.921 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,923 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:45.922 | INFO     | __main__:test:12 - Sleep 0.5954410741418728s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,521 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.520 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,521 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.521 | INFO     | __main__:test:12 - Sleep 0.10471143983800468s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,631 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.630 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,632 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.631 | INFO     | __main__:test:12 - Sleep 0.12704017263351186s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,759 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.758 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,760 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:46.759 | INFO     | __main__:test:12 - Sleep 0.26222866859817395s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,025 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:47.025 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,026 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:47.025 | INFO     | __main__:test:12 - Sleep 0.31215837276333647s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,343 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:47.343 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,344 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:47.343 | INFO     | __main__:test:12 - Sleep 0.8863919731268238s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,230 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:48.230 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,230 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:48.230 | INFO     | __main__:test:12 - Sleep 0.6220607701794121s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,858 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:48.857 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,858 DEBG &#39;tester&#39; stderr output:</span><br><span class="line">2021-01-12 17:57:48.858 | INFO     | __main__:test:12 - Sleep 0.9545468958914863s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:49,835 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690128 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:49,835 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:49,835 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:49,835 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:50,836 INFO gave up: tester entered FATAL state, too many start retries too quickly</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml2i44gvnj327y0icwg0.jpg" alt=""></p>
<h2 id="Supervisor番外篇"><a href="#Supervisor番外篇" class="headerlink" title="Supervisor番外篇"></a>Supervisor番外篇</h2><h3 id="Supervisorctl常用命令"><a href="#Supervisorctl常用命令" class="headerlink" title="Supervisorctl常用命令"></a><strong>Supervisorctl常用命令</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supervisorctl status：查看进程的状态</span></span><br><span class="line">supervisorctl status</span><br><span class="line">status &lt;name&gt;           Get status <span class="keyword">for</span> a single process</span><br><span class="line">status &lt;gname&gt;:*        Get status <span class="keyword">for</span> all processes <span class="keyword">in</span> a group</span><br><span class="line">status &lt;name&gt; &lt;name&gt;    Get status <span class="keyword">for</span> multiple named processes</span><br><span class="line">status                  Get all process status info</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl start 启动进程</span></span><br><span class="line">start &lt;name&gt;            Start a process</span><br><span class="line">start &lt;gname&gt;:*         Start all processes <span class="keyword">in</span> a group</span><br><span class="line">start &lt;name&gt; &lt;name&gt;     Start multiple processes or groups</span><br><span class="line">start all               Start all processes</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl stop 停止进程</span></span><br><span class="line">stop &lt;name&gt;             Stop a process</span><br><span class="line">stop &lt;gname&gt;:*          Stop all processes <span class="keyword">in</span> a group</span><br><span class="line">stop &lt;name&gt; &lt;name&gt;      Stop multiple processes or groups</span><br><span class="line">stop all                Stop all processes</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl restart 重启进程</span></span><br><span class="line">restart &lt;name&gt;          Restart a process</span><br><span class="line">restart &lt;gname&gt;:*       Restart all processes <span class="keyword">in</span> a group</span><br><span class="line">restart &lt;name&gt; &lt;name&gt;   Restart multiple processes or groups</span><br><span class="line">restart all             Restart all processes</span><br><span class="line">Note: restart does not reread config files. For that, see reread and update.</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl update 配置文件修改后可以使用该命令加载新的配置</span></span><br><span class="line">update                  Reload config and add/remove as necessary, and will restart affected programs</span><br><span class="line">update all              Reload config and add/remove as necessary, and will restart affected programs</span><br><span class="line">update &lt;gname&gt; [...]    Update specific groups</span><br><span class="line"></span><br><span class="line">supervisorctl reload: 重新启动配置中的所有程序</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多命令可 supervisorctl 进入终端。输入help(?)进行查看</span></span><br></pre></td></tr></table></figure>
<h3 id="Supervisorctl-参数列表"><a href="#Supervisorctl-参数列表" class="headerlink" title="Supervisorctl 参数列表"></a>Supervisorctl 参数列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl -- control applications run by supervisord from the cmd line.</span><br><span class="line"></span><br><span class="line">Usage: &#x2F;Users&#x2F;stringle-004&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;Proxypool&#x2F;bin&#x2F;supervisorctl [options] [action [arguments]]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-c&#x2F;--configuration FILENAME -- configuration file path (searches if not given)</span><br><span class="line">-h&#x2F;--help -- print usage message and exit</span><br><span class="line">-i&#x2F;--interactive -- start an interactive shell after executing commands</span><br><span class="line">-s&#x2F;--serverurl URL -- URL on which supervisord server is listening</span><br><span class="line">     (default &quot;http:&#x2F;&#x2F;localhost:9001&quot;).</span><br><span class="line">-u&#x2F;--username USERNAME -- username to use for authentication with server</span><br><span class="line">-p&#x2F;--password PASSWORD -- password to use for authentication with server</span><br><span class="line">-r&#x2F;--history-file -- keep a readline history (if readline is available)</span><br><span class="line"></span><br><span class="line">action [arguments] -- see below</span><br><span class="line"></span><br><span class="line">Actions are commands like &quot;tail&quot; or &quot;stop&quot;.  If -i is specified or no action is</span><br><span class="line">specified on the command line, a &quot;shell&quot; interpreting actions typed</span><br><span class="line">interactively is started.  Use the action &quot;help&quot; to find out about available</span><br><span class="line">actions.</span><br></pre></td></tr></table></figure>
<h3 id="supervisord-conf配置文件示例"><a href="#supervisord-conf配置文件示例" class="headerlink" title="supervisord.conf配置文件示例"></a>supervisord.conf配置文件示例</h3><p>使命令用<code>sudo echo_supervisord_conf &gt; supervisord.conf</code> 进行创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">; Sample supervisor config file.</span><br><span class="line">;</span><br><span class="line">; For more information on the config file, please see:</span><br><span class="line">; http://supervisord.org/configuration.html</span><br><span class="line">;</span><br><span class="line">; Notes:</span><br><span class="line">;  - Shell expansion (<span class="string">&quot;~&quot;</span> or <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span>) is not supported.  Environment</span><br><span class="line">;    variables can be expanded using this syntax: <span class="string">&quot;%(ENV_HOME)s&quot;</span>.</span><br><span class="line">;  - Quotes around values are not supported, except <span class="keyword">in</span> the <span class="keyword">case</span> of</span><br><span class="line">;    the environment= options as shown below.</span><br><span class="line">;  - Comments must have a leading space: <span class="string">&quot;a=b ;comment&quot;</span> not <span class="string">&quot;a=b;comment&quot;</span>.</span><br><span class="line">;  - Command will be truncated <span class="keyword">if</span> it looks like a config file comment, e.g.</span><br><span class="line">;    <span class="string">&quot;command=bash -c &#x27;foo ; bar&#x27;&quot;</span> will truncate to <span class="string">&quot;command=bash -c &#x27;foo &quot;</span>.</span><br><span class="line">;</span><br><span class="line">; Warning:</span><br><span class="line">;  Paths throughout this example file use /tmp because it is available on most</span><br><span class="line">;  systems.  You will likely need to change these to locations more appropriate</span><br><span class="line">;  <span class="keyword">for</span> your system.  Some systems periodically delete older files <span class="keyword">in</span> /tmp.</span><br><span class="line">;  Notably, <span class="keyword">if</span> the socket file defined <span class="keyword">in</span> the [unix_http_server] section below</span><br><span class="line">;  is deleted, supervisorctl will be unable to connect to supervisord.</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; the path to the socket file</span><br><span class="line">;chmod=0700                 ; socket file mode (default 0700)</span><br><span class="line">;chown=nobody:nogroup       ; socket file uid:gid owner</span><br><span class="line">;username=user              ; default is no username (open server)</span><br><span class="line">;password=123               ; default is no password (open server)</span><br><span class="line"></span><br><span class="line">; Security Warning:</span><br><span class="line">;  The inet HTTP server is not enabled by default.  The inet HTTP server is</span><br><span class="line">;  enabled by uncommenting the [inet_http_server] section below.  The inet</span><br><span class="line">;  HTTP server is intended <span class="keyword">for</span> use within a trusted environment only.  It</span><br><span class="line">;  should only be bound to localhost or only accessible from within an</span><br><span class="line">;  isolated, trusted network.  The inet HTTP server does not support any</span><br><span class="line">;  form of encryption.  The inet HTTP server does not use authentication</span><br><span class="line">;  by default (see the username= and password= options to add authentication).</span><br><span class="line">;  Never expose the inet HTTP server to the public internet.</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">;port=9001        ; ip_address:port specifier, *:port <span class="keyword">for</span> all iface</span><br><span class="line">;username=user              ; default is no username (open server)</span><br><span class="line">;password=123               ; default is no password (open server)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; main <span class="built_in">log</span> file; default <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ; max main logfile bytes b4 rotation; default 50MB</span><br><span class="line">logfile_backups=10           ; of main logfile backups; 0 means none, default 10</span><br><span class="line">loglevel=info                ; <span class="built_in">log</span> level; default info; others: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid</span><br><span class="line">nodaemon=<span class="literal">false</span>               ; start <span class="keyword">in</span> foreground <span class="keyword">if</span> <span class="literal">true</span>; default <span class="literal">false</span></span><br><span class="line">minfds=1024                  ; min. avail startup file descriptors; default 1024</span><br><span class="line">minprocs=200                 ; min. avail process descriptors;default 200</span><br><span class="line">;<span class="built_in">umask</span>=022                   ; process file creation <span class="built_in">umask</span>; default 022</span><br><span class="line">;user=supervisord            ; setuid to this UNIX account at startup; recommended <span class="keyword">if</span> root</span><br><span class="line">;identifier=supervisor       ; supervisord identifier, default is <span class="string">&#x27;supervisor&#x27;</span></span><br><span class="line">;directory=/tmp              ; default is not to <span class="built_in">cd</span> during start</span><br><span class="line">;nocleanup=<span class="literal">true</span>              ; don<span class="string">&#x27;t clean up tempfiles at start; default false</span></span><br><span class="line"><span class="string">;childlogdir=/tmp            ; &#x27;</span>AUTO<span class="string">&#x27; child log dir, default $TEMP</span></span><br><span class="line"><span class="string">;environment=KEY=&quot;value&quot;     ; key value pairs to add to environment</span></span><br><span class="line"><span class="string">;strip_ansi=false            ; strip ansi escape codes in logs; def. false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The rpcinterface:supervisor section must remain in the config file for</span></span><br><span class="line"><span class="string">; RPC (supervisorctl/web interface) to work.  Additional interfaces may be</span></span><br><span class="line"><span class="string">; added by defining them in separate [rpcinterface:x] sections.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[rpcinterface:supervisor]</span></span><br><span class="line"><span class="string">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The supervisorctl section configures how supervisorctl will connect to</span></span><br><span class="line"><span class="string">; supervisord.  configure it match the settings in either the unix_http_server</span></span><br><span class="line"><span class="string">; or inet_http_server section.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[supervisorctl]</span></span><br><span class="line"><span class="string">serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket</span></span><br><span class="line"><span class="string">;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket</span></span><br><span class="line"><span class="string">;username=chris              ; should be same as in [*_http_server] if set</span></span><br><span class="line"><span class="string">;password=123                ; should be same as in [*_http_server] if set</span></span><br><span class="line"><span class="string">;prompt=mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;)</span></span><br><span class="line"><span class="string">;history_file=~/.sc_history  ; use readline history if available</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The sample program section below shows all possible program subsection values.</span></span><br><span class="line"><span class="string">; Create one or more &#x27;</span>real<span class="string">&#x27; program: sections to be able to control them under</span></span><br><span class="line"><span class="string">; supervisor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;[program:theprogramname]</span></span><br><span class="line"><span class="string">;command=/bin/cat              ; the program (relative uses PATH, can take args)</span></span><br><span class="line"><span class="string">;process_name=%(program_name)s ; process_name expr (default %(program_name)s)</span></span><br><span class="line"><span class="string">;numprocs=1                    ; number of processes copies to start (def 1)</span></span><br><span class="line"><span class="string">;directory=/tmp                ; directory to cwd to before exec (def no cwd)</span></span><br><span class="line"><span class="string">;umask=022                     ; umask for process (default None)</span></span><br><span class="line"><span class="string">;priority=999                  ; the relative start priority (default 999)</span></span><br><span class="line"><span class="string">;autostart=true                ; start at supervisord start (default: true)</span></span><br><span class="line"><span class="string">;startsecs=1                   ; # of secs prog must stay up to be running (def. 1)</span></span><br><span class="line"><span class="string">;startretries=3                ; max # of serial start failures when starting (default 3)</span></span><br><span class="line"><span class="string">;autorestart=unexpected        ; when to restart if exited after running (def: unexpected)</span></span><br><span class="line"><span class="string">;exitcodes=0                   ; &#x27;</span>expected<span class="string">&#x27; exit codes used with autorestart (default 0)</span></span><br><span class="line"><span class="string">;stopsignal=QUIT               ; signal used to kill process (default TERM)</span></span><br><span class="line"><span class="string">;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)</span></span><br><span class="line"><span class="string">;stopasgroup=false             ; send stop signal to the UNIX process group (default false)</span></span><br><span class="line"><span class="string">;killasgroup=false             ; SIGKILL the UNIX process group (def false)</span></span><br><span class="line"><span class="string">;user=chrism                   ; setuid to this UNIX account to run the program</span></span><br><span class="line"><span class="string">;redirect_stderr=true          ; redirect proc stderr to stdout (default false)</span></span><br><span class="line"><span class="string">;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO</span></span><br><span class="line"><span class="string">;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"><span class="string">;stdout_logfile_backups=10     ; # of stdout logfile backups (0 means none, default 10)</span></span><br><span class="line"><span class="string">;stdout_capture_maxbytes=1MB   ; number of bytes in &#x27;</span>capturemode<span class="string">&#x27; (default 0)</span></span><br><span class="line"><span class="string">;stdout_events_enabled=false   ; emit events on stdout writes (default false)</span></span><br><span class="line"><span class="string">;stdout_syslog=false           ; send stdout to syslog with process name (default false)</span></span><br><span class="line"><span class="string">;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO</span></span><br><span class="line"><span class="string">;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"><span class="string">;stderr_logfile_backups=10     ; # of stderr logfile backups (0 means none, default 10)</span></span><br><span class="line"><span class="string">;stderr_capture_maxbytes=1MB   ; number of bytes in &#x27;</span>capturemode<span class="string">&#x27; (default 0)</span></span><br><span class="line"><span class="string">;stderr_events_enabled=false   ; emit events on stderr writes (default false)</span></span><br><span class="line"><span class="string">;stderr_syslog=false           ; send stderr to syslog with process name (default false)</span></span><br><span class="line"><span class="string">;environment=A=&quot;1&quot;,B=&quot;2&quot;       ; process environment additions (def no adds)</span></span><br><span class="line"><span class="string">;serverurl=AUTO                ; override serverurl computation (childutils)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The sample eventlistener section below shows all possible eventlistener</span></span><br><span class="line"><span class="string">; subsection values.  Create one or more &#x27;</span>real<span class="string">&#x27; eventlistener: sections to be</span></span><br><span class="line"><span class="string">; able to handle event notifications sent by supervisord.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;[eventlistener:theeventlistenername]</span></span><br><span class="line"><span class="string">;command=/bin/eventlistener    ; the program (relative uses PATH, can take args)</span></span><br><span class="line"><span class="string">;process_name=%(program_name)s ; process_name expr (default %(program_name)s)</span></span><br><span class="line"><span class="string">;numprocs=1                    ; number of processes copies to start (def 1)</span></span><br><span class="line"><span class="string">;events=EVENT                  ; event notif. types to subscribe to (req&#x27;</span>d)</span><br><span class="line">;buffer_size=10                ; event buffer queue size (default 10)</span><br><span class="line">;directory=/tmp                ; directory to cwd to before <span class="built_in">exec</span> (def no cwd)</span><br><span class="line">;<span class="built_in">umask</span>=022                     ; <span class="built_in">umask</span> <span class="keyword">for</span> process (default None)</span><br><span class="line">;priority=-1                   ; the relative start priority (default -1)</span><br><span class="line">;autostart=<span class="literal">true</span>                ; start at supervisord start (default: <span class="literal">true</span>)</span><br><span class="line">;startsecs=1                   ; <span class="comment"># of secs prog must stay up to be running (def. 1)</span></span><br><span class="line">;startretries=3                ; max <span class="comment"># of serial start failures when starting (default 3)</span></span><br><span class="line">;autorestart=unexpected        ; autorestart <span class="keyword">if</span> exited after running (def: unexpected)</span><br><span class="line">;exitcodes=0                   ; <span class="string">&#x27;expected&#x27;</span> <span class="built_in">exit</span> codes used with autorestart (default 0)</span><br><span class="line">;stopsignal=QUIT               ; signal used to <span class="built_in">kill</span> process (default TERM)</span><br><span class="line">;stopwaitsecs=10               ; max num secs to <span class="built_in">wait</span> b4 SIGKILL (default 10)</span><br><span class="line">;stopasgroup=<span class="literal">false</span>             ; send stop signal to the UNIX process group (default <span class="literal">false</span>)</span><br><span class="line">;killasgroup=<span class="literal">false</span>             ; SIGKILL the UNIX process group (def <span class="literal">false</span>)</span><br><span class="line">;user=chrism                   ; setuid to this UNIX account to run the program</span><br><span class="line">;redirect_stderr=<span class="literal">false</span>         ; redirect_stderr=<span class="literal">true</span> is not allowed <span class="keyword">for</span> eventlisteners</span><br><span class="line">;stdout_logfile=/a/path        ; stdout <span class="built_in">log</span> path, NONE <span class="keyword">for</span> none; default AUTO</span><br><span class="line">;stdout_logfile_maxbytes=1MB   ; max <span class="comment"># logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line">;stdout_logfile_backups=10     ; <span class="comment"># of stdout logfile backups (0 means none, default 10)</span></span><br><span class="line">;stdout_events_enabled=<span class="literal">false</span>   ; emit events on stdout writes (default <span class="literal">false</span>)</span><br><span class="line">;stdout_syslog=<span class="literal">false</span>           ; send stdout to syslog with process name (default <span class="literal">false</span>)</span><br><span class="line">;stderr_logfile=/a/path        ; stderr <span class="built_in">log</span> path, NONE <span class="keyword">for</span> none; default AUTO</span><br><span class="line">;stderr_logfile_maxbytes=1MB   ; max <span class="comment"># logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line">;stderr_logfile_backups=10     ; <span class="comment"># of stderr logfile backups (0 means none, default 10)</span></span><br><span class="line">;stderr_events_enabled=<span class="literal">false</span>   ; emit events on stderr writes (default <span class="literal">false</span>)</span><br><span class="line">;stderr_syslog=<span class="literal">false</span>           ; send stderr to syslog with process name (default <span class="literal">false</span>)</span><br><span class="line">;environment=A=<span class="string">&quot;1&quot;</span>,B=<span class="string">&quot;2&quot;</span>       ; process environment additions</span><br><span class="line">;serverurl=AUTO                ; override serverurl computation (childutils)</span><br><span class="line"></span><br><span class="line">; The sample group section below shows all possible group values.  Create one</span><br><span class="line">; or more <span class="string">&#x27;real&#x27;</span> group: sections to create <span class="string">&quot;heterogeneous&quot;</span> process groups.</span><br><span class="line"></span><br><span class="line">;[group:thegroupname]</span><br><span class="line">;programs=progname1,progname2  ; each refers to <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> [program:x] definitions</span><br><span class="line">;priority=999                  ; the relative start priority (default 999)</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the <span class="string">&quot;files&quot;</span> setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br></pre></td></tr></table></figure>
<p>常用配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod&#x3D;0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown&#x3D;nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port&#x3D;9001        					;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username&#x3D;user              ;登录管理后台的用户名</span><br><span class="line">;password&#x3D;123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ;日志文件，默认是 $CWD&#x2F;supervisord.log</span><br><span class="line">logfile_maxbytes&#x3D;50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups&#x3D;10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel&#x3D;info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ;pid 文件</span><br><span class="line">nodaemon&#x3D;false               ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class="line">minfds&#x3D;1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs&#x3D;200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;bin&#x2F;catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart&#x3D;true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs&#x3D;10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart&#x3D;true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries&#x3D;3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user&#x3D;tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority&#x3D;999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr&#x3D;true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes&#x3D;20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups &#x3D; 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;logs&#x2F;catalina.out</span><br><span class="line">stopasgroup&#x3D;false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup&#x3D;false     ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files &#x3D; relative&#x2F;directory&#x2F;*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>我们从<code>supervisor</code>基础模型，组成、再到到使用进行了介绍</li>
<li>验证了<code>supervisor</code>确实可以监控我们的任务，且给予了简单的控制面板，更加便于我们控制、监控</li>
<li><code>supervisor</code>的配置文件十分重要，是熟练使用的前提与基石</li>
</ul>
<p>自从又了它，相信你对于任务的管理再也不会迷路了，冲冲冲～</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmjvtjiqtdj31c20mggp8.jpg" alt=""></p>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>go代码测试与调优</title>
    <url>/2021/04/14/go%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>在了解golang的测试之前，先了解一下go语言自带的测试工具-go test</p>
<h2 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a>go test工具</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。<br><a id="more"></a><br>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>
<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">测试函数</td>
<td style="text-align:center">函数名前缀为Test</td>
<td style="text-align:center">测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td style="text-align:center">基准函数</td>
<td style="text-align:center">函数名前缀为Benchmark</td>
<td style="text-align:center">测试函数的性能</td>
</tr>
<tr>
<td style="text-align:center">示例函数</td>
<td style="text-align:center">函数名前缀为Example</td>
<td style="text-align:center">为文档提供示例文档</td>
</tr>
</tbody>
</table>
</div>
<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h3 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h3><p>上次对于<code>go test</code> 并没有详细的阐述，这次补上。</p>
<p>go test 的使用语法如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> [build/<span class="built_in">test</span> flags] [packages] [build/<span class="built_in">test</span> flags &amp; <span class="built_in">test</span> binary flags]</span><br><span class="line"><span class="comment"># 可以直接 go test 直接运行，那么它将运行本目录下的所有*_test.go的基准测试。</span></span><br><span class="line"><span class="comment"># 还可以进行编译后测试例如 go test build </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多请查看 <code>go help testfunc</code>。</p>
<p><code>go test</code> 命令还会忽略 <code>testdata</code> 目录，该目录用来保存测试需要用到的辅助数据。</p>
<p>go test 有两种运行模式：</p>
<p>1、本地目录模式，在没有包参数（例如 <code>go test</code> 或 <code>go test -v</code>）调用时发生。在此模式下，<code>go test</code> 编译当前目录中找到的包和测试，然后运行测试二进制文件。在这种模式下，caching 是禁用的。在包测试完成后，<code>go test</code> 打印一个概要行，显示测试状态、包名和运行时间。</p>
<p>2、包列表模式，在使用显示包参数调用 <code>go test</code> 时发生（例如 <code>go test math</code>，<code>go test ./...</code> 甚至是 <code>go test .</code>）。在此模式下，go 测试编译并测试在命令上列出的每个包。如果一个包测试通过，<code>go test</code> 只打印最终的 <code>ok</code> 总结行。如果一个包测试失败，<code>go test</code> 将输出完整的测试输出。如果使用 <code>-bench</code> 或 <code>-v</code> 标志，则 <code>go test</code> 会输出完整的输出，甚至是通过包测试，以显示所请求的基准测试结果或详细日志记录。</p>
<p>下面详细说明下 <code>go test</code> 的具体用法，flag 的作用及一些相关例子。需要说明的是：一些 flag 支持 <code>go test</code> 命令和编译后的二进制测试文件。它们都能识别加 <code>-test.</code> 前缀的 flag，如 <code>go test -test.v</code>，但编译后的二进制文件必须加前缀 <code>./sum.test -test.bench=.</code>。</p>
</blockquote>
<p>参数详解</p>
<h3 id="test-flag"><a href="#test-flag" class="headerlink" title="test flag"></a>test flag</h3><p>以下 flag 可以跟被 <code>go test</code> 命令使用：</p>
<ul>
<li><code>-args</code>：传递命令行参数，该标志会将 -args 之后的参数作为命令行参数传递，最好作为最后一个标志。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -args -p&#x3D;true</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：编译测试二进制文件为 [pkg].test，不运行测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -c &amp;&amp; .&#x2F;sum.test -p&#x3D;true</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-exec xprog</code>：使用 xprog 运行测试，行为同 <code>go run</code> 一样，查看 <code>go help run</code>。</li>
<li><code>-i</code>：安装与测试相关的包，不运行测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -i</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-o file</code>：编译测试二进制文件并指定文件，同时运行测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go test -o filename</span><br></pre></td></tr></table></figure>
<h3 id="test-binary-flag"><a href="#test-binary-flag" class="headerlink" title="test/binary flag"></a>test/binary flag</h3><p>以下标志同时支持测试二进制文件和 <code>go test</code> 命令。</p>
<ul>
<li><code>-bench regexp</code>：通过正则表达式执行基准测试，默认不执行基准测试。可以使用 <code>-bench .</code>或<code>-bench=.</code>执行所有基准测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -bench&#x3D;.</span><br><span class="line">$ go test -c</span><br><span class="line">$ .&#x2F;sum.test -test.bench&#x3D;.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-benchtime t</code>：每个基准测试运行足够迭代消耗的时间，time.Duration（如 -benchtime 1h30s），默认 1s。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -bench&#x3D;. -benchtime 0.1s</span><br><span class="line">$ .&#x2F;sum.test -test.bench&#x3D;. -test.benchtime&#x3D;1s</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-count n</code>：运行每个测试和基准测试的次数（默认 1），如果 -cpu 指定了，则每个 GOMAXPROCS 值执行 n 次，Examples 总是运行一次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -bench&#x3D;. -count&#x3D;2</span><br><span class="line">$ .&#x2F;sum.test -test.bench&#x3D;. -test.count&#x3D;2</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-cover</code>：开启覆盖分析，开启覆盖分析可能会在编译或测试失败时，代码行数不对。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go test -bench&#x3D;. -cover</span><br></pre></td></tr></table></figure>
<ul>
<li>```<br>-covermode set,count,atomic<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：覆盖分析的模式，默认是 set，如果设置 -race，将会变为 atomic。</span><br><span class="line"></span><br><span class="line">    - set，bool，这个语句运行吗？</span><br><span class="line">    - count，int，该语句运行多少次？</span><br><span class="line">    - atomic，int，数量，在多线程正确使用，但是耗资源的。</span><br><span class="line"></span><br><span class="line">- &#96;-coverpkg pkg1,pkg2,pkg3&#96;：指定分析哪个包，默认值只分析被测试的包，包为导入的路径。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="sum-gt-GOPATH-src-test-sum"><a href="#sum-gt-GOPATH-src-test-sum" class="headerlink" title="sum -&gt; $GOPATH/src/test/sum"></a>sum -&gt; $GOPATH/src/test/sum</h1>$ go test -coverpkg test/sum<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-cpu 1,2,4&#96;：指定测试或基准测试的 GOMAXPROCS 值。默认为 GOMAXPROCS 的当前值。</span><br><span class="line">- &#96;-list regexp&#96;：列出与正则表达式匹配的测试、基准测试或 Examples。只列出顶级测试（不列出子测试），不运行测试。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -list Sum<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-parallel n&#96;：允许并行执行通过调用 t.Parallel 的测试函数的最大次数。默认值为 GOMAXPROCS 的值。-parallel 仅适用于单个二进制测试文件，但&#96;go test&#96;命令可以通过指定 -p 并行测试不同的包。查看 &#96;go help build&#96;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -run=TestSumParallel -parallel=2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-run regexp&#96;：只运行与正则表达式匹配的测试和Examples。可以通过 &#x2F; 来指定测试子函数。&#96;go test Foo&#x2F;A&#x3D;&#96;，会先去匹配并执行 Foo 函数，再查找子函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -v -run TestSumSubTest/1+<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-short&#96;：缩短长时间运行的测试的测试时间。默认关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -short<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-timeout d&#96;：如果二进制测试文件执行时间过长，panic。默认10分钟（10m）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -run TestSumLongTime -timeout 1s<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-v&#96;：详细输出，运行期间所有测试的日志。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -v<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### analyze flag</span><br><span class="line"></span><br><span class="line">以下测试适用于 &#96;go test&#96; 和测试二进制文件：</span><br><span class="line"></span><br><span class="line">- &#96;-benchmem&#96;：打印用于基准的内存分配统计数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -bench=. -benchmem<br>$ ./sum.test -test.bench -test.benchmem<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-blockprofile block.out&#96;：当所有的测试都完成时，在指定的文件中写入一个 goroutine 阻塞概要文件。指定 -c，将写入测试二进制文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -v -cpuprofile=prof.out<br>$ go tool pprof prof.out<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-blockprofilerate n&#96;：goroutine 阻塞时候打点的纳秒数。默认不设置就相当于 -test.blockprofilerate&#x3D;1，每一纳秒都打点记录一下。</span><br><span class="line">- &#96;-coverprofile cover.out&#96;：在所有测试通过后，将覆盖概要文件写到文件中。设置过 -cover。</span><br><span class="line">- &#96;-cpuprofile cpu.out&#96;：在退出之前，将一个 CPU 概要文件写入指定的文件。</span><br><span class="line">- &#96;-memprofile mem.out&#96;：在所有测试通过后，将内存概要文件写到文件中。</span><br><span class="line">- &#96;-memprofilerate n&#96;：开启更精确的内存配置。如果为 1，将会记录所有内存分配到 profile。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ go test -memprofile mem.out -memprofilerate 1<br>$ go tool pprof mem.out<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;-mutexprofile mutex.out&#96;：当所有的测试都完成时，在指定的文件中写入一个互斥锁争用概要文件。指定 -c，将写入测试二进制文件。</span><br><span class="line">- &#96;-mutexprofilefraction n&#96;：样本 1 在 n 个堆栈中，goroutines 持有 a，争用互斥锁。</span><br><span class="line">- &#96;-outputdir directory&#96;：在指定的目录中放置输出文件，默认情况下，&#96;go test&#96; 正在运行的目录。</span><br><span class="line">- &#96;-trace trace.out&#96;：在退出之前，将执行跟踪写入指定文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 单元测试</span><br><span class="line"></span><br><span class="line">&gt; 以下是来自wiki对于单元测试的定义</span><br><span class="line"></span><br><span class="line">在[计算机编程](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;计算机编程)中，**单元测试**（英语：Unit Testing）又称为**模块测试**，是针对[程序模块](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;模組_(程式設計))（[软件设计](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;软件设计)的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在[过程化编程](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;過程化編程)中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到[软件规格书](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;規格_(技術標準))要求的工作目标，没有[程序错误](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Bug)；虽然单元测试不是必须的，但也不坏，这牵涉到[项目管理](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;專案管理)的政策决定。</span><br><span class="line"></span><br><span class="line">每个理想的[测试案例](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;测试案例)独立于其它案例；为测试时隔离模块，经常使用stubs、mock[[1\]](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;单元测试#cite_note-mocksarentstubs-1)或fake等测试[马甲程序](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;w&#x2F;index.php?title&#x3D;马甲程序&amp;action&#x3D;edit&amp;redlink&#x3D;1)。单元测试通常由[软件开发人员](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;w&#x2F;index.php?title&#x3D;软件开发人员&amp;action&#x3D;edit&amp;redlink&#x3D;1)编写，用于确保他们所写的代码符合软件需求和遵循[开发目标](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;w&#x2F;index.php?title&#x3D;开发目标&amp;action&#x3D;edit&amp;redlink&#x3D;1)。它的实施方式可以是非常手动的（透过纸笔），或者是做成[构建自动化](https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;構建自動化)的一部分。</span><br><span class="line"></span><br><span class="line">简单来说，单元测试就是程序员自己对于自己的代码进行测试，而一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">更有一种开发手法，那就是TDD（Test Driven Development）,测试驱动开发。期望局部最优到全局最优，这个是一种非常不错的好习惯</span><br><span class="line"></span><br><span class="line">&gt; 请注意这里的局部最优的，局部，并不是函数内的详细。而是整个函数。甚至是一个类，等等。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因为有些函数内部的最优，并非这个函数的最优。这点需要格外的注意。若有兴趣，可了解一下有点关系的贪心算法</span><br><span class="line"></span><br><span class="line">### 测试函数格式</span><br><span class="line"></span><br><span class="line">其中参数&#96;t&#96;用于报告测试失败和附加的日志信息。 &#96;testing.T&#96;的拥有的方法如下：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">func (c *T) Error(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Errorf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fail()</span><br><span class="line">func (c *T) FailNow()</span><br><span class="line">func (c *T) Failed() bool</span><br><span class="line">func (c *T) Fatal(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fatalf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Log(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Logf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Name() string</span><br><span class="line">func (t *T) Parallel()</span><br><span class="line">func (t *T) Run(name string, f func(t *T)) bool</span><br><span class="line">func (c *T) Skip(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) SkipNow()</span><br><span class="line">func (c *T) Skipf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Skipped() bool</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>说了这么多，来实现一个<code>简单的</code>string中的Split函数，并对他进行单元测试，然后在剖析代码。了解单元测试的相关规范</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// splits.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	i := strings.Index(s, sep)</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">		s = s[i+<span class="number">1</span>:]</span><br><span class="line">		i = strings.Index(s, sep)</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, s)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split_test.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit 单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">	got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">	want := []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能直接比较，借助反射包中的方法比较</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit2 单元测试组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个测试用例类型</span></span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">		input <span class="keyword">string</span></span><br><span class="line">		sep   <span class="keyword">string</span></span><br><span class="line">		want  []<span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">	tests := []test&#123;</span><br><span class="line">		&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line">	<span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		got := Split(tc.input, tc.sep)</span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrolzdwnuj318y0dq3z2.jpg" alt=""></p>
<p>说明测试成功，本次通过。当然你也可以在<code>Terminal</code>里面直接运行<code>go test</code>，命令，如下所示</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnropdatxhj30oa0bg0t4.jpg" style="zoom:70%;" /></p>
<blockquote>
<p>温馨提示：关于可能造成运行test不成功原因</p>
<p>直接在<code>split_test.go</code>,运行。</p>
<ul>
<li>或许知道，go是以文件夹的方法来区分项目。所以当前文件，并不能跑到旁边文件中去找到<code>Split</code>,以至于测试失败。或未达到预期效果</li>
</ul>
<p>那么正确的打开方式应该是？</p>
<p>在goland中，鼠标右键点击run测试文件所在的文件夹，选择后面第二个 <code>go test projectFileName</code></p>
<p>在<code>Terminal</code>中，应在<code>测试文件所在的文件夹</code>的路径中，进行<code>go test [arge...]</code></p>
</blockquote>
<p>示例看完了，那么进行简单的剖析。先从函数文件说起，(也就是这里的<code>splits.go</code>)</p>
<ol>
<li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li>
<li>函数名大写，大写意味着公有函数，可支持外部调用</li>
</ol>
<p>测试文件</p>
<ol>
<li>文件名为’*_test.go’</li>
<li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li>
<li>函数名为TestFuncName</li>
</ol>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="基准测试函数格式"><a href="#基准测试函数格式" class="headerlink" title="基准测试函数格式"></a>基准测试函数格式</h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ReportAllocs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ResetTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(b *B)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">RunParallel</span><span class="params">(body <span class="keyword">func</span>(*PB)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetBytes</span><span class="params">(n <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetParallelism</span><span class="params">(p <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StartTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StopTimer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h3><p>为自己写的<code>Split</code>函数编写基准测试如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BenchmarkSplit 基准测试(性能测试)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N ; i++ &#123;</span><br><span class="line">		Split(<span class="string">&quot;abcdebdae&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: Gp/part5/splitStr</span><br><span class="line">BenchmarkSplit</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>   	 <span class="number">5740642</span>	       <span class="number">209</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  	Gp/part5/splitStr	<span class="number">1.963</span>s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中</p>
<p>BenchmarkSplit：表示对Split函数进行基准测试</p>
<p>BenchmarkSplit-8：数字<code>8</code>表示<code>GOMAXPROCS</code>的值，这个对于并发基准测试很重要</p>
<p>5188407和206 ns/op：表示每次调用<code>Split</code>函数耗时<code>203ns</code></p>
</blockquote>
<p>还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrw3i5yuej312k07adg0.jpg" alt=""></p>
<blockquote>
<p> 112 B/op：表示每次操作内存分配了112字节</p>
<p><code>3 allocs/op</code>：则表示每次操作进行了3次内存分配！！！</p>
</blockquote>
<p>优化后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	i := strings.Index(s, sep)</span><br><span class="line">  <span class="comment">// 手动分配固定内存，避免多次创建</span></span><br><span class="line">	result = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">		s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">		i = strings.Index(s, sep)</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, s)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后代码如下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrx800j18j314g07gjrk.jpg" alt=""></p>
<blockquote>
<p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p>
<p>仅仅小小的一处改动，就引起如此大的性能改变。so good</p>
<p>量变产生质变</p>
</blockquote>
<h3 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h3><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="keyword">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>例如编写了一个计算斐波那契数列的函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写的性能比较函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Fib(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>运行基准测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns/op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns/op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns/op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns/op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns/op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 12.944s</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下应该可以使用<code>-benchtime</code>标志增加最小基准时间，以产生更准确的结果。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Fib40 -benchtime=20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 33.849s</span><br></pre></td></tr></table></figure>
<p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		Fib(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a>重置时间</h2><p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line">	b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		strings.Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p>
<p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下基准测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure>
<p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p>
<h2 id="Setup与TearDown"><a href="#Setup与TearDown" class="headerlink" title="Setup与TearDown"></a>Setup与TearDown</h2><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h2 id="Go性能优化"><a href="#Go性能优化" class="headerlink" title="Go性能优化"></a>Go性能优化</h2><p>做了这么多的测试最终的目的是测试代码有没有写对，性能是否可以优化。接下来进行性能优化与调优</p>
<p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库。</p>
<p>Go语言项目中的性能优化主要有以下几个方面：</p>
<ul>
<li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li>
<li>Memory Profile（Heap Profile）：报告程序的内存的使用情况</li>
<li>Block Profiling：报告 goroutine 不在运行状态的情况，可以用来分析与查找死锁等性能瓶颈</li>
<li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
<h3 id="采集性能数据"><a href="#采集性能数据" class="headerlink" title="采集性能数据"></a>采集性能数据</h3><p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p>
<ul>
<li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li>
<li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li>
</ul>
<p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p>
<h3 id="pprof应用"><a href="#pprof应用" class="headerlink" title="pprof应用"></a>pprof应用</h3><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h3><p>开启CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer)</span><br></pre></td></tr></table></figure>
<p>停止CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure>
<p>应用执行结束后，就会生成一个文件，保存了 CPU profiling 数据。得到采样数据之后，使用<code>go tool pprof</code>工具进行CPU性能分析。</p>
<h3 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h3><p>记录程序的堆栈信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure>
<p>得到采样数据之后，使用<code>go tool pprof</code>工具进行内存性能分析。</p>
<p><code>go tool pprof</code>默认是使用<code>-inuse_space</code>进行统计，还可以使用<code>-inuse-objects</code>查看分配对象的数量。</p>
<h2 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h2><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p>
<p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure>
<p>如果你使用的是gin框架，推荐使用<a href="https://github.com/gin-contrib/pprof">github.com/gin-contrib/pprof</a>，在代码中通过以下命令注册pprof相关路由。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure>
<p>不管哪种方式，你的 HTTP 服务都会多出<code>/debug/pprof</code> endpoint，访问它会得到类似下面的内容：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpih7cgmhxj30hu0jwmy0.jpg" alt=""></p>
<p>这个路径下还有几个子页面：</p>
<ul>
<li>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，并生成一个文件供下载</li>
<li>/debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li>
<li>/debug/pprof/block：block Profiling 的路径</li>
<li><p>/debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系</p>
</li>
<li><p>。。。 。。。</p>
</li>
</ul>
<h3 id="go-tool-pprof命令"><a href="#go-tool-pprof命令" class="headerlink" title="go tool pprof命令"></a>go tool pprof命令</h3><p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code>命令行工具。</p>
<p><code>go tool pprof</code>最简单的使用方式为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>binary 是应用的二进制文件，用来解析各种符号；</li>
<li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li>
</ul>
<p><strong>注意事项：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p>
<h3 id="命令行交互界面"><a href="#命令行交互界面" class="headerlink" title="命令行交互界面"></a>命令行交互界面</h3><p>我们使用go工具链里的<code>pprof</code>来分析一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof cpu.pprof</span><br></pre></td></tr></table></figure>
<p>执行上面的代码会进入交互界面如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runtime_pprof $ go tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Jun 28, 2020 at 11:28am (CST)</span><br><span class="line">Duration: 20.13s, Total samples = 1.91mins (538.60%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)  </span><br></pre></td></tr></table></figure>
<p>我们可以在交互界面输入<code>top3</code>来查看程序中占用CPU前3位的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(pprof) top3</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> 100.37s, 87.68% of 114.47s total</span><br><span class="line">Dropped 17 nodes (cum &lt;= 0.57s)</span><br><span class="line">Showing top 3 nodes out of 4</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    42.52s 37.15% 37.15%     91.73s 80.13%  runtime.selectnbrecv</span><br><span class="line">    35.21s 30.76% 67.90%     39.49s 34.50%  runtime.chanrecv</span><br><span class="line">    22.64s 19.78% 87.68%    114.37s 99.91%  main.logicCode</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>flat：当前函数占用CPU的耗时</li>
<li>flat：:当前函数占用CPU的耗时百分比</li>
<li>sun%：函数占用CPU的耗时累计百分比</li>
<li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li>
<li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li>
<li>最后一列：函数名称</li>
</ul>
<p>在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p>
<p>还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list logicCode</code>查看我们编写的函数的详细分析。</p>
<h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。 想要查看图形化的界面首先需要安装<a href="https://graphviz.gitlab.io/">graphviz</a>图形化工具。</p>
<p>Mac：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>
<p>Windows: 下载<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html">graphviz</a> 将<code>graphviz</code>安装目录下的bin文件夹添加到Path环境变量中。 在终端输入<code>dot -version</code>查看是否安装成功。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpihc6efdzj310a0q676g.jpg" alt=""></p>
<p>关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。 线条上的数字表示函数调用的次数。 方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p>
<p>除了分析CPU性能数据，pprof也支持分析内存性能数据。比如，使用下面的命令分析http服务的heap性能数据，查看当前程序的内存占用以及热点内存对象使用的情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内存占用数据</span></span><br><span class="line">go tool pprof -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"><span class="comment"># 查看临时内存分配数据</span></span><br><span class="line">go tool pprof -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>
<h2 id="go-torch和火焰图"><a href="#go-torch和火焰图" class="headerlink" title="go-torch和火焰图"></a>go-torch和火焰图</h2><p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling 结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：<code>go-torch</code>。这是 uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。</p>
<h3 id="安装go-torch"><a href="#安装go-torch" class="headerlink" title="安装go-torch"></a>安装go-torch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -v github.com/uber/go-torch</span><br></pre></td></tr></table></figure>
<p>火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in 分析它上面的内容。</p>
<p>火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用 CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p>
<p>go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从<code>http://localhost:8080/debug/pprof/profile</code>获取 profiling 数据。它有三个常用的参数可以调整：</p>
<ul>
<li>-u –url：要访问的 URL，这里只是主机和端口部分</li>
<li>-s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile</li>
<li>–seconds：要执行 profiling 的时间长度，默认为 30s</li>
</ul>
<h3 id="安装-FlameGraph"><a href="#安装-FlameGraph" class="headerlink" title="安装 FlameGraph"></a>安装 FlameGraph</h3><p>要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。</p>
<ol>
<li>下载安装perl：<a href="https://www.perl.org/get.html">https://www.perl.org/get.html</a></li>
<li>下载FlameGraph：<code>git clone https://github.com/brendangregg/FlameGraph.git</code></li>
<li>将<code>FlameGraph</code>目录加入到操作系统的环境变量中。</li>
<li>Windows平台，需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code>按如下方式修改，然后在<code>go-torch</code>目录下执行<code>go install</code>即可。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) &#123;</span></span><br><span class="line">flameGraph := findInPath(flameGraphScripts)</span><br><span class="line"><span class="keyword">if</span> flameGraph == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errNoPerlScript</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> runScript(<span class="string">&quot;perl&quot;</span>, <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;flameGraph&#125;, args...), graphInput)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> runScript(flameGraph, args, graphInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h3><p>推荐使用<a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a> 或 <a href="https://github.com/adjust/go-wrk">https://github.com/adjust/go-wrk</a></p>
<h3 id="使用go-torch"><a href="#使用go-torch" class="headerlink" title="使用go-torch"></a>使用go-torch</h3><p>使用wrk进行压测:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-wrk -n 50000 http://127.0.0.1:8080/book/list</span><br></pre></td></tr></table></figure>
<p>在上面压测进行的同时，打开另一个终端执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-torch -u http://127.0.0.1:8080 -t 30</span><br></pre></td></tr></table></figure>
<p>30秒之后终端会出现如下提示：<code>Writing svg to torch.svg</code></p>
<p>然后我们使用浏览器打开<code>torch.svg</code>就能看到如下火焰图了。</p>
<p>火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p>
<p>此外还可以借助火焰图分析内存性能数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-torch -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>
<h2 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h2><p><code>go test</code>命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p>
<ul>
<li>-cpuprofile：cpu profiling 数据要保存的文件地址</li>
<li>-memprofile：memory profiling 数据要报文的文件地址</li>
</ul>
<p>我们还可以选择将pprof与性能测试相结合，比如：</p>
<p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.prof</span><br></pre></td></tr></table></figure>
<p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -memprofile=./mem.prof</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下 Profiling 才有意义。</p>
<h2 id="referce"><a href="#referce" class="headerlink" title="referce"></a>referce</h2><p><a href="https://www.liwenzhou.com/posts/Go/performance_optimisation/">李文周-Go性能优化</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>详探Redis.conf</title>
    <url>/2021/01/18/%E8%AF%A6%E6%8E%A2Redis-conf/</url>
    <content><![CDATA[<blockquote>
<p>Redis版本：6.0.10</p>
<p>redis.conf 默认路径：/opt/redis-6.0.10 路径下（如果为自定制安装，则在您设置的redis路径下）</p>
</blockquote>
<p>还记得我刚入行的时候，我的师傅就经常告诉我们<code>配置比开发更重要</code>，因为很多时候就是由于配置不当，而造成后期的难以预想的各种问题，以至于项目难以维护等等由于配置。进入一个公司首先的也是看相关项目的文档。so，如果需要对于redis有更深入的了解，与使用配置文件不可不读。为CURD，但不止于CURD。那么接下来我们对于<code>redis.conf</code>有个了解，话不多说，开干。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Redis configuration file example.</span><br><span class="line"></span><br><span class="line">Note that in order to read the configuration file, Redis must be</span><br><span class="line">started with the file path as first argument:</span><br><span class="line"></span><br><span class="line">./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line">Note on units: when memory size is needed, it is possible to specify</span><br><span class="line">it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line"></span><br><span class="line"><span class="attr">1k</span> =&gt; <span class="number">1000</span> bytes</span><br><span class="line"><span class="attr">1kb</span> =&gt; <span class="number">1024</span> bytes</span><br><span class="line"><span class="attr">1m</span> =&gt; <span class="number">1000000</span> bytes</span><br><span class="line"><span class="attr">1mb</span> =&gt; <span class="number">1024</span>*<span class="number">1024</span> bytes</span><br><span class="line"><span class="attr">1g</span> =&gt; <span class="number">1000000000</span> bytes</span><br><span class="line"><span class="attr">1gb</span> =&gt; <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span> bytes</span><br><span class="line"></span><br><span class="line">units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br></pre></td></tr></table></figure>
<p>Redis启动必须指定配置文件路径(如果没有则使用默认的配置文件)，</p>
<blockquote>
<p>说明如果我们把<code>默认的</code>配置文件给删除了，是无法启动redis的。</p>
<p>同理既然可以指定路径，那么我们也可以参考默认配置文件，定制化配置Redis</p>
</blockquote>
<p>需要使用内存大小时，可以指定单位，通常是以 k,gb,m的形式出现，并且<strong>单位不区分大小写</strong>。</p>
<p>仔细看你会发现它只支持<code>bytes</code>类型，不支持<code>`bit</code>等类型</p>
<h2 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a>INCLUDES</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Include one or more other config files here.  This is useful if you</span><br><span class="line">have a standard template that goes to all Redis servers but also need</span><br><span class="line">to customize a few per-server settings.  Include files can include</span><br><span class="line">other files, so use this wisely.</span><br><span class="line"><span class="comment"># 在此处包括一个或多个其他配置文件。如果您具有可用于所有Redis服务器的标准模板，但还需要自定义一些每台服务器设置，则此功能很有用。包含文件可以包含其他文件，因此请明智地使用它</span></span><br><span class="line">Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line">from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line">line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="line">at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line"><span class="comment"># 请注意，选项“ include”将不会被admin或Redis Sentinel中的命令“ CONFIG REWRITE”重写。由于Redis始终使用最后处理的行作为配置指令的值，因此最好将include放在此文件的开头，以避免在运行时覆盖配置更改</span></span><br><span class="line">If instead you are interested in using includes to override configuration</span><br><span class="line">options, it is better to use include as the last line.</span><br><span class="line"><span class="comment"># 相反，如果您有兴趣使用include覆盖配置选项，则最好使用include作为最后一行</span></span><br><span class="line">include /path/to/local.conf</span><br><span class="line">include /path/to/other.conf</span><br></pre></td></tr></table></figure>
<p>我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过 include /path/to/local.conf 配置进来，而原本的 redis.conf 配置文件就作为一个总闸。</p>
<p>另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。</p>
<h2 id="MODULES"><a href="#MODULES" class="headerlink" title="MODULES"></a>MODULES</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Load modules at startup. If the server is not able to load modules</span><br><span class="line">it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line"></span><br><span class="line">loadmodule /path/to/my_module.so</span><br><span class="line">loadmodule /path/to/other_module.so</span><br></pre></td></tr></table></figure>
<p>通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。</p>
<h2 id="NETWORK-重要"><a href="#NETWORK-重要" class="headerlink" title="NETWORK(重要)"></a>NETWORK(重要)</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="line">for connections from all available network interfaces on the host machine.</span><br><span class="line">It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line">the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line"><span class="comment"># 默认情况下，如果未指定“ bind”配置指令，则Redis侦听主机上所有可用网络接口的连接。可以使用“ bind”配置指令仅侦听一个或多个所选接口，然后侦听一个或多个IP地址</span></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">bind 192.168.1.100 10.0.0.1</span><br><span class="line">bind 127.0.0.1 ::1</span><br><span class="line"></span><br><span class="line">~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line">internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line">instance to everybody on the internet. So by default we uncomment the</span><br><span class="line">following bind directive, that will force Redis to listen only on the</span><br><span class="line">IPv4 loopback interface address (this means Redis will only be able to</span><br><span class="line">accept client connections from the same host that it is running on).</span><br><span class="line"><span class="comment"># ~~~警告~~~如果运行Redis的计算机直接暴露于Internet，则绑定到所有接口都是很危险的，并且会将实例暴露给Internet上的所有人。因此，默认情况下，我们取消注释以下bind指令，这将强制Redis仅在IPv4环回接口地址上侦听（这意味着Redis将只能接受来自其运行所在主机的客户端连接）</span></span><br><span class="line">IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line">JUST COMMENT OUT THE FOLLOWING LINE.</span><br><span class="line"><span class="comment"># 如果您确定要立即侦听所有接口，只需在后续行中注明即可。</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">bind 127.0.0.1 ::1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line">Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"><span class="comment"># 保护模式是安全保护的一层，目的是避免访问和利用Internet上打开的Redis实例。</span></span><br><span class="line">When protected mode is on and if:</span><br><span class="line"><span class="comment"># 当保护模式开启时，如果</span></span><br><span class="line">1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">&quot;bind&quot; directive.</span><br><span class="line"><span class="comment"># 服务器未使用“ bind”指令显式绑定到一组地址</span></span><br><span class="line">2) No password is configured.</span><br><span class="line"><span class="comment"># 没有配置密码</span></span><br><span class="line">The server only accepts connections from clients connecting from the</span><br><span class="line">IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line">sockets.</span><br><span class="line"><span class="comment"># 服务器仅接受来自客户端的连接，这些客户端从IPv4和IPv6回送地址127.0.0.1和:: 1以及Unix域套接字连接</span></span><br></pre></td></tr></table></figure>
<p>bind:绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。</p>
<p>同时需要注意的是 如果注释掉<code>bind</code>后面的内容，运行Redis的计算机将直接暴露于在internet上，绑定到所有接口是危险的，并且会暴露向互联网上的每个人提供实例。需谨慎选择</p>
<blockquote>
<p>至少也得加个密码(见下文)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By default protected mode is enabled. You should disable it only if</span><br><span class="line">you are sure you want clients from other hosts to connect to Redis</span><br><span class="line">even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line">are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line"># 默认情况下启用保护模式。仅当您确定您希望其他主机的客户端连接到Redis时，即使未配置身份验证，也不要使用“ bind”指令显式列出一组特定的接口，才应禁用它</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
<p>默认情况下，启用保护模式。只有当您确定希望来自其他主机的客户端连接到Redis时才应该禁用它，即使没有配置身份验证，也没有使用“bind”指令显式列出一组特定的接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept connections on the specified port, default is 6379 (IANA 815344).</span><br><span class="line">If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line"># 接受指定端口上的连接，默认为6379（IANA 815344）。如果指定了端口0，则Redis将不会在TCP套接字上侦听</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure>
<p>接受指定端口上的连接，默认值为6379。如果指定了端口0，Redis将不会侦听TCP套接字。由于Redis是单线程模型，因此单机开多个Redis进程的时候需要修改端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP listen() backlog.</span><br><span class="line"></span><br><span class="line">In high requests-per-second environments you need a high backlog in order</span><br><span class="line">to avoid slow clients connection issues. Note that the Linux kernel</span><br><span class="line">will silently truncate it to the value of &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn so</span><br><span class="line">make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line">in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">在每秒高请求的环境中，您需要一个高积压工作，以避免客户端连接速度慢的问题。请注意，Linux内核将静默地将其截断为&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn so的值</span><br><span class="line">确保同时提高somaxconn和tcp\u max\u syn\u backlog的值以获得所需的效果</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认值 511<br>tcp-backlog：511</p>
<p>此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。</p>
<p>建议修改为 2048<br>修改somaxconn</p>
<p>该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。</p>
<p>echo 2048 &gt; /proc/sys/net/core/somaxconn 但是这样系统重启后保存不了</p>
<p>在/etc/sysctl.conf中添加如下</p>
<p>net.core.somaxconn = 2048</p>
<p>然后在终端中执行</p>
<p>sysctl -p</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unix socket.</span><br><span class="line"></span><br><span class="line">Specify the path for the Unix socket that will be used to listen for</span><br><span class="line">incoming connections. There is no default, so Redis will not listen</span><br><span class="line">on a unix socket when not specified.</span><br><span class="line"></span><br><span class="line">unixsocket &#x2F;tmp&#x2F;redis.sock</span><br><span class="line">unixsocketperm 700</span><br></pre></td></tr></table></figure>
<p>指定用于侦听传入连接的Unix套接字的路径。没有默认值，因此Redis在未指定时不会侦听unix套接字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br></pre></td></tr></table></figure>
<p>客户端空闲N秒后关闭连接（0表示禁用）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">TCP keepalive.</span><br><span class="line"></span><br><span class="line">If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line">of communication. This is useful for two reasons:</span><br><span class="line"><span class="comment"># 如果不为零，请在没有通信的情况下使用SO_KEEPALIVE向客户端发送TCP ACK。这很有用，有两个原因：</span></span><br><span class="line">1) Detect dead peers.   # 检测死者</span><br><span class="line">2) Force network equipment in the middle to consider the connection to be</span><br><span class="line">alive.                  # 强制中间的网络设备考虑连接处于活动状态。</span><br><span class="line"></span><br><span class="line">On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line">Note that to close the connection the double of the time is needed.</span><br><span class="line">On other kernels the period depends on the kernel configuration.</span><br><span class="line"><span class="comment"># 在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。请注意，关闭连接需要两倍的时间。在其他内核上，周期取决于内核配置</span></span><br><span class="line">A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line">Redis default starting with Redis 3.2.1.</span><br><span class="line"><span class="comment"># 此选项的合理值是300秒，这是从Redis 3.2.1开始的新Redis默认值。</span></span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure>
<p>TCP保持连接。</p>
<p>如果非零，则在没有通信的情况下，使用SO_KEEPALIVE向客户端发送TCP确认。这有两个原因：</p>
<p>1） 检测死掉的同伴。</p>
<p>2） 强制中间的网络设备认为连接是活动的。</p>
<p>在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。请注意，要关闭连接，需要两倍的时间。</p>
<p>在其他内核上，周期取决于内核配置。</p>
<p>这个选项的合理值是300秒，这是从redis3.2.1开始的新Redis默认值。</p>
<p>tcp保持300</p>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By default, TLS&#x2F;SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span><br><span class="line">directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="line">default port, use:</span><br><span class="line"># 默认情况下，TLSSSL被禁用。要启用它，可以使用“ tls-port”配置指令来定义TLS侦听端口。要在默认端口上启用TLS，请使用</span><br><span class="line">port 0</span><br><span class="line">tls-port 6379</span><br></pre></td></tr></table></figure>
<p>默认情况下，TLS/SSL处于禁用状态。要启用它，“tls端口”配置</p>
<p>指令可用于定义TLS侦听端口。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="line">server to connected clients, masters or cluster peers.  These files should be</span><br><span class="line">PEM formatted.</span><br><span class="line"><span class="comment"># 配置X.509证书和私钥，用于对连接的客户端，主服务器或集群对等服务器进行身份验证。这些文件应为PEM格式</span></span><br><span class="line">tls-cert-file redis.crt </span><br><span class="line">tls-key-file redis.key</span><br><span class="line"></span><br><span class="line">Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="line"></span><br><span class="line">tls-dh-params-file redis.dh</span><br><span class="line"></span><br><span class="line">Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="line">clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="line">of these, and will not implicitly use the system wide configuration.</span><br><span class="line"></span><br><span class="line">tls-ca-cert-file ca.crt</span><br><span class="line">tls-ca-cert-dir /etc/ssl/certs</span><br><span class="line"></span><br><span class="line">By default, clients (including replica servers) on a TLS port are required</span><br><span class="line">to authenticate using valid client side certificates.</span><br><span class="line"><span class="comment"># 默认情况下，要求TLS端口上的客户端（包括副本服务器）使用有效的客户端证书进行身份验证</span></span><br><span class="line">If &quot;no&quot; is specified, client certificates are not required and not accepted.</span><br><span class="line">If &quot;optional&quot; is specified, client certificates are accepted and must be</span><br><span class="line">valid if provided, but are not required.</span><br><span class="line"><span class="comment"># 如果指定“否”，则不需要也不接受客户端证书。如果指定了“可选”，则接受客户端证书，并且如果提供的话，客户端证书必须有效，但不是必需的</span></span><br><span class="line">tls-auth-clients no</span><br><span class="line">tls-auth-clients optional</span><br><span class="line"></span><br><span class="line">By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="line">with its master.</span><br><span class="line"><span class="comment"># 默认情况下，Redis副本不会尝试与其主服务器建立TLS连接</span></span><br><span class="line">Use the following directive to enable TLS on replication links.</span><br><span class="line"><span class="comment"># 使用以下指令在复制链接上启用TLS</span></span><br><span class="line">tls-replication yes</span><br><span class="line"></span><br><span class="line">By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="line">TLS for the bus protocol, use the following directive:</span><br><span class="line"></span><br><span class="line">tls-cluster yes</span><br><span class="line"></span><br><span class="line">Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="line">and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot; (OpenSSL &gt;= 1.1.1) or</span><br><span class="line">any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="line"></span><br><span class="line">tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span><br><span class="line"></span><br><span class="line">Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="line">about the syntax of this string.</span><br><span class="line"></span><br><span class="line">Note: this configuration applies only to &lt;= TLSv1.2.</span><br><span class="line"></span><br><span class="line">tls-ciphers DEFAULT:!MEDIUM</span><br><span class="line"></span><br><span class="line">Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="line">information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="line">ciphersuites.</span><br><span class="line"></span><br><span class="line">tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line"></span><br><span class="line">When choosing a cipher, use the server&#x27;s preference instead of the client</span><br><span class="line">preference. By default, the server follows the client&#x27;s preference.</span><br><span class="line"></span><br><span class="line">tls-prefer-server-ciphers yes</span><br><span class="line"></span><br><span class="line">By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="line">reconnections by clients that support it. Use the following directive to disable</span><br><span class="line">caching.</span><br><span class="line"></span><br><span class="line">tls-session-caching no</span><br><span class="line"></span><br><span class="line">Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="line">to unlimited size. The default size is 20480.</span><br><span class="line"></span><br><span class="line">tls-session-cache-size 5000</span><br><span class="line"></span><br><span class="line">Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="line">seconds.</span><br><span class="line"></span><br><span class="line">tls-session-cache-timeout 60</span><br></pre></td></tr></table></figure>
<h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By default Redis does not run as a daemon. Use &#39;yes&#39; if you need it.</span><br><span class="line">Note that Redis will write a pid file in &#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br></pre></td></tr></table></figure>
<p>　daemonize:设置为yes表示指定Redis以守护进程的方式启动（即后台启动）。默认值为 no</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line">supervision tree. Options:</span><br><span class="line">supervised no      - no supervision interaction</span><br><span class="line">supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">                    requires &quot;expect stop&quot; in your upstart job config</span><br><span class="line">supervised systemd - signal systemd by writing READY&#x3D;1 to $NOTIFY_SOCKET</span><br><span class="line">supervised auto    - detect upstart or systemd method based on</span><br><span class="line">                    UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line">Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line">   They do not enable continuous pings back to your supervisor.</span><br><span class="line">supervised no</span><br></pre></td></tr></table></figure>
<p>如果你使用系统的<code>upstart</code>或者<code>systemd</code>运行redis。他们可以管理监控redis。默认不启用</p>
<p>参数</p>
<p>supervised no： - no supervision interaction（无监督-无监督互动）</p>
<p>supervised upstart - 监督upstart-通过将Redis置于SIGSTOP模式来发出upstart信号在upstart作业配置中需要“expect stop”</p>
<p>supervised systemd - 受监控的systemd-通过写入READY=1到$NOTIFY\u SOCKET发送信号systemd</p>
<p>supervised auto - 基于upstart\u JOB或NOTIFY\u SOCKET环境变量检测upstart或systemd方法</p>
<blockquote>
<p>注意：这些监督方法仅表示“过程准备就绪”，它们不支持连续ping返回到您的主管。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line">and removes it at exit.</span><br><span class="line"></span><br><span class="line">When the server runs non daemonized, no pid file is created if none is</span><br><span class="line">specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line">is used even if not specified, defaulting to &quot;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;redis.pid&quot;.</span><br><span class="line"></span><br><span class="line">Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line">nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br></pre></td></tr></table></figure>
<p>　pidfile: 配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Specify the server verbosity level.</span><br><span class="line">This can be one of:</span><br><span class="line">debug (a lot of information, useful for development&#x2F;testing)</span><br><span class="line">verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line">notice (moderately verbose, what you want in production probably)</span><br><span class="line">warning (only very important &#x2F; critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">Specify the log file name. Also the empty string can be used to force</span><br><span class="line">Redis to log on the standard output. Note that if you use standard</span><br><span class="line">output for logging but daemonize, logs will be sent to &#x2F;dev&#x2F;null</span><br><span class="line">logfile &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>　loglevel ：定义日志级别。默认值为notice，有如下4种取值：</p>
<blockquote>
<p>debug（大量信息，对开发/测试有用）</p>
<p>verbose（许多很少有用的信息，但不像调试级别那样混乱）</p>
<p>notice（适度冗长，可能是生产中需要的内容）</p>
<p>warning（只记录非常重要/关键的消息）</p>
</blockquote>
<p>logfile ：配置log文件地址,默认打印在命令行终端的窗口上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">To enable logging to the system logger, just set &#39;syslog-enabled&#39; to yes,</span><br><span class="line">and optionally update the other syslog parameters to suit your needs.</span><br><span class="line">syslog-enabled no</span><br><span class="line"></span><br><span class="line">Specify the syslog identity.</span><br><span class="line">syslog-ident redis</span><br><span class="line"></span><br><span class="line">Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line">syslog-facility local0</span><br><span class="line"></span><br><span class="line">Set the number of databases. The default database is DB 0, you can select</span><br><span class="line">a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line">dbid is a number between 0 and &#39;databases&#39;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>
<p>databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是 16，也就是说默认Redis有16个数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line">standard output and if the standard output is a TTY. Basically this means</span><br><span class="line">that normally a logo is displayed only in interactive sessions.</span><br><span class="line"></span><br><span class="line">However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line">ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br></pre></td></tr></table></figure>
<h2 id="SNAPSHOTTING（快照，重要！！！）"><a href="#SNAPSHOTTING（快照，重要！！！）" class="headerlink" title="SNAPSHOTTING（快照，重要！！！）"></a>SNAPSHOTTING（快照，重要！！！）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Save the DB on disk:</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">Will save the DB if both the given number of seconds and the given</span><br><span class="line">number of write operations against the DB occurred.</span><br><span class="line"></span><br><span class="line">In the example below the behavior will be to save:</span><br><span class="line">after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">after 60 sec if at least 10000 keys changed</span><br><span class="line"></span><br><span class="line">Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line"></span><br><span class="line">It is also possible to remove all the previously configured save</span><br><span class="line">points by adding a save directive with a single empty string argument</span><br><span class="line">like in the following example:</span><br><span class="line"></span><br><span class="line">save &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>save 900 1<br>save 300 10<br>save 60 10000</p>
<p>save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"> (at least one save point) and the latest background save failed.</span><br><span class="line"> This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"> on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"> disaster will happen.</span><br><span class="line"> </span><br><span class="line">  If the background saving process will start working again Redis will</span><br><span class="line"> automatically allow writes again.</span><br><span class="line"> </span><br><span class="line">  However if you have setup your proper monitoring of the Redis server</span><br><span class="line"> and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"> continue to work as usual even if there are problems with disk,</span><br><span class="line"> permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果启用RDB快照，Redis将停止接受写操作</p>
<p>（至少一个保存点）和最新的后台保存失败。</p>
<p>这将使用户意识到（以一种困难的方式）数据没有持久化</p>
<p>在磁盘上正确，否则很可能没有人会注意到和一些</p>
<p>灾难就会发生。</p>
<p>如果后台保存过程将重新开始工作，Redis将自动允许再次写入。但是，如果您已经设置了对Redis服务器的适当监视</p>
<p>和持久性，您可能希望禁用此功能，以便Redis</p>
<p>即使磁盘、权限等出现问题，也要继续正常工作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compress string objects using LZF when dump .rdb databases?</span><br><span class="line">By default compression is enabled as it&#39;s almost always a win.</span><br><span class="line">If you want to save some CPU in the saving child set it to &#39;no&#39; but</span><br><span class="line">the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>
<p>转储.rdb数据库时使用LZF压缩字符串对象？</p>
<p>默认情况下，压缩是启用的，因为它几乎总是一个胜利。</p>
<p>如果您想在保存子进程中保存一些CPU，请将其设置为“否”，但是</p>
<p>如果有可压缩的值或键，数据集可能会更大。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line">This makes the format more resistant to corruption but there is a performance</span><br><span class="line">hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line">for maximum performances.</span><br><span class="line"></span><br><span class="line">RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line">tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">由于RDB版本5，CRC64校验和放在文件的末尾。这使格式更能抵抗损坏，但在保存和加载RDB文件时，性能会受到影响（约10%），因此可以禁用它以获得最大性能。在禁用校验和的情况下创建的RDB文件的校验和为零，这将告诉加载代码跳过检查。</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">将数据库转储到的文件名</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Remove RDB files used by replication in instances without persistence</span><br><span class="line">enabled. By default this option is disabled, however there are environments</span><br><span class="line">where for regulations or other security concerns, RDB files persisted on</span><br><span class="line">disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="line">in order to load them for the initial synchronization, should be deleted</span><br><span class="line">ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="line">and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="line"></span><br><span class="line">An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="line">to use diskless replication on both master and replicas instances. However</span><br><span class="line">in the case of replicas, diskless is not always an option.</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line">The working directory.</span><br><span class="line"></span><br><span class="line">The DB will be written inside this directory, with the filename specified</span><br><span class="line">above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line"></span><br><span class="line">The Append Only File will also be created inside this directory.</span><br><span class="line"></span><br><span class="line">Note that you must specify a directory here, not a file name.</span><br><span class="line"></span><br><span class="line">dir /usr/local/var/db/redis/</span><br><span class="line"></span><br><span class="line">在没有持久性的实例中删除复制使用的RDB文件启用。默认情况下，此选项处于禁用状态，但是在某些环境中，出于管理法规或其他安全考虑，应尽快删除由主服务器保留在磁盘上以馈送副本的RDB文件，或由副本存储在磁盘上以加载它们以进行初始同步。请注意，此选项仅适用于同时禁用AOF和RDB持久性的实例，否则将完全忽略。</span><br><span class="line">另一种（有时更好）获得相同效果的方法是在主实例和副本实例上使用无盘复制。但是，对于副本，无磁盘并不是一种好的选择。</span><br><span class="line">rdb del同步文件编号</span><br><span class="line">工作目录。</span><br><span class="line">数据库将被写入这个目录，并指定文件名</span><br><span class="line">使用“dbfilename”配置指令。</span><br><span class="line">只附加的文件也将在这个目录中创建。</span><br><span class="line">请注意，必须在此处指定目录，而不是文件名。</span><br></pre></td></tr></table></figure>
<p>　dbfilename ：设置快照的文件名，默认是 dump.rdb</p>
<p>　　⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</p>
<h2 id="REPLICATION（主从复制）"><a href="#REPLICATION（主从复制）" class="headerlink" title="REPLICATION（主从复制）"></a>REPLICATION（主从复制）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">REPLICATION </span><br><span class="line"></span><br><span class="line">Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="line">another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line"></span><br><span class="line">+------------------+      +---------------+</span><br><span class="line">|      Master      | ---&gt; |    Replica    |</span><br><span class="line">| (receive writes) |      |  (exact copy) |</span><br><span class="line">+------------------+      +---------------+</span><br><span class="line"></span><br><span class="line">1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">stop accepting writes if it appears to be not connected with at least</span><br><span class="line">a given number of replicas.</span><br><span class="line"><span class="comment"># Redis复制是异步的，但是您可以配置一个主机，如果它看起来没有连接到至少给定数量的副本，那么它就停止接受写操作。</span></span><br><span class="line">2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="line">master if the replication link is lost for a relatively small amount of</span><br><span class="line">time. You may want to configure the replication backlog size (see the next</span><br><span class="line">sections of this file) with a sensible value depending on your needs.</span><br><span class="line"><span class="comment"># 如果复制链路丢失的时间相对较短，Redis复制副本可以执行与主机的部分重新同步。您可能需要根据需要使用合理的值来配置复制积压工作大小（请参阅本文件的下一节）。</span></span><br><span class="line">3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">network partition replicas automatically try to reconnect to masters</span><br><span class="line">and resynchronize with them.</span><br><span class="line"><span class="comment"># 复制是自动的，不需要用户干预。在网络分区之后，复制副本会自动尝试重新连接到主机并与它们重新同步。</span></span><br><span class="line"></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line">directive below) it is possible to tell the replica to authenticate before</span><br><span class="line">starting the replication synchronization process, otherwise the master will</span><br><span class="line">refuse the replica request.</span><br><span class="line"><span class="comment"># 如果主机受密码保护（使用下面的“requirepass”配置指令），则可以在启动复制同步过程之前通知复制副本进行身份验证，否则主机将拒绝副本请求。</span></span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="line">6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="line">command and/or other commands needed for replication. In this case it&#x27;s</span><br><span class="line">better to configure a special user to use with replication, and specify the</span><br><span class="line">masteruser configuration as such:</span><br><span class="line"><span class="comment"># 但是，如果您正在使用Redis ACL（用于Redis版本6或更高版本），并且默认用户无法运行PSYNC命令和/或其他复制所需的命令，这还不够。在这种情况下，最好配置一个特殊用户以用于复制</span></span><br><span class="line">masteruser &lt;username&gt;</span><br><span class="line"></span><br><span class="line">When masteruser is specified, the replica will authenticate against its</span><br><span class="line">master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><span class="line"><span class="comment"># 指定masteruser时，副本将使用新的AUTH表单针对其主服务器进行身份验证</span></span><br><span class="line">When a replica loses its connection with the master, or when the replication</span><br><span class="line">is still in progress, the replica can act in two different ways:</span><br><span class="line"><span class="comment"># 当副本失去与主数据库的连接时，或者仍在进行复制时，副本可以采取两种不同的方式进行操作</span></span><br><span class="line">1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="line">still reply to client requests, possibly with out of date data, or the</span><br><span class="line">data set may just be empty if this is the first synchronization.</span><br><span class="line"><span class="comment"># 如果复制副本服务过时数据设置为“是”（默认值），则复制副本仍将回复客户端请求，可能包含过期数据，或者如果这是第一次同步，则数据集可能只是空的。</span></span><br><span class="line">2) If replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="line">an error &quot;SYNC with master in progress&quot; to all commands except:</span><br><span class="line">INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,</span><br><span class="line">UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,</span><br><span class="line">HOST and LATENCY.</span><br><span class="line"><span class="comment"># 如果将replica-serve-stale-data设置为“ no”，则该副本将对所有命令（“ INFO，REPLICAOF，AUTH，PING，SHUTDOWN，REPLCONF，ROLE，CONFIG，SUBSCRIBE）进行错误答复” ，退订，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，COMMAND，POST，HOST和LATENCY。</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">You can configure a replica instance to accept writes or not. Writing against</span><br><span class="line">a replica instance may be useful to store some ephemeral data (because data</span><br><span class="line">written on a replica will be easily deleted after resync with the master) but</span><br><span class="line">may also cause problems if clients are writing to it because of a</span><br><span class="line">misconfiguration.</span><br><span class="line"><span class="comment"># 您可以配置副本实例以接受或不接受写入。针对副本实例进行写操作可能对存储一些临时数据很有用（因为与主实例重新同步后，写入副本上的数据将很容易删除），但是如果客户端由于配置错误而向其进行写操作，也会导致问题。</span></span><br><span class="line">Since Redis 2.6 by default replicas are read-only.</span><br><span class="line"></span><br><span class="line">Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="line">on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="line">Still a read only replica exports by default all the administrative commands</span><br><span class="line">such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line">security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="line">administrative / dangerous commands.</span><br><span class="line"><span class="comment"># 只读副本并非旨在向Internet上不受信任的客户端公开。它只是防止实例滥用的保护层。默认情况下，只读副本仍会导出所有管理命令，例如CONFIG，DEBUG等。在一定程度上，您可以使用&#x27;rename-command&#x27;隐藏所有管理危险命令来提高只读副本的安全性</span></span><br><span class="line">replica-read-only yes</span><br><span class="line">Replication SYNC strategy: disk or socket.</span><br><span class="line"></span><br><span class="line">New replicas and reconnecting replicas that are not able to continue the</span><br><span class="line">replication process just receiving differences, need to do what is called a</span><br><span class="line">&quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span><br><span class="line">replicas.</span><br><span class="line"><span class="comment"># 仅仅接受差异就无法继续复制过程的新副本和重新连接的副本需要进行所谓的“完全同步”。 RDB文件从主数据库传输到副本数据库</span></span><br><span class="line">The transmission can happen in two different ways:</span><br><span class="line"></span><br><span class="line">1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line">             file on disk. Later the file is transferred by the parent</span><br><span class="line">             process to the replicas incrementally.</span><br><span class="line">2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line">          RDB file to replica sockets, without touching the disk at all.</span><br><span class="line"></span><br><span class="line">With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="line">can be queued and served with the RDB file as soon as the current child</span><br><span class="line">producing the RDB file finishes its work. With diskless replication instead</span><br><span class="line">once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="line">transfer will start when the current one terminates.</span><br><span class="line"><span class="comment"># 使用磁盘支持的复制，当生成RDB文件时，只要生成RDB文件的当前子级完成工作，就可以将更多副本排入队列并与RDB文件一起使用。如果使用无盘复制，则一旦传输开始，新的副本将排队，并且当当前副本终止时将开始新的传输</span></span><br><span class="line">When diskless replication is used, the master waits a configurable amount of</span><br><span class="line">time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="line">replicas will arrive and the transfer can be parallelized.</span><br><span class="line"><span class="comment"># 使用无盘复制时，主服务器在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本可以到达并且传输可以并行化</span></span><br><span class="line">With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line">works better.</span><br><span class="line"><span class="comment"># 对于慢速磁盘和快速（大带宽）网络，无盘复制效果更好</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line">When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line">the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line">to the replicas.</span><br><span class="line"><span class="comment"># 启用无盘复制后，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到副本的子代。</span></span><br><span class="line">This is important since once the transfer starts, it is not possible to serve</span><br><span class="line">new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="line">server waits a delay in order to let more replicas arrive.</span><br><span class="line"><span class="comment"># 这一点很重要，因为一旦传输开始，就无法为到达下一个RDB传输的新副本提供服务，因此服务器会等待一段时间才能让更多副本到达。</span></span><br><span class="line">The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line">it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line"><span class="comment"># 延迟以秒为单位指定，默认情况下为5秒。要完全禁用它，只需将其设置为0秒，传输就会尽快开始。</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="line">does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="line">failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="line">cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="line">stage with the master. Use only if your do what you are doing.</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 警告：RDB无盘加载是实验性的。因为在此设置中，副本不会立即在磁盘上存储RDB，所以它可能会导致故障转移期间的数据丢失。在与主机的初始同步阶段，如果IO错误，则RDB无盘负载+ Redis模块不处理IO读取也可能导致Redis中止。仅在执行自己的操作时使用</span></span><br><span class="line">Replica can load the RDB it reads from the replication link directly from the</span><br><span class="line">socket, or store the RDB to a file and read that file after it was completely</span><br><span class="line">received from the master.</span><br><span class="line"><span class="comment"># 副本可以直接从套接字加载从复制链接读取的RDB，也可以将RDB存储到文件中，并在从主服务器完全接收到该文件后读取该文件。</span></span><br><span class="line">In many cases the disk is slower than the network, and storing and loading</span><br><span class="line">the RDB file may increase replication time (and even increase the master&#x27;s</span><br><span class="line">Copy on Write memory and salve buffers).</span><br><span class="line">However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="line">to flush the contents of the current database before the full rdb was</span><br><span class="line">received. For this reason we have the following options:</span><br><span class="line"><span class="comment"># 在许多情况下，磁盘的速度比网络慢，并且存储和加载RDB文件可能会增加复制时间（甚至会增加主服务器的“写时复制”内存和从属缓冲区）。但是，直接从套接字解析RDB文件可能意味着我们必须在收到完整的rdb之前刷新当前数据库的内容。因此，我们有以下选择</span></span><br><span class="line">&quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span><br><span class="line"><span class="comment"># 不要使用无盘负载（首先将rdb文件存储到磁盘）</span></span><br><span class="line">&quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span><br><span class="line"><span class="comment"># 仅在完全安全的情况下使用无盘加载</span></span><br><span class="line">&quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsin </span><br><span class="line">the data directly from the socket. note that this requires sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span><br><span class="line"><span class="comment"># 直接从套接字解析数据时，将当前数据库内容的副本保留在RAM中。请注意，这需要足够的内存，如果没有足够的内存，则可能会杀死OOM</span></span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line">Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span><br><span class="line">change this interval with the repl_ping_replica_period option. The default</span><br><span class="line">value is 10 seconds.</span><br><span class="line"><span class="comment"># 副本以预定义的时间间隔将PING发送到服务器。可以使用repl_ping_replica_period选项更改此间隔。默认值为10秒</span></span><br><span class="line">repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line">The following option sets the replication timeout for:</span><br><span class="line"><span class="comment"># 以下选项设置了复制超时</span></span><br><span class="line">1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="line"><span class="comment"># 从副本的角度来看，在SYNC期间进行批量传输IO。</span></span><br><span class="line">2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="line"><span class="comment"># 从副本（数据，ping）的角度来看主超时</span></span><br><span class="line">3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line"><span class="comment"># 从主服务器角度来看副本超时（REPLCONF ACK ping）</span></span><br><span class="line">It is important to make sure that this value is greater than the value</span><br><span class="line">specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="line">every time there is low traffic between the master and the replica. The default</span><br><span class="line">value is 60 seconds.</span><br><span class="line"><span class="comment"># 重要的是要确保该值大于为repl-ping-replica-period指定的值，否则，每当主机和副本之间的通信量较低时，就会检测到超时。默认值为60秒。</span></span><br><span class="line">repl-timeout 60</span><br><span class="line"></span><br><span class="line">Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="line"><span class="comment"># 同步后在副本套接字上禁用TCP_NODELAY</span></span><br><span class="line"></span><br><span class="line">If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="line">less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="line">the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="line">Linux kernels using a default configuration.</span><br><span class="line"><span class="comment"># 如果选择“是”，则Redis将使用更少的TCP数据包和更少的带宽将数据发送到副本。但这会增加数据在副本端显示的延迟，对于使用默认配置的Linux内核，此延迟最多40毫秒</span></span><br><span class="line">If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="line">be reduced but more bandwidth will be used for replication.</span><br><span class="line"><span class="comment"># 如果选择“否”，则将减少数据在副本侧出现的延迟，但将使用更多带宽进行复制</span></span><br><span class="line">By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line">or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="line">be a good idea.</span><br><span class="line"><span class="comment"># 默认情况下，我们会针对低延迟进行优化，但是在流量非常高的情况下，或者当主服务器和副本距离很多跳时，将其设置为“是”可能是个好主意</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line">replica data when replicas are disconnected for some time, so that when a</span><br><span class="line">replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="line">partial resync is enough, just passing the portion of data the replica</span><br><span class="line">missed while disconnected.</span><br><span class="line"><span class="comment"># 设置复制积压大小。待办事项是一个缓冲区，当副本断开连接一段时间后，该缓冲区将累积副本数据，因此，当副本要重新连接时，通常不需要完全重新同步，但是部分重新同步就足够了，只需传递副本中的部分数据断开连接时错过</span></span><br><span class="line">The bigger the replication backlog, the longer the replica can endure the</span><br><span class="line">disconnect and later be able to perform a partial resynchronization.</span><br><span class="line"><span class="comment"># 复制积压量越大，副本可以承受断开连接并随后能够执行部分重新同步的时间越长</span></span><br><span class="line">The backlog is only allocated if there is at least one replica connected.</span><br><span class="line"><span class="comment"># 仅在连接至少一个副本时分配积压</span></span><br><span class="line">repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line">After a master has no connected replicas for some time, the backlog will be</span><br><span class="line">freed. The following option configures the amount of seconds that need to</span><br><span class="line">elapse, starting from the time the last replica disconnected, for the backlog</span><br><span class="line">buffer to be freed.</span><br><span class="line"><span class="comment"># 主服务器在一段时间内没有连接的副本后，积压的订单将被释放。以下选项配置了从断开最后一个副本的时间开始，释放待办事项缓冲区所需的秒数</span></span><br><span class="line">Note that replicas never free the backlog for timeout, since they may be</span><br><span class="line">promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="line">resynchronize&quot; with other replicas: hence they should always accumulate backlog.</span><br><span class="line"><span class="comment"># 请注意，副本永远不会释放积压的超时，因为它们可能稍后会升级为主副本，并且应该能够与其他副本正确“部分重新同步”：因此，它们应始终累积积压。</span></span><br><span class="line">A value of 0 means to never release the backlog.</span><br><span class="line"><span class="comment"># 值为0表示永不释放积压</span></span><br><span class="line">repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">The replica priority is an integer number published by Redis in the INFO</span><br><span class="line">output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="line">into a master if the master is no longer working correctly.</span><br><span class="line"><span class="comment"># 副本优先级是Redis在INFO输出中发布的整数。如果主服务器不再正常工作，Redis Sentinel会使用它来选择要升级为主服务器的副本</span></span><br><span class="line">A replica with a low priority number is considered better for promotion, so</span><br><span class="line">for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="line">will pick the one with priority 10, that is the lowest.</span><br><span class="line"><span class="comment"># 优先级数字低的副本被认为更适合升级，例如，如果有三个副本的优先级分别为10、100和25，Sentinel将选择优先级为10的副本，这是最低的</span></span><br><span class="line">However a special priority of 0 marks the replica as not able to perform the</span><br><span class="line">role of master, so a replica with priority of 0 will never be selected by</span><br><span class="line">Redis Sentinel for promotion.</span><br><span class="line"><span class="comment"># 但是，特殊优先级0会将副本标记为不能执行主角色，因此Redis Sentinel永远不会选择优先级为0的副本进行升级，默认情况下，优先级为100</span></span><br><span class="line">By default the priority is 100.</span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line">It is possible for a master to stop accepting writes if there are less than</span><br><span class="line">N replicas connected, having a lag less or equal than M seconds.</span><br><span class="line"><span class="comment"># 如果连接的副本少于N个，且延迟小于或等于M秒，则主服务器可能会停止接受写入</span></span><br><span class="line">The N replicas need to be in &quot;online&quot; state.</span><br><span class="line"><span class="comment"># N个副本需要处于“联机”状态</span></span><br><span class="line">The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="line">the last ping received from the replica, that is usually sent every second.</span><br><span class="line"><span class="comment"># 延迟（以秒为单位）必须小于等于指定值，该延迟是从副本接收到的最后一次ping计算得出的，通常每秒钟发送一次</span></span><br><span class="line">This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line">will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="line">are available, to the specified number of seconds.</span><br><span class="line"><span class="comment"># 此选项不能保证N个副本将接受写操作，但是如果没有足够的副本可用，则会将丢失写操作的暴露窗口限制为指定的秒数</span></span><br><span class="line">For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="line"><span class="comment"># 例如，要求至少3个副本的延迟&lt;= 10秒，请使用</span></span><br><span class="line">min-replicas-to-write 3</span><br><span class="line">min-replicas-max-lag 10</span><br><span class="line"></span><br><span class="line">Setting one or the other to 0 disables the feature.</span><br><span class="line"><span class="comment"># 将一个或另一个设置为0将禁用该功能</span></span><br><span class="line">By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="line">min-replicas-max-lag is set to 10.</span><br><span class="line"><span class="comment"># 默认情况下，将要写入的最小副本设置为0（禁用功能），并且将最小副本最大延迟设置为10</span></span><br><span class="line">A Redis master is able to list the address and port of the attached</span><br><span class="line">replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="line">offers this information, which is used, among other tools, by</span><br><span class="line">Redis Sentinel in order to discover replica instances.</span><br><span class="line">Another place where this info is available is in the output of the</span><br><span class="line">&quot;ROLE&quot; command of a master.</span><br><span class="line"><span class="comment"># Redis主服务器能够以不同方式列出附加副本的地址和端口。例如，“ INFO复制”部分提供了此信息，Redis Sentinel使用此信息以及其他工具来发现副本实例。该信息可用的另一个位置是主服务器的“ ROLE”命令的输出</span></span><br><span class="line">The listed IP address and port normally reported by a replica is</span><br><span class="line">obtained in the following way:</span><br><span class="line"><span class="comment"># 副本通常报告的列出的IP地址和端口可以通过以下方式获得</span></span><br><span class="line">IP: The address is auto detected by checking the peer address</span><br><span class="line">of the socket used by the replica to connect with the master.</span><br><span class="line"><span class="comment"># IP：通过检查副本用来与主服务器连接的套接字的对等地址来自动检测该地址</span></span><br><span class="line">Port: The port is communicated by the replica during the replication</span><br><span class="line">handshake, and is normally the port that the replica is using to</span><br><span class="line">listen for connections.</span><br><span class="line"><span class="comment"># 端口：端口在复制握手期间由副本进行通信，通常是副本用来侦听连接的端口。</span></span><br><span class="line">However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line">used, the replica may actually be reachable via different IP and port</span><br><span class="line">pairs. The following two options can be used by a replica in order to</span><br><span class="line">report to its master a specific set of IP and port, so that both INFO</span><br><span class="line">and ROLE will report those values.</span><br><span class="line"><span class="comment"># 但是，当使用端口转发或网络地址转换（NAT）时，实际上可以通过不同的IP和端口对访问该副本。副本可以使用以下两个选项，以便向其主服务器报告特定的IP和端口集，以便INFO和ROLE都将报告这些值</span></span><br><span class="line">There is no need to use both the options if you need to override just</span><br><span class="line">the port or the IP address.</span><br><span class="line"><span class="comment"># 如果只需要覆盖端口或IP地址，则无需使用这两个选项。</span></span><br><span class="line">replica-announce-ip 5.5.5.5</span><br><span class="line">replica-announce-port 1234</span><br></pre></td></tr></table></figure>
<p>①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现：</p>
<p>　　　　1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候 </p>
<p>　　　　2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 “SYNC with master in progress” 的错误</p>
<p>②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。</p>
<p>③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。</p>
<p>④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。 这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段 时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。</p>
<p>⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。 Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。</p>
<h2 id="KEYS-TRACKING"><a href="#KEYS-TRACKING" class="headerlink" title="KEYS TRACKING"></a>KEYS TRACKING</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">KEYS TRACKING </span><br><span class="line"><span class="comment"># Redis为客户端的值缓存实现服务器辅助的支持。这是使用无效表实现的，该无效表使用1600万个插槽记住哪些客户端可能具有某些键子集。依次将其用于向客户端发送无效消息</span></span><br><span class="line">Redis implements server assisted support for client side caching of values.</span><br><span class="line">This is implemented using an invalidation table that remembers, using</span><br><span class="line">16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="line">this is used in order to send invalidation messages to clients. Please</span><br><span class="line">check this page to understand more about the feature:</span><br><span class="line"></span><br><span class="line">https://redis.io/topics/client-side-caching</span><br><span class="line"></span><br><span class="line">When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="line">to be cached: this will force Redis to store information in the invalidation</span><br><span class="line">table. When keys are modified, such information is flushed away, and</span><br><span class="line">invalidation messages are sent to the clients. However if the workload is</span><br><span class="line">heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="line">to track the keys fetched by many clients.</span><br><span class="line"><span class="comment"># 为客户端启用跟踪时，假定所有只读查询都已缓存：这将强制Redis将信息存储在失效表中。修改密钥后，将清除此类信息，并将无效消息发送给客户端。但是，如果工作负载主要由读取控制，则Redis可能会使用越来越多的内存来跟踪许多客户端获取的密钥</span></span><br><span class="line">For this reason it is possible to configure a maximum fill value for the</span><br><span class="line">invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="line">is reached, Redis will start to evict keys in the invalidation table</span><br><span class="line">even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="line">force the clients to invalidate the cached values. Basically the table</span><br><span class="line">maximum size is a trade off between the memory you want to spend server</span><br><span class="line">side to track information about who cached what, and the ability of clients</span><br><span class="line">to retain cached objects in memory.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将值设置为0，则表示没有限制，Redis将在失效表中保留所需数量的键。在“统计信息”信息部分中，您可以找到有关每个给定时刻失效表中的键数的信息。</span></span><br><span class="line">If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="line">retain as many keys as needed in the invalidation table.</span><br><span class="line">In the &quot;stats&quot; INFO section, you can find information about the number of</span><br><span class="line">keys in the invalidation table at every given moment.</span><br><span class="line"></span><br><span class="line">Note: when key tracking is used in broadcasting mode, no memory is used</span><br><span class="line">in the server side so this setting is useless.</span><br><span class="line"></span><br><span class="line">tracking-table-max-keys 1000000</span><br></pre></td></tr></table></figure>
<h2 id="SECURITY-重要"><a href="#SECURITY-重要" class="headerlink" title="SECURITY(重要)"></a>SECURITY(重要)</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">SECURITY </span><br><span class="line"></span><br><span class="line">Warning: since Redis is pretty fast, an outside user can try up to</span><br><span class="line">1 million passwords per second against a modern box. This means that you</span><br><span class="line">should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="line">Note that because the password is really a shared secret between the client</span><br><span class="line">and the server, and should not be memorized by any human, the password</span><br><span class="line">can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="line">long and unguessable password no brute force attack will be possible.</span><br><span class="line"><span class="comment"># 警告：由于Redis的速度非常快，因此外部用户每秒可以在一个现代机器上尝试最多100万个密码。这意味着您应该使用非常安全的密码，否则密码很容易破解。</span></span><br><span class="line"><span class="comment"># 请注意，由于该密码实际上是客户端和服务器之间的共享机密，并且不应被任何人记住，因此该密码可以很容易地是来自devurandom或其他任何形式的长字符串，因此使用长而毫无疑问的密码不会造成暴力攻击是可能的</span></span><br><span class="line">Redis ACL users are defined in the following format:</span><br><span class="line"></span><br><span class="line">user &lt;username&gt; ... acl rules ...</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line"></span><br><span class="line">user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="line"></span><br><span class="line">The special username &quot;default&quot; is used for new connections. If this user</span><br><span class="line">has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span><br><span class="line">as the &quot;default&quot; user without the need of any password provided via the</span><br><span class="line">AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span><br><span class="line">the connections will start in not authenticated state, and will require</span><br><span class="line">AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="line">start to work.</span><br><span class="line"><span class="comment"># 特殊的用户名“默认”用于新连接。如果该用户具有“ nopass”规则，则新连接将立即被认证为“默认”用户，而不需要通过AUTH命令提供的任何密码。否则，如果未将“默认”用户标记为“ nopass”，则连接将以未认证状态启动，并且需要AUTH（或HELLO命令AUTH选项）才能进行认证并开始工作</span></span><br><span class="line">The ACL rules that describe what a user can do are the following:</span><br><span class="line"></span><br><span class="line">on           Enable the user: it is possible to authenticate as this user.</span><br><span class="line">off          Disable the user: it&#x27;s no longer possible to authenticate</span><br><span class="line">           with this user, however the already authenticated connections</span><br><span class="line">           will still work.</span><br><span class="line">+&lt;command&gt;   Allow the execution of that command</span><br><span class="line">-&lt;command&gt;   Disallow the execution of that command</span><br><span class="line">+@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="line">           with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="line">           and so forth, see the full list in the server.c file where</span><br><span class="line">           the Redis command table is described and defined.</span><br><span class="line">           The special category @all means all the commands, but currently</span><br><span class="line">           present in the server, and that will be loaded in the future</span><br><span class="line">           via modules.</span><br><span class="line">+&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="line">                       disabled command. Note that this form is not</span><br><span class="line">                       allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="line">                       only additive starting with &quot;+&quot;.</span><br><span class="line">allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="line">           all the future commands loaded via the modules system.</span><br><span class="line">nocommands   Alias for -@all.</span><br><span class="line">~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="line">           commands. For instance ~* allows all the keys. The pattern</span><br><span class="line">           is a glob-style pattern like the one of KEYS.</span><br><span class="line">           It is possible to specify multiple patterns.</span><br><span class="line">allkeys      Alias for ~*</span><br><span class="line">resetkeys    Flush the list of allowed keys patterns.</span><br><span class="line">&gt;&lt;password&gt;  Add this password to the list of valid password for the user.</span><br><span class="line">           For example &gt;mypass will add &quot;mypass&quot; to the list.</span><br><span class="line">           This directive clears the &quot;nopass&quot; flag (see later).</span><br><span class="line">&lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="line">nopass       All the set passwords of the user are removed, and the user</span><br><span class="line">           is flagged as requiring no password: it means that every</span><br><span class="line">           password will work against this user. If this directive is</span><br><span class="line">           used for the default user, every new connection will be</span><br><span class="line">           immediately authenticated with the default user without</span><br><span class="line">           any explicit AUTH command required. Note that the &quot;resetpass&quot;</span><br><span class="line">           directive will clear this condition.</span><br><span class="line">resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="line">           &quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span><br><span class="line">           passwords and there is no way to authenticate without adding</span><br><span class="line">           some password (or setting it as &quot;nopass&quot; later).</span><br><span class="line">reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="line">           -@all. The user returns to the same state it has immediately</span><br><span class="line">           after its creation.</span><br><span class="line"></span><br><span class="line">ACL rules can be specified in any order: for instance you can start with</span><br><span class="line">passwords, then flags, or key patterns. However note that the additive</span><br><span class="line">and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="line">For instance see the following example:</span><br><span class="line"></span><br><span class="line">user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="line"></span><br><span class="line">This will allow &quot;alice&quot; to use all the commands with the exception of the</span><br><span class="line">DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="line">alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="line">of two ACL rules the result will be different:</span><br><span class="line"><span class="comment"># 这将允许“ alice”使用除DEBUG命令之外的所有命令，因为+ @ all将所有命令添加到了alice可以使用的命令集中，并且后来删除了DEBUG。但是，如果我们颠倒两个ACL规则的顺序，结果将有所不同</span></span><br><span class="line">user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="line"></span><br><span class="line">Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="line">commands, later all the commands are added, so the user will be able to</span><br><span class="line">execute everything.</span><br><span class="line"></span><br><span class="line">Basically ACL rules are processed left-to-right.</span><br><span class="line"></span><br><span class="line">For more information about ACL configuration please refer to</span><br><span class="line">the Redis web site at https://redis.io/topics/acl</span><br><span class="line"></span><br><span class="line">ACL LOG</span><br><span class="line"></span><br><span class="line">The ACL Log tracks failed commands and authentication events associated</span><br><span class="line">with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="line">by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="line">ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="line">acllog-max-len 128</span><br><span class="line"><span class="comment"># ACL日志跟踪与ACL关联的失败命令和身份验证事件。 ACL日志可用于对ACL阻止的失败命令进行故障排除。 ACL日志存储在内存中。您可以使用ACL LOG RESET回收内存。在下面定义ACL日志的最大输入长度。 acllog-max-len 128</span></span><br><span class="line">Using an external ACL file</span><br><span class="line"></span><br><span class="line">Instead of configuring users here in this file, it is possible to use</span><br><span class="line">a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="line">if you configure users here and at the same time you activate the external</span><br><span class="line">ACL file, the server will refuse to start.</span><br><span class="line"><span class="comment"># 除了在此文件中配置用户之外，还可以使用仅列出用户的独立文件。两种方法不能混用：如果您在此处配置用户并同时激活外部ACL文件，则服务器将拒绝启动</span></span><br><span class="line">The format of the external ACL user file is exactly the same as the</span><br><span class="line">format that is used inside redis.conf to describe users.</span><br><span class="line"></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTE: starting with Redis 6 &quot;requirepass&quot; is just a compatibility</span><br><span class="line">layer on top of the new ACL system. The option effect will be just setting</span><br><span class="line">the password for the default user. Clients will still authenticate using</span><br><span class="line">AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="line">if they follow the new protocol: both will work.</span><br><span class="line"><span class="comment"># 重要说明：从Redis 6开始，“ requirepass”只是新ACL系统之上的兼容性层。选项效果将只是为默认用户设置密码。客户端仍将照常使用AUTH &lt;password&gt;进行身份验证，如果遵循新协议，则仍将使用AUTH default &lt;password&gt;进行更明确的身份验证</span></span><br><span class="line">requirepass foobared</span><br><span class="line"></span><br><span class="line">Command renaming (DEPRECATED).</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="line">commands from the default user, and put them only in some admin user you</span><br><span class="line">create for administrative purposes.</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 警告：尽可能避免使用此选项。而是使用ACL从默认用户中删除命令，并将其仅放置在您出于管理目的而创建的某些admin用户中</span></span><br><span class="line">It is possible to change the name of dangerous commands in a shared</span><br><span class="line">environment. For instance the CONFIG command may be renamed into something</span><br><span class="line">hard to guess so that it will still be available for internal-use tools</span><br><span class="line">but not available for general clients.</span><br><span class="line"><span class="comment"># 可以在共享环境中更改危险命令的名称。例如，CONFIG命令可能会重命名为一些难以猜测的名称，因此它仍可用于内部使用的工具，但不适用于一般客户</span></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line">It is also possible to completely kill a command by renaming it into</span><br><span class="line">an empty string:</span><br><span class="line"></span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">Please note that changing the name of commands that are logged into the</span><br><span class="line">AOF file or transmitted to replicas may cause problems.</span><br><span class="line"><span class="comment"># 注意，更改登录到AOF文件或传输到副本的命令的名称可能会导致问题</span></span><br></pre></td></tr></table></figure>
<p>rename-command：命令重命名，对于一些危险命令例如：</p>
<ul>
<li><p>flushdb（清空数据库）</p>
</li>
<li><p>flushall（清空所有记录）</p>
</li>
<li><p>config（客户端连接后可配置服务器）</p>
</li>
<li><p>keys（客户端连接后可查看所有存在的键）          </p>
</li>
</ul>
<blockquote>
<p>作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：</p>
<p>rename-command FLUSHALL “”</p>
</blockquote>
<p>也可以保留命令但是不能轻易使用，重命名这个命令即可：</p>
<ul>
<li>rename-command FLUSHALL abcdefg 这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。</li>
</ul>
<p><strong>requirepass:设置redis连接密码</strong></p>
<p>　　比如: requirepass 123456 表示redis的连接密码为123456.</p>
<h2 id="CLIENTS"><a href="#CLIENTS" class="headerlink" title="CLIENTS"></a>CLIENTS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLIENTS </span><br><span class="line"></span><br><span class="line">Set the max number of connected clients at the same time. By default</span><br><span class="line">this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line">able to configure the process file limit to allow for the specified limit</span><br><span class="line">the max number of allowed clients is set to the current file limit</span><br><span class="line">minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line"># 同时设置最大连接客户端数。默认情况下，此限制设置为10000个客户端，但是，如果Redis服务器无法将进程文件限制配置为允许指定的限制，则允许的最大客户端数设置为当前文件限制减去32（因为Redis保留了内部使用的几个文件描述符）</span><br><span class="line">Once the limit is reached Redis will close all the new connections sending</span><br><span class="line">an error &#39;max number of clients reached&#39;.</span><br><span class="line"># 达到限制后，Redis将关闭所有新连接，并发送错误消息“已达到最大客户端数”。</span><br><span class="line">IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="line">shared with the cluster bus: every node in the cluster will use two</span><br><span class="line">connections, one incoming and another outgoing. It is important to size the</span><br><span class="line">limit accordingly in case of very large clusters.</span><br><span class="line"># 重要信息：使用Redis群集时，最大连接数也与群集总线共享：群集中的每个节点将使用两个连接，一个进入，另一个向外。在群集非常大的情况下，相应地调整限制大小非常重要</span><br><span class="line">maxclients 10000</span><br></pre></td></tr></table></figure>
<p>maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。 描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<h2 id="MEMORY-MANAGEMENT"><a href="#MEMORY-MANAGEMENT" class="headerlink" title="MEMORY MANAGEMENT"></a>MEMORY MANAGEMENT</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">MEMORY MANAGEMENT </span><br><span class="line"></span><br><span class="line">Set a memory usage limit to the specified amount of bytes.</span><br><span class="line">When the memory limit is reached Redis will try to remove keys</span><br><span class="line">according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line"><span class="comment"># 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis将尝试根据所选的逐出策略来删除密钥</span></span><br><span class="line">If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="line">set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="line">that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line">to reply to read-only commands like GET.</span><br><span class="line"><span class="comment"># 如果Redis无法根据该策略删除密钥，或者如果该策略设置为&#x27;noeviction&#x27;，则Redis将开始对将使用更多内存的命令（例如SET，LPUSH等）进行错误答复，并将继续回复诸如GET之类的只读命令</span></span><br><span class="line">This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line">set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="line"><span class="comment"># 当将Redis用作LRU或LFU缓存，或为实例设置硬盘限制时，此选项通常很有用</span></span><br><span class="line">WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="line">the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line">from the used memory count, so that network problems / resyncs will</span><br><span class="line">not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line">buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line">of more keys, and so forth until the database is completely emptied.</span><br><span class="line"><span class="comment"># 警告：如果您将副本附加到实例上且maxmemory处于打开状态，则从使用的内存计数中减去提供副本所需的输出缓冲区的大小，以便网络问题重新同步将不会触发逐出密钥的循环。使副本的输出缓冲区已满，其中有被驱逐的键DEL触发了更多键的删除，依此类推，直到数据库完全清空</span></span><br><span class="line">In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line">limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line">output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="line"><span class="comment"># 简而言之...如果您附加了副本，建议您为maxmemory设置一个下限，以便系统上有一些可用的RAM用于副本输出缓冲区（但是如果策略为“ noeviction”，则不需要这样做）</span></span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line">is reached. You can select one from the following behaviors:</span><br><span class="line"><span class="comment"># MAXMEMORY POLICY：达到maxmemory后，Redis将如何选择要删除的内容。您可以从以下行为中选择一种</span></span><br><span class="line">volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line">allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line">volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.    # 使用近似的LRU驱逐，仅使用已过期的密钥</span><br><span class="line">allkeys-lfu -&gt; Evict any key using approximated LFU.                           # 使用近似的LFU退出任何密钥</span><br><span class="line">volatile-random -&gt; Remove a random key having an expire set.                   # 删除具有过期设置的随机密钥</span><br><span class="line">allkeys-random -&gt; Remove a random key, any key.                                # 删除随机密钥，任何密钥</span><br><span class="line">volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)        # 取出最接近到期时间（较小的TTL）的密钥</span><br><span class="line">noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.  # 不驱逐任何东西，仅在写操作时返回错误</span><br><span class="line"></span><br><span class="line">LRU means Least Recently Used       # LRU表示最近最少使用   LFU表示最少使用</span><br><span class="line">LFU means Least Frequently Used</span><br><span class="line"></span><br><span class="line">Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line">randomized algorithms. </span><br><span class="line"><span class="comment"># LRU，LFU和volatile-ttl均使用近似随机算法实现</span></span><br><span class="line"></span><br><span class="line">Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">   operations, when there are no suitable keys for eviction.</span><br><span class="line"></span><br><span class="line">   At the date of writing these commands are: set setnx setex append</span><br><span class="line">   incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">   sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">   zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">   getset mset msetnx exec sort</span><br><span class="line"><span class="comment"># 注意：使用上述任何策略时，如果没有合适的退出键，Redis将在写入操作中返回错误。在撰写本文时，这些命令是：</span></span><br><span class="line"><span class="comment"># set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd interinterstore sunion </span></span><br><span class="line"><span class="comment"># sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby mcrby deby byby</span></span><br><span class="line">The default is:</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line">algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line">accuracy. By default Redis will check five keys and pick the one that was</span><br><span class="line">used least recently, you can change the sample size using the following</span><br><span class="line">configuration directive.</span><br><span class="line"><span class="comment"># LRU，LFU和最小TTL算法不是精确算法，而是近似算法（以节省内存），因此您可以针对速度或准确性进行调整。默认情况下，Redis将检查五个键并选择最近使用最少的键，您可以使用以下配置指令更改样本大小</span></span><br><span class="line">The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line">true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line"><span class="comment"># 默认值为5会产生足够好的结果。 10非常接近真实的LRU，但是会花费更多的CPU。 3更快但不是很准确</span></span><br><span class="line">maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="line">(unless it is promoted to master after a failover or manually). It means</span><br><span class="line">that the eviction of keys will be just handled by the master, sending the</span><br><span class="line">DEL commands to the replica as keys evict in the master side.</span><br><span class="line"><span class="comment"># 从Redis 5开始，默认情况下，副本将忽略其maxmemory设置（除非在故障转移后或手动提升为主副本）。这意味着密钥的移出将仅由主服务器处理，将DEL命令作为副本在主计算机侧逐出，将DEL命令发送到副本</span></span><br><span class="line">This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="line">what you want, however if your replica is writable, or you want the replica</span><br><span class="line">to have a different memory setting, and you are sure all the writes performed</span><br><span class="line">to the replica are idempotent, then you may change this default (but be sure</span><br><span class="line">to understand what you are doing).</span><br><span class="line"><span class="comment"># 此行为可确保主副本和副本始终保持一致，这通常是您想要的，但是，如果副本是可写的，或者您希望副本具有不同的内存设置，并且您确定对副本执行的所有写操作都是幂等的，那么您可以更改此默认设置（但请务必了解您在做什么）</span></span><br><span class="line">Note that since the replica by default does not evict, it may end using more</span><br><span class="line">memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="line">be larger on the replica, or data structures may sometimes take more memory</span><br><span class="line">and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="line">have enough memory to never hit a real out-of-memory condition before the</span><br><span class="line">master hits the configured maxmemory setting.</span><br><span class="line"><span class="comment"># 请注意，由于默认情况下该副本不会退出，因此它可能会结束使用比通过maxmemory设置的内存更多的内存（某些缓冲区在副本上可能会更大，或者数据结构有时会占用更多的内存，依此类推）。因此，请确保您监视副本，并确保副本具有足够的内存，以便在主副本达到配置的最大内存设置之前永远不会遇到真正的内存不足情况</span></span><br><span class="line">replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line">Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="line">found to be expired, and also in background, in what is called the</span><br><span class="line">&quot;active expire key&quot;. The key space is slowly and interactively scanned</span><br><span class="line">looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="line">of keys that are expired and will never be accessed again in a short time.</span><br><span class="line"><span class="comment"># Redis通过两种方式回收过期的密钥：访问时发现这些密钥已过期，以及在后台，称为“活动的过期密钥”。缓慢地，交互地扫描密钥空间，以查找要回收的过期密钥，以便可以释放已过期且不久之后将不再访问的密钥的内存</span></span><br><span class="line">The default effort of the expire cycle will try to avoid having more than</span><br><span class="line">ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="line">more than 25% of total memory and to add latency to the system. However</span><br><span class="line">it is possible to increase the expire &quot;effort&quot; that is normally set to</span><br><span class="line">&quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span><br><span class="line">system will use more CPU, longer cycles (and technically may introduce</span><br><span class="line">more latency), and will tolerate less already expired keys still present</span><br><span class="line">in the system. It&#x27;s a tradeoff between memory, CPU and latency.</span><br><span class="line"><span class="comment"># 到期周期的默认工作将尝试避免在内存中保留超过百分之十的过期密钥，并且将尝试避免消耗超过总内存的25％并增加系统延迟。但是，可以将通常设置为“ 1”的过期“努力”增加到更大的值，直到值“ 10”。系统将以其最大值使用更多的CPU，更长的周期（并且从技术上讲可能会引入更多的延迟），并且将容忍更少的系统中仍然存在的已过期密钥。在内存，CPU和延迟之间进行权衡</span></span><br><span class="line">active-expire-effort 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LRU是Least Recently Used的缩写，即最近最少使用<br>LFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法</p>
</blockquote>
<p>maxmemory：设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。</p>
<p>maxmemory-policy ：当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择：</p>
<p>　　　　1）volatile-lru  利用LRU算法移除设置过过期时间的key </p>
<p>　　　　2）allkeys-lru  利用LRU算法移除任何key </p>
<p>　　　　3）volatile-random 移除设置过过期时间的随机key </p>
<p>　　　　4）allkeys-random 移除随机ke</p>
<p>　　　　5）volatile-ttl  移除即将过期的key(minor TTL) </p>
<p>　　　　6）noeviction noeviction  不移除任何key，只是返回一个写错误 ，默认选项</p>
<p>maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)。随意你可以选择样本大小进行检，redis默认选择5个样本进行检测，你可以通过maxmemory-samples进行设置样本数。</p>
<h2 id="LAZY-FREEING"><a href="#LAZY-FREEING" class="headerlink" title="LAZY FREEING"></a>LAZY FREEING</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">LAZY FREEING </span><br><span class="line"></span><br><span class="line">Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line">deletion of the object. It means that the server stops processing new commands</span><br><span class="line">in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line">way. If the key deleted is associated with a small object, the time needed</span><br><span class="line">in order to execute the DEL command is very small and comparable to most other</span><br><span class="line">O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="line">aggregated value containing millions of elements, the server can block for</span><br><span class="line">a long time (even seconds) in order to complete the operation.</span><br><span class="line"><span class="comment"># Redis有两个删除键的原语。一种称为DEL，它是对象的阻塞删除。这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。如果删除的键与一个小对象相关联，则执行DEL命令所需的时间非常短，可与Redis中的大多数其他O（1）或O（log_N）命令相提并论。但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能会阻塞很长时间（甚至几秒钟）以完成操作</span></span><br><span class="line">For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line">such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line">FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line">are executed in constant time. Another thread will incrementally free the</span><br><span class="line">object in the background as fast as possible.</span><br><span class="line"><span class="comment"># 由于上述原因，Redis还提供了非阻塞删除原语，例如UNLINK（非阻塞DEL）以及FLUSHALL和FLUSHDB命令的ASYNC选项，以便在后台回收内存。这些命令在固定时间内执行。另一个线程将尽可能快地在后台逐渐释放对象</span></span><br><span class="line">DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line">It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="line">idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line">delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line">Specifically Redis deletes objects independently of a user call in the</span><br><span class="line">following scenarios:</span><br><span class="line"><span class="comment"># 用户可以控制FLUSHALL和FLUSHDB的DEL，UNLINK和ASYNC选项。由应用程序的设计来决定何时使用一个或另一个是一个好主意。但是，Redis服务器有时必须删除键或刷新整个数据库，这是其他操作的副作用。特别是在以下情况下，Redis会独立于用户调用而删除对象</span></span><br><span class="line">1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line">in order to make room for new data, without going over the specified</span><br><span class="line">memory limit.</span><br><span class="line">2) Because of expire: when a key with an associated time to live (see the</span><br><span class="line">EXPIRE command) must be deleted from memory.</span><br><span class="line">3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line">already exist. For example the RENAME command may delete the old key</span><br><span class="line">content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line">or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line">itself removes any old content of the specified key in order to replace</span><br><span class="line">it with the specified string.</span><br><span class="line">4) During replication, when a replica performs a full resynchronization with</span><br><span class="line">its master, the content of the whole database is removed in order to</span><br><span class="line">load the RDB file just transferred.</span><br><span class="line"></span><br><span class="line">In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line">like if DEL was called. However you can configure each case specifically</span><br><span class="line">in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line">was called, using the following configuration directives.</span><br><span class="line"><span class="comment"># 在上述所有情况下，默认设置都是以阻塞方式删除对象，就像调用DEL一样。但是，可以使用以下配置指令专门配置每种情况，以便以非阻塞方式释放内存，例如是否调用了UNLINK。</span></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line">It is also possible, for the case when to replace the user code DEL calls</span><br><span class="line">with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="line">command to act exactly like UNLINK, using the following configuration</span><br><span class="line">directive:</span><br><span class="line"><span class="comment"># 对于用UNLINK调用替换用户代码DEL调用不容易的情况，也可以使用以下配置指令将DEL命令的默认行为修改为与UNLINK完全一样</span></span><br><span class="line">lazyfree-lazy-user-del no</span><br></pre></td></tr></table></figure>
<h2 id="THREADED-I-O"><a href="#THREADED-I-O" class="headerlink" title="THREADED I/O"></a>THREADED I/O</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">THREADED I/O </span><br><span class="line"></span><br><span class="line">Redis is mostly single threaded, however there are certain threaded</span><br><span class="line">operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="line">performed on side threads.</span><br><span class="line"><span class="comment"># Redis大多是单线程的，但是有一些线程操作，例如UNLINK，缓慢的IO访问和其他在侧线程上执行的操作</span></span><br><span class="line">Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="line">in different I/O threads. Since especially writing is so slow, normally</span><br><span class="line">Redis users use pipelining in order to speed up the Redis performances per</span><br><span class="line">core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="line">threads it is possible to easily speedup two times Redis without resorting</span><br><span class="line">to pipelining nor sharding of the instance.</span><br><span class="line"><span class="comment"># 现在，还可以在不同的IO线程中处理Redis客户端套接字的读写。由于特别慢的写入速度，通常Redis用户使用流水线来加快每个内核的Redis性能，并生成多个实例以扩展规模。使用IO线程，可以轻松地将Redis加速两次，而无需求助于实例的流水线处理或分片</span></span><br><span class="line">By default threading is disabled, we suggest enabling it only in machines</span><br><span class="line">that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="line">Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="line">threaded I/O only if you actually have performance problems, with Redis</span><br><span class="line">instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="line">there is no point in using this feature.</span><br><span class="line"><span class="comment"># 默认情况下，线程是禁用的，我们建议仅在具有至少4个或更多内核的计算机上启用它，而至少保留一个备用内核。使用8个以上的线程不太可能有很大帮助。我们还建议仅在实际存在性能问题时才使用线程IO，Redis实例可以使用很大一部分CPU时间，否则使用此功能毫无意义。</span></span><br><span class="line">So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="line">threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="line">enable I/O threads use the following configuration directive:</span><br><span class="line"><span class="comment"># 因此，例如，如果您有四个核的盒子，请尝试使用2个或3个IO线程，如果您有8个核，请尝试使用6个线程。为了启用IO线程，请使用以下配置指令</span></span><br><span class="line">io-threads 4</span><br><span class="line"></span><br><span class="line">Setting io-threads to 1 will just use the main thread as usual.</span><br><span class="line">When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="line">to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="line">socket. However it is also possible to enable threading of reads and</span><br><span class="line">protocol parsing using the following configuration directive, by setting</span><br><span class="line">it to yes:</span><br><span class="line"><span class="comment"># 将io-threads设置为1只会照常使用主线程。启用IO线程后，我们仅使用线程进行写操作，即对write（2）系统调用进行线程化，并将客户端缓冲区传输到套接字。但是，也可以使用以下配置指令，通过将其设置为yes，来启用读取线程和协议解析</span></span><br><span class="line">io-threads-do-reads no</span><br><span class="line"></span><br><span class="line">Usually threading reads doesn&#x27;t help much.</span><br><span class="line"><span class="comment"># 通常线程读取并没有多大帮助</span></span><br><span class="line">NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="line">CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="line">enabled.</span><br><span class="line"><span class="comment"># 注意1：无法在运行时通过CONFIG SET更改此配置指令。启用SSL后，该功能目前也无法使用。</span></span><br><span class="line">NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="line">sure you also run the benchmark itself in threaded mode, using the</span><br><span class="line">--threads option to match the number of Redis threads, otherwise you&#x27;ll not</span><br><span class="line">be able to notice the improvements.</span><br><span class="line"><span class="comment"># 注意2：如果要使用redis-benchmark测试Redis加速，请确保还使用--threads选项匹配Redis线程数，在线程模式下运行基准测试本身，否则将无法注意改进</span></span><br></pre></td></tr></table></figure>
<h2 id="KERNEL-OOM-CONTROL"><a href="#KERNEL-OOM-CONTROL" class="headerlink" title="KERNEL OOM CONTROL"></a>KERNEL OOM CONTROL</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">KERNEL OOM CONTROL # 内核OOM控制</span><br><span class="line"></span><br><span class="line">On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="line">should be killed first when out of memory.</span><br><span class="line"><span class="comment"># 在Linux上，可以向内核OOM杀手提示内存不足时应首先终止哪些进程</span></span><br><span class="line">Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="line">for all its processes, depending on their role. The default scores will</span><br><span class="line">attempt to have background child processes killed before all others, and</span><br><span class="line">replicas killed before masters.</span><br><span class="line"><span class="comment"># 启用此功能可使Redis根据其进程主动控制其所有进程的oom_score_adj值。默认分数将尝试使后台子进程在所有其他进程之前被杀死，副本在主数据库之前被杀死</span></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line">When oom-score-adj is used, this directive controls the specific values used</span><br><span class="line">for master, replica and background child processes. Values range -1000 to</span><br><span class="line">1000 (higher means more likely to be killed).</span><br><span class="line"><span class="comment"># 使用oom-score-adj时，此伪指令控制用于主，副本和后台子进程的特定值。值范围-1000至1000（值越高，表示被杀死的可能性越高）</span></span><br><span class="line">Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="line">can freely increase their value, but not decrease it below its initial</span><br><span class="line">settings.</span><br><span class="line"><span class="comment"># 无特权的进程（不是root进程，并且没有CAP_SYS_RESOURCE功能）可以自由地增加其值，但不能将其降低到其初始设置以下</span></span><br><span class="line">Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="line">starts. Because typically the initial value is 0, they will often match the</span><br><span class="line">absolute values.</span><br><span class="line"></span><br><span class="line">oom-score-adj-values 0 200 800</span><br></pre></td></tr></table></figure>
<h2 id="APPEND-ONLY-MODE-重要"><a href="#APPEND-ONLY-MODE-重要" class="headerlink" title="APPEND ONLY MODE(重要)"></a>APPEND ONLY MODE(重要)</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">APPEND ONLY MODE </span><br><span class="line"></span><br><span class="line">By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line">good enough in many applications, but an issue with the Redis process or</span><br><span class="line">a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line">the configured save points).</span><br><span class="line"><span class="comment"># 服务器启动时，使用相对于oom_score_adj初始值的值。因为通常初始值为0，所以它们通常会与绝对值匹配。</span></span><br><span class="line">The Append Only File is an alternative persistence mode that provides</span><br><span class="line">much better durability. For instance using the default data fsync policy</span><br><span class="line">(see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line">dramatic event like a server power outage, or a single write if something</span><br><span class="line">wrong with the Redis process itself happens, but the operating system is</span><br><span class="line">still running correctly.</span><br><span class="line"><span class="comment"># 仅附加文件是一种替代的持久性模式，可提供更好的持久性。例如，使用默认数据fsync策略（请参阅配置文件中的稍后内容），Redis在严重的事件（例如服务器断电）中仅会丢失一秒钟的写入，如果Redis进程本身发生问题，则可能会丢失一次写入，但是操作系统仍在正常运行</span></span><br><span class="line">AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line">If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line">with the better durability guarantees.</span><br><span class="line"><span class="comment"># 可以同时启用AOF和RDB持久性，而不会出现问题。如果在启动时启用了AOF，则Redis将加载AOF，即具有更好持久性的文件</span></span><br><span class="line">Please check http://redis.io/topics/persistence for more information.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line">instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line">data on disk, some other OS will just try to do it ASAP.</span><br><span class="line"><span class="comment"># fsync（）调用告诉操作系统将数据实际写入磁盘，而不是等待输出缓冲区中的更多数据。某些操作系统确实会刷新磁盘上的数据，而另一些操作系统会尽快尝试</span></span><br><span class="line">Redis supports three different modes:</span><br><span class="line"></span><br><span class="line">no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line">always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line">everysec: fsync only one time every second. Compromise.</span><br><span class="line"></span><br><span class="line">The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="line">speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="line">&quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line">it wants, for better performances (but if you can live with the idea of</span><br><span class="line">some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line">or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line">everysec.</span><br><span class="line"></span><br><span class="line">More details please check the following article:</span><br><span class="line">http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line"></span><br><span class="line">If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line">appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no</span><br><span class="line"></span><br><span class="line">When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line">saving process (a background save or AOF log background rewriting) is</span><br><span class="line">performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line">Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line">this currently, as even performing fsync in a different thread will block</span><br><span class="line">our synchronous write(2) call.</span><br><span class="line"><span class="comment"># 当AOF fsync策略设置为always或everysec，并且后台保存进程（后台保存或AOF日志后台重写）对磁盘执行大量IO时，在某些Linux配置中，Redis可能会在fsync上阻塞太长时间（ ）致电。请注意，目前尚无此修复程序，因为即使在其他线程中执行fsync也将阻塞我们的同步write（2）调用</span></span><br><span class="line">In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="line">that will prevent fsync() from being called in the main process while a</span><br><span class="line">BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line"><span class="comment"># 为了减轻此问题，可以使用以下选项来防止在BGSAVE或BGREWRITEAOF进行时在主进程中调用fsync（）</span></span><br><span class="line">This means that while another child is saving, the durability of Redis is</span><br><span class="line">the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line">possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line">default Linux settings).</span><br><span class="line"><span class="comment"># 这意味着当另一个子线程正在保存时，Redis的持久性与“ appendfsync none”相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置）可能会丢失多达30秒的日志</span></span><br><span class="line">If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line">&quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"><span class="comment"># 如果您有延迟问题，请将其设置为“是”。否则，从耐用性的角度出发，将其保留为“ no”是最安全的选择</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">Automatic rewrite of the append only file.</span><br><span class="line">Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line">BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line"><span class="comment"># 自动重写仅附加文件。当AOF日志大小增加指定百分比时，Redis能够自动重写日志文件，隐式调用BGREWRITEAOF</span></span><br><span class="line">This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line">latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line">the AOF at startup is used).</span><br><span class="line"><span class="comment"># 它是这样工作的：Redis在最近一次重写之后会记住AOF文件的大小（如果自重新启动以来未发生任何重写，则使用启动时AOF的大小）。</span></span><br><span class="line">This base size is compared to the current size. If the current size is</span><br><span class="line">bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line">you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line">is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line">is reached but it is still pretty small.</span><br><span class="line"><span class="comment"># 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。另外，您需要指定要重写的AOF文件的最小大小，这对于避免重写AOF文件很有用，即使达到百分比增加，但它仍然很小</span></span><br><span class="line">Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line">rewrite feature.</span><br><span class="line"><span class="comment"># 指定零百分比以禁用自动AOF重写功能</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line">startup process, when the AOF data gets loaded back into memory.</span><br><span class="line">This may happen when the system where Redis is running</span><br><span class="line">crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"><span class="attr">data</span>=ordered option (however this can<span class="string">&#x27;t happen when Redis itself</span></span><br><span class="line"><span class="string">crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="string"># 当AOF数据重新加载回内存时，在Redis启动过程中可能会发现AOF文件在末尾被截断。当运行Redis的系统崩溃时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，可能会发生这种情况（但是，当Redis本身崩溃或中止，但操作系统仍然可以正常运行时，就不会发生这种情况）</span></span><br><span class="line"><span class="string">Redis can either exit with an error when this happens, or load as much</span></span><br><span class="line"><span class="string">data as possible (the default now) and start if the AOF file is found</span></span><br><span class="line"><span class="string">to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="string"># 发生这种情况时，Redis可能会退出并显示错误，也可以加载尽可能多的数据（当前为默认值），如果发现AOF文件最后被截断，则Redis会开始。以下选项控制此行为</span></span><br><span class="line"><span class="string">If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span><br><span class="line"><span class="string">the Redis server starts emitting a log to inform the user of the event.</span></span><br><span class="line"><span class="string">Otherwise if the option is set to no, the server aborts with an error</span></span><br><span class="line"><span class="string">and refuses to start. When the option is set to no, the user requires</span></span><br><span class="line"><span class="string">to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span></span><br><span class="line"><span class="string">the server.</span></span><br><span class="line"><span class="string"># 如果aof-load-truncated设置为yes，则将加载截短的AOF文件，并且Redis服务器将开始发出日志以将事件通知用户。否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。如果该选项设置为no，则用户需要在重新启动服务器之前使用“ redis-check-aof”实用程序修复AOF文件</span></span><br><span class="line"><span class="string">Note that if the AOF file will be found to be corrupted in the middle</span></span><br><span class="line"><span class="string">the server will still exit with an error. This option only applies when</span></span><br><span class="line"><span class="string">Redis will try to read more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="string">will be found.</span></span><br><span class="line"><span class="string"># 请注意，如果在中间发现AOF文件已损坏，则服务器仍将退出并出现错误。仅当Redis尝试从AOF文件读取更多数据但找不到足够的字节时，此选项才适用。</span></span><br><span class="line"><span class="string">aof-load-truncated yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When rewriting the AOF file, Redis is able to use an RDB preamble in the</span></span><br><span class="line"><span class="string">AOF file for faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="string">on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class="line"><span class="string"># 重写AOF文件时，Redis可以使用AOF文件中的RDB前同步码来更快地进行重写和恢复。启用此选项后，重写的AOF文件由两个不同的节组成</span></span><br><span class="line"><span class="string">[RDB file] [AOF tail]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When loading, Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span></span><br><span class="line"><span class="string">string and loads the prefixed RDB file, then continues loading the AOF</span></span><br><span class="line"><span class="string">tail.</span></span><br><span class="line"><span class="string"># 加载时，Redis会识别AOF文件以“ REDIS”字符串开头并加载带前缀的RDB文件，然后继续加载AOF尾部。</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble yes</span></span><br></pre></td></tr></table></figure>
<p>appendonly（AOF）是一种替代的持久性模式，可提供更好的持久性。例如，使用默认数据fsync策略（请参阅配置文件中的稍后内容），Redis在严重的事件（例如服务器断电）中仅会丢失一秒钟的写入，如果Redis进程本身发生问题，则可能会丢失一次写入，但是操作系统仍在正常运行</p>
<p>可以同时启用AOF和RDB持久性，而不会出现问题。如果在启动时启用了AOF，则Redis将加载AOF，即具有更好持久性的文件</p>
<p>appendonly（AOF）默认是关闭的，我们可以<code>appendonly yes</code>打开，默认文件名为<code>appendonly.aof</code></p>
<blockquote>
<p>默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，  可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no</p>
</blockquote>
<p>appendonly（AOF）的启动参数有三个：默认使用appendfsync everysec</p>
<blockquote>
<p>appendfsync always<br>appendfsync everysec<br>appendfsync no</p>
<p>aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</p>
</blockquote>
<p>在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。  设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。</p>
<blockquote>
<p>如果您有延迟问题，请将其设置为“是”。否则，从耐用性的角度出发，将其保留为“ no”是最安全的选择</p>
</blockquote>
<p>auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</p>
<p>auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</p>
<p>aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象 redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes</p>
<h2 id="LUA-SCRIPTING"><a href="#LUA-SCRIPTING" class="headerlink" title="LUA SCRIPTING"></a>LUA SCRIPTING</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LUA SCRIPTING  </span><br><span class="line"></span><br><span class="line">Max execution time of a Lua script in milliseconds.</span><br><span class="line"><span class="comment"># Lua脚本的最大执行时间（以毫秒为单位）。</span></span><br><span class="line">If the maximum execution time is reached Redis will log that a script is</span><br><span class="line">still in execution after the maximum allowed time and will start to</span><br><span class="line">reply to queries with an error.</span><br><span class="line"><span class="comment"># 如果达到了最大执行时间，Redis将记录脚本在允许的最大时间后仍在执行中，并将开始以错误答复查询</span></span><br><span class="line">When a long running script exceeds the maximum execution time only the</span><br><span class="line">SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line">used to stop a script that did not yet call any write commands. The second</span><br><span class="line">is the only way to shut down the server in the case a write command was</span><br><span class="line">already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="line">termination of the script.</span><br><span class="line"><span class="comment"># 如果长时间运行的脚本超过了最大执行时间，则只有“ SCRIPT KILL”和“ SHUTDOWN NOSAVE”命令可用。第一个可用于停止尚未调用任何写命令的脚本。第二种是在脚本已经发出写命令但用户不想等待脚本自然终止的情况下关闭服务器的唯一方法</span></span><br><span class="line">Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line"><span class="comment"># 将其设置为0或负值可无警告地无限执行</span></span><br><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure>
<p>lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000</p>
<h2 id="REDIS-CLUSTER-重要"><a href="#REDIS-CLUSTER-重要" class="headerlink" title="REDIS CLUSTER(重要)"></a>REDIS CLUSTER(重要)</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">REDIS CLUSTER  </span><br><span class="line"></span><br><span class="line">Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="line">started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line">cluster node enable the cluster support uncommenting the following:</span><br><span class="line"><span class="comment"># 普通Redis实例不能属于Redis集群；只有作为群集节点启动的节点可以。为了将Redis实例启动为集群节点，请启用集群支持</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">Every cluster node has a cluster configuration file. This file is not</span><br><span class="line">intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line">Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line">Make sure that instances running in the same system do not have</span><br><span class="line">overlapping cluster configuration file names.</span><br><span class="line"><span class="comment"># 每个群集节点都有一个群集配置文件。该文件不适合手工编辑。它由Redis节点创建和更新。每个Redis群集节点都需要一个不同的群集配置文件。确保在同一系统上运行的实例没有重叠的集群配置文件名</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line">Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line">for it to be considered in failure state.</span><br><span class="line">Most other internal time limits are a multiple of the node timeout.</span><br><span class="line"><span class="comment"># 群集节点超时是一个节点必须不可达的毫秒数，才能将其视为故障状态。其他大多数内部时间限制是节点超时的倍数</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line">A replica of a failing master will avoid to start a failover if its data</span><br><span class="line">looks too old.</span><br><span class="line"><span class="comment"># 如果发生故障的主副本的数据看起来太旧，它将避免启动故障转移。</span></span><br><span class="line">There is no simple way for a replica to actually have an exact measure of</span><br><span class="line">its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="line"><span class="comment"># 没有一种简单的方法可以使副本实际上具有其“数据年龄”的准确度量，因此执行以下两项检查</span></span><br><span class="line">1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="line">in order to try to give an advantage to the replica with the best</span><br><span class="line">replication offset (more data from the master processed).</span><br><span class="line">Replicas will try to get their rank by offset, and apply to the start</span><br><span class="line">of the failover a delay proportional to their rank.</span><br><span class="line"><span class="comment"># # 如果存在多个能够进行故障转移的副本，则它们会交换消息，以便尝试利用具有最佳复制偏移量的副本（已处理来自主数据库的更多数据）来获得优势。副本将尝试按偏移量获得其排名，并将故障切换延迟按其排名成比例地应用于故障转移的开始</span></span><br><span class="line">2) Every single replica computes the time of the last interaction with</span><br><span class="line">its master. This can be the last ping or command received (if the master</span><br><span class="line">is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="line">disconnection with the master (if the replication link is currently down).</span><br><span class="line">If the last interaction is too old, the replica will not try to failover</span><br><span class="line">at all.</span><br><span class="line"><span class="comment"># 每个单个副本都会计算与其主副本之间最后一次交互的时间。这可以是最后收到的ping或命令（如果主服务器仍处于“已连接”状态），也可以是自从与主服务器断开连接以来经过的时间（如果复制链接当前已关闭）。如果最后一次交互太旧，则副本将完全不会尝试故障转移</span></span><br><span class="line">The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="line">the failover if, since the last interaction with the master, the time</span><br><span class="line">elapsed is greater than:</span><br><span class="line"><span class="comment"># 用户可以调整点“ 2”。特别是，如果自从上次与主服务器进行交互以来，如果经过的时间大于或等于一个副本，则副本将不执行故障转移。</span></span><br><span class="line">(node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period</span><br><span class="line"><span class="comment"># （节点超时 * 集群副本有效性因子）+ 复制周期</span></span><br><span class="line">So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor</span><br><span class="line">is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="line">replica will not try to failover if it was not able to talk with the master</span><br><span class="line">for longer than 310 seconds.</span><br><span class="line"><span class="comment"># 因此，例如，如果节点超时为30秒，并且集群副本有效期因子为10，并且假设默认的repl-ping-replica-period为10秒，则副本将无法尝试进行故障转移，如果它不能与主人交谈超过310秒</span></span><br><span class="line">A large cluster-replica-validity-factor may allow replicas with too old data to failover</span><br><span class="line">a master, while a too small value may prevent the cluster from being able to</span><br><span class="line">elect a replica at all.</span><br><span class="line"><span class="comment"># 较大的群集副本有效性因素可能会使数据过旧的副本无法对主副本进行故障转移，而值太小可能会使群集根本无法选择副本</span></span><br><span class="line">For maximum availability, it is possible to set the cluster-replica-validity-factor</span><br><span class="line">to a value of 0, which means, that replicas will always try to failover the</span><br><span class="line">master regardless of the last time they interacted with the master.</span><br><span class="line">(However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="line">offset rank).</span><br><span class="line"><span class="comment"># 为了获得最大可用性，可以将cluster-replica-validity-factor设置为0，这意味着，无论副本上次与主服务器交互是什么，副本将始终尝试对主服务器进行故障转移。 （但是，他们将始终尝试按与其偏移等级成比例的方式应用延迟）</span></span><br><span class="line">Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line">the cluster will always be able to continue.</span><br><span class="line"><span class="comment"># 零是唯一能够确保当所有分区恢复正常时群集将始终能够继续运行的值</span></span><br><span class="line">cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line">Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="line">that are left without working replicas. This improves the cluster ability</span><br><span class="line">to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="line">in case of failure if it has no working replicas.</span><br><span class="line"><span class="comment"># 群集副本能够迁移到孤立的主数据库，即那些没有工作副本的主数据库。这提高了群集抵抗故障的能力，否则如果孤立的主节点没有可用的副本，则该主节点在发生故障的情况下无法进行故障转移</span></span><br><span class="line">Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="line">given number of other working replicas for their old master. This number</span><br><span class="line">is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="line">will migrate only if there is at least 1 other working replica for its master</span><br><span class="line">and so forth. It usually reflects the number of replicas you want for every</span><br><span class="line">master in your cluster.</span><br><span class="line"><span class="comment"># 仅当旧的主副本仍存在至少给定数量的其他工作副本时，副本副本才会迁移到孤立的主副本。这个数字是“移民壁垒”。迁移屏障为1意味着，仅当副本数据库的主副本中至少有1个其他工作副本时，副本副本才会迁移。它通常反映出集群中每个主数据库所需的副本数</span></span><br><span class="line">Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="line">one replica). To disable migration just set it to a very large value.</span><br><span class="line">A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line">in production.</span><br><span class="line"><span class="comment"># 缺省值为1（仅当其主副本保留至少一个副本副本时，副本副本才会迁移）。要禁用迁移，只需将其设置为非常大的值即可。可以设置为0，但仅用于调试和生产危险</span></span><br><span class="line">cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line">is at least a hash slot uncovered (no available node is serving it).</span><br><span class="line">This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line">are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line">It automatically returns available as soon as all the slots are covered again.</span><br><span class="line"><span class="comment"># 默认情况下，如果Redis Cluster节点检测到至少发现一个哈希槽（没有可用的节点正在为其提供服务），它们将停止接受查询。这样，如果集群部分关闭（例如，不再覆盖哈希槽范围），则所有集群最终将变得不可用。再次覆盖所有插槽后，它将自动返回可用状态</span></span><br><span class="line">However sometimes you want the subset of the cluster which is working,</span><br><span class="line">to continue to accept queries for the part of the key space that is still</span><br><span class="line">covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line">option to no.</span><br><span class="line"><span class="comment"># 但是，有时您希望正在运行的集群子集继续接受对仍覆盖的部分键空间的查询。为此，只需将cluster-require-full-coverage选项设置为no</span></span><br><span class="line"></span><br><span class="line">cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="line">master during master failures. However the master can still perform a</span><br><span class="line">manual failover, if forced to do so.</span><br><span class="line"><span class="comment"># 设置为yes时，此选项可防止副本在主服务器发生故障时尝试对其主服务器进行故障转移。但是，主服务器仍然可以执行手动故障转移（如果被迫执行）</span></span><br><span class="line">This is useful in different scenarios, especially in the case of multiple</span><br><span class="line">data center operations, where we want one side to never be promoted if not</span><br><span class="line">in the case of a total DC failure.</span><br><span class="line"><span class="comment"># 这在不同的情况下很有用，尤其是在多个数据中心操作的情况下，在这种情况下，如果完全DC失败，我们希望不升级一侧。</span></span><br><span class="line">cluster-replica-no-failover no</span><br><span class="line"></span><br><span class="line">This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="line">the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="line"><span class="comment"># 设置为yes时，此选项允许节点在群集处于关闭状态时为其提供读取流量，只要它认为自己拥有插槽即可</span></span><br><span class="line">This is useful for two cases.  The first case is for when an application </span><br><span class="line">doesn&#x27;t require consistency of data during node failures or network partitions.</span><br><span class="line">One example of this is a cache, where as long as the node has the data it</span><br><span class="line">should be able to serve it. </span><br><span class="line"><span class="comment"># 这对于两种情况很有用。第一种情况是在节点故障或网络分区期间应用程序不需要数据一致性时。一个示例是高速缓存，只要节点具有数据，它就应该能够为其服务</span></span><br><span class="line">The second use case is for configurations that don&#x27;t meet the recommended  </span><br><span class="line">three shards but want to enable cluster mode and scale later. A </span><br><span class="line">master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="line">entire cluster without this option set, with it set there is only a write outage.</span><br><span class="line">Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="line"><span class="comment"># 第二个用例是针对不符合建议的三个分片但希望启用集群模式并在以后扩展的配置。如果没有设置此选项，则在1或2分片配置中的主服务器中断会导致整个集群的读写中断。如果没有法定人数的主持人，则插槽所有权不会自动更改</span></span><br><span class="line">cluster-allow-reads-when-down no</span><br><span class="line"></span><br><span class="line">In order to setup your cluster make sure to read the documentation</span><br><span class="line">available at http://redis.io web site.</span><br></pre></td></tr></table></figure>
<p>cluster-enabled：集群开关，默认是不开启集群模式。</p>
<p>cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf</p>
<p>cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数</p>
<p>cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了， 导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。</p>
<blockquote>
<p>判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period   如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</p>
</blockquote>
<p>cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</p>
<p>cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。 设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</p>
<h2 id="CLUSTER-DOCKER-NAT-support"><a href="#CLUSTER-DOCKER-NAT-support" class="headerlink" title="CLUSTER DOCKER/NAT support"></a>CLUSTER DOCKER/NAT support</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CLUSTER DOCKER/NAT support  </span><br><span class="line"></span><br><span class="line">In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line">addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line">Docker and other containers).</span><br><span class="line"><span class="comment"># 在某些部署中，Redis群集节点地址发现失败，这是因为地址经过NAT限制或端口已转发（典型情况是Docker和其他容器）</span></span><br><span class="line">In order to make Redis Cluster working in such environments, a static</span><br><span class="line">configuration where each node knows its public address is needed. The</span><br><span class="line">following two options are used for this scope, and are:</span><br><span class="line"><span class="comment"># 为了使Redis Cluster在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是</span></span><br><span class="line">* cluster-announce-ip</span><br><span class="line">* cluster-announce-port</span><br><span class="line">* cluster-announce-bus-port</span><br><span class="line"></span><br><span class="line">Each instructs the node about its address, client port, and cluster message</span><br><span class="line">bus port. The information is then published in the header of the bus packets</span><br><span class="line">so that other nodes will be able to correctly map the address of the node</span><br><span class="line">publishing the information.</span><br><span class="line"><span class="comment"># 每个节点都向节点指示其地址，客户端端口和群集消息总线端口。然后将信息发布在总线数据包的标题中，以便其他节点将能够正确映射发布信息的节点的地址</span></span><br><span class="line">If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line">will be used instead.</span><br><span class="line"><span class="comment"># 如果未使用上述选项，则将使用常规的Redis群集自动检测</span></span><br><span class="line">Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line">clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line">on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line">10000 will be used as usual.</span><br><span class="line"><span class="comment"># 请注意，重新映射时，总线端口可能不在客户端端口+ 10000的固定偏移处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则将照常使用10000的固定偏移量</span></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 10.1.1.5</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 6380</span><br></pre></td></tr></table></figure>
<p>在某些部署中，Redis群集节点寻址失败，这是因为地址经过NAT限制或端口已转发（典型情况是Docker和其他容器），为了使Redis Cluster在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是</p>
<ul>
<li>cluster-announce-ip</li>
<li>cluster-announce-port</li>
<li>cluster-announce-bus-port</li>
</ul>
<h2 id="SLOW-LOG"><a href="#SLOW-LOG" class="headerlink" title="SLOW LOG"></a>SLOW LOG</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">SLOW LOG </span><br><span class="line"></span><br><span class="line">The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line">execution time. The execution time does not include the I/O operations</span><br><span class="line">like talking with the client, sending the reply and so forth,</span><br><span class="line">but just the time needed to actually execute the command (this is the only</span><br><span class="line">stage of command execution where the thread is blocked and can not serve</span><br><span class="line">other requests in the meantime).</span><br><span class="line"><span class="comment"># Redis Slow Log是一个用于记录超过指定执行时间的查询的系统。执行时间不包括与客户端交谈，发送回复等IO操作，而仅包括实际执行命令所需的时间（这是命令执行的唯一阶段，在该阶段线程被阻塞并且无法服务同时提出其他要求）</span></span><br><span class="line">You can configure the slow log with two parameters: one tells Redis</span><br><span class="line">what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line">command to get logged, and the other parameter is the length of the</span><br><span class="line">slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line">queue of logged commands.</span><br><span class="line"><span class="comment"># 您可以使用以下两个参数配置慢速日志：一个告诉Redis，为了使命令被记录下来，执行时间要超过多少微秒，而另一个参数是慢速日志的长度。记录新命令时，最早的命令将从记录的命令队列中删除</span></span><br><span class="line">The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line">to one second. Note that a negative number disables the slow log, while</span><br><span class="line">a value of zero forces the logging of every command.</span><br><span class="line"><span class="comment"># 时间以微秒为单位，因此1000000等于一秒。请注意，负数将禁用慢速日志记录，而零值将强制记录每个命令</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line">You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"><span class="comment"># 该长度没有限制。请注意，它将消耗内存。您可以使用SLOWLOG RESET回收慢日志使用的内存</span></span><br></pre></td></tr></table></figure>
<p>Slowlog-log-slower-than: 默认值为10000，其中1000000等于1秒（负数将禁用慢速日志记录，而零值将强制记录每个命令）</p>
<p>slowlog-max-len: 日志的长度默认值为128，新日志将追加。就日志将从前删除。</p>
<h2 id="LATENCY-MONITOR"><a href="#LATENCY-MONITOR" class="headerlink" title="LATENCY MONITOR"></a>LATENCY MONITOR</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">LATENCY MONITOR </span><br><span class="line"></span><br><span class="line">The Redis latency monitoring subsystem samples different operations</span><br><span class="line">at runtime in order to collect data related to possible sources of</span><br><span class="line">latency of a Redis instance.</span><br><span class="line"><span class="comment"># Redis延迟监视子系统在运行时对不同的操作进行采样，以便收集与Redis实例的潜在延迟源相关的数据</span></span><br><span class="line">Via the LATENCY command this information is available to the user that can</span><br><span class="line">print graphs and obtain reports.</span><br><span class="line"><span class="comment"># 通过LATENCY命令，该信息可供打印，获取报告的用户使用</span></span><br><span class="line">The system only logs operations that were performed in a time equal or</span><br><span class="line">greater than the amount of milliseconds specified via the</span><br><span class="line">latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line">to zero, the latency monitor is turned off.</span><br><span class="line"><span class="comment"># 系统仅记录在等于或大于通过delay-monitor-threshold配置指令指定的毫秒量的时间内执行的操作。当其值设置为零时，等待时间监视器将关闭</span></span><br><span class="line">By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line">if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="line">impact, that while very small, can be measured under big load. Latency</span><br><span class="line">monitoring can easily be enabled at runtime using the command</span><br><span class="line">&quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="line"><span class="comment"># 默认情况下，延迟监视是禁用的，因为如果您没有延迟问题，通常不需要它，并且收集数据会对性能产生影响，尽管影响很小，但是可以在大负载下进行测量。如果需要，可以在运行时使用命令“ CONFIG SET delay-monitor-threshold &lt;milliseconds&gt;”轻松启用延迟监视</span></span><br><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure>
<h2 id="EVENT-NOTIFICATION"><a href="#EVENT-NOTIFICATION" class="headerlink" title="EVENT NOTIFICATION"></a>EVENT NOTIFICATION</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">EVENT NOTIFICATION </span><br><span class="line"></span><br><span class="line">Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line">This feature is documented at http://redis.io/topics/notifications</span><br><span class="line"><span class="comment"># Redis可以通知PubSub客户端关键空间中发生的事件</span></span><br><span class="line">For instance if keyspace events notification is enabled, and a client</span><br><span class="line">performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="line">messages will be published via Pub/Sub:</span><br><span class="line"><span class="comment"># 例如，如果启用了键空间事件通知，并且客户端对存储在数据库0中的键“ foo”执行了DEL操作，则将通过PubSub发布两条消息</span></span><br><span class="line">PUBLISH __keyspace@0__:foo del</span><br><span class="line">PUBLISH __keyevent@0__:del foo</span><br><span class="line"></span><br><span class="line">It is possible to select the events that Redis will notify among a set</span><br><span class="line">of classes. Every class is identified by a single character:</span><br><span class="line"><span class="comment"># 可以在一组类中选择Redis将通知的事件。每个类别都由单个字符标识</span></span><br><span class="line">K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.             # 空键事件，以__keyspace @ &lt;db&gt; __前缀发布</span><br><span class="line">E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.             # 按键事件，以__keyevent @ &lt;db&gt; __前缀发布</span><br><span class="line">g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...    # 通用命令（非类型专用），例如DEL，EXPIRE，RENAME</span><br><span class="line">$     String commands                                                       # 字符串命令</span><br><span class="line">l     List commands                                                         # 列表命令</span><br><span class="line">s     Set commands                                                          # 集合命令</span><br><span class="line">h     Hash commands                                                         # 哈希命令</span><br><span class="line">z     Sorted set commands                                                   # 有序集合命令</span><br><span class="line">x     Expired events (events generated every time a key expires)            # 过期事件（每次密钥过期时生成的事件）</span><br><span class="line">e     Evicted events (events generated when a key is evicted for maxmemory) # 驱逐事件（将密钥驱逐到最大内存时生成的事件）</span><br><span class="line">t     Stream commands                                                       # 流命令</span><br><span class="line">m     Key-miss events (Note: It is not included in the &#x27;A&#x27; class)           # 键丢失事件（注意：它不包含在“ A”类中）</span><br><span class="line">A     Alias for g$lshzxet, so that the &quot;AKE&quot; string means all the events    # glshzxet的别名，因此“ AKE”字符串表示所有事件</span><br><span class="line">    (Except key-miss events which are excluded from &#x27;A&#x27; due to their</span><br><span class="line">     unique nature).</span><br><span class="line"></span><br><span class="line">The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="line">of zero or multiple characters. The empty string means that notifications</span><br><span class="line">are disabled.</span><br><span class="line"><span class="comment"># “ notify-keyspace-events”将由零个或多个字符组成的字符串作为参数。空字符串表示已禁用通知</span></span><br><span class="line">Example: to enable list and generic events, from the point of view of the</span><br><span class="line">       event name, use:</span><br><span class="line"></span><br><span class="line">notify-keyspace-events Elg</span><br><span class="line"></span><br><span class="line">Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line">         name __keyevent@0__:expired use:</span><br><span class="line"></span><br><span class="line">notify-keyspace-events Ex</span><br><span class="line"></span><br><span class="line">By default all notifications are disabled because most users don&#x27;t need</span><br><span class="line">this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="line">specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"><span class="comment"># 默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，并且该功能有一些开销。请注意，如果您未指定K或E中的至少一个，则不会传递任何事件。 notify-keyspace-events</span></span><br></pre></td></tr></table></figure>
<h2 id="GOPHER-SERVER"><a href="#GOPHER-SERVER" class="headerlink" title="GOPHER SERVER"></a>GOPHER SERVER</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOPHER SERVER </span><br><span class="line"></span><br><span class="line">Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="line">the RFC 1436 (https:&#x2F;&#x2F;www.ietf.org&#x2F;rfc&#x2F;rfc1436.txt).</span><br><span class="line"># Redis包含RFC 1436（https：www.ietf.orgrfcrfc1436.txt）中指定的Gopher协议的实现。</span><br><span class="line">The Gopher protocol was very popular in the late &#39;90s. It is an alternative</span><br><span class="line">to the web, and the implementation both server and client side is so simple</span><br><span class="line">that the Redis server has just 100 lines of code in order to implement this</span><br><span class="line">support.</span><br><span class="line"># Gopher协议在90年代后期非常流行。它是Web的替代方法，服务器和客户端的实现是如此简单，以至于Redis服务器只有100行代码才能实现这种支持</span><br><span class="line">What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="line">lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="line">composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="line">internet, others believe that the mainstream internet became too much</span><br><span class="line">controlled, and it&#39;s cool to create an alternative space for people that</span><br><span class="line">want a bit of fresh air.</span><br><span class="line"># 您现在如何使用Gopher？好吧，Gopher从未真正死过，最近出现了一种运动，目的是使Gopher具有更多层次的内容（由纯文本文档组成）得以复活。有些人想要一个更简单的互联网，另一些人则认为主流互联网变得过于受控，为想要一点新鲜空气的人们创造一个替代空间很酷。</span><br><span class="line">Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="line">as a gift.</span><br><span class="line"># 无论如何，在Redis十岁生日的时候，我们给了它Gopher协议作为礼物</span><br><span class="line">--- HOW IT WORKS? ---</span><br><span class="line"></span><br><span class="line">The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="line">two kind of inline requests that were anyway illegal: an empty request</span><br><span class="line">or any request that starts with &quot;&#x2F;&quot; (there are no Redis commands starting</span><br><span class="line">with such a slash). Normal RESP2&#x2F;RESP3 requests are completely out of the</span><br><span class="line">path of the Gopher protocol implementation and are served as usual as well.</span><br><span class="line"># Redis Gopher支持使用Redis的内联协议，特别是两种仍然非法的内联请求：空请求或任何以“”开头的请求（没有以这样的斜杠开头的Redis命令）。正常的RESP2RESP3请求完全超出了Gopher协议实现的路径，并且也照常使用</span><br><span class="line">If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="line">a string like &quot;&#x2F;foo&quot;, if there is a key named &quot;&#x2F;foo&quot; it is served via the</span><br><span class="line">Gopher protocol.</span><br><span class="line"># 如果在启用Gopher时打开与Redis的连接，并向其发送“ foo”之类的字符串，则如果存在名为“ foo”的密钥，则会通过Gopher协议为其提供服务</span><br><span class="line">In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span><br><span class="line">talking), you likely need a script like the following:</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;antirez&#x2F;gopher2redis</span><br><span class="line"></span><br><span class="line">--- SECURITY WARNING ---</span><br><span class="line"></span><br><span class="line">If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="line">to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="line">Once a password is set:</span><br><span class="line"></span><br><span class="line">1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="line">  content via Gopher.</span><br><span class="line">2. However other commands cannot be called before the client will</span><br><span class="line">  authenticate.</span><br><span class="line"></span><br><span class="line">So use the &#39;requirepass&#39; option to protect your instance.</span><br><span class="line"></span><br><span class="line">Note that Gopher is not currently supported when &#39;io-threads-do-reads&#39;</span><br><span class="line">is enabled.</span><br><span class="line"></span><br><span class="line">To enable Gopher support, uncomment the following line and set the option</span><br><span class="line">from no (the default) to yes.</span><br><span class="line"></span><br><span class="line">gopher-enabled no</span><br></pre></td></tr></table></figure>
<h2 id="ADVANCED-CONFIG"><a href="#ADVANCED-CONFIG" class="headerlink" title="ADVANCED CONFIG"></a>ADVANCED CONFIG</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ADVANCED CONFIG </span><br><span class="line"></span><br><span class="line">Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line">small number of entries, and the biggest entry does not exceed a given</span><br><span class="line">threshold. These thresholds can be configured using the following directives.</span><br><span class="line"><span class="comment"># 当哈希条目只有少量条目且最大条目未超过给定阈值时，将使用内存高效的数据结构对其进行编码。可以使用以下指令配置这些阈值</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">Lists are also encoded in a special way to save a lot of space.</span><br><span class="line">The number of entries allowed per internal list node can be specified</span><br><span class="line">as a fixed maximum size or a maximum number of elements.</span><br><span class="line"><span class="comment"># 列表也以特殊方式编码，以节省大量空间。每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数</span></span><br><span class="line">For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"><span class="comment"># 对于固定的最大大小，请使用-5到-1，表示</span></span><br><span class="line">-5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line">-4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line">-3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line">-2: max size: 8 Kb   &lt;-- good</span><br><span class="line">-1: max size: 4 Kb   &lt;-- good</span><br><span class="line">Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line">per list node.</span><br><span class="line"><span class="comment"># 正数表示每个列表节点最多可存储_exactly_个元素</span></span><br><span class="line">The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line">but if your use case is unique, adjust the settings as necessary.</span><br><span class="line"><span class="comment"># 最高性能的选项通常是-2（8 Kb大小）或-1（4 Kb大小），但是如果您的用例是唯一的，请根据需要调整设置</span></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line">Lists may also be compressed.   # 列表也可以被压缩。</span><br><span class="line">Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line">the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line">are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="line"><span class="comment"># 压缩深度是列表的每侧要从压缩中排除的快速列表ziplist节点的数量。列表的开头和结尾始终是未压缩的，以便快速进行pushpop操作。设置是</span></span><br><span class="line">0: disable all list compression # 禁用所有列表压缩</span><br><span class="line">1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="line">going from either the head or tail&quot; # 深度1表示“直到列表中有1个节点之后，才开始压缩，从头到尾</span><br><span class="line">So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line">[head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line">2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line">2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">but compress all nodes between them.</span><br><span class="line">3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line">etc.</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line">Sets have a special encoding in just one case: when a set is composed</span><br><span class="line">of just strings that happen to be integers in radix 10 in the range</span><br><span class="line">of 64 bit signed integers.</span><br><span class="line">The following configuration setting sets the limit in the size of the</span><br><span class="line">set in order to use this special memory saving encoding.</span><br><span class="line"><span class="comment"># 在仅一种情况下，集合具有特殊的编码：当集合仅由恰好是基数10中整数（在64位有符号整数范围内）的字符串组成时。以下配置设置设置了大小限制，以便使用此特殊的内存节省编码</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line">order to save a lot of space. This encoding is only used when the length and</span><br><span class="line">elements of a sorted set are below the following limits:</span><br><span class="line"><span class="comment"># 与哈希表和列表类似，对排序集也进行了特殊编码，以节省大量空间。仅当排序集的长度和元素低于以下限制时，才使用此编码</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line">16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line">this limit, it is converted into the dense representation.</span><br><span class="line"><span class="comment"># HyperLogLog稀疏表示形式的字节数限制。限制包括16个字节的标头。当使用稀疏表示的HyperLogLog超过此限制时，它将转换为密集表示</span></span><br><span class="line">A value greater than 16000 is totally useless, since at that point the</span><br><span class="line">dense representation is more memory efficient.</span><br><span class="line"><span class="comment"># 大于16000的值是完全没有用的，因为在那一点上，密集表示的存储效率更高</span></span><br><span class="line">The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line">the space efficient encoding without slowing down too much PFADD,</span><br><span class="line">which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line">~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line">composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line"><span class="comment"># 建议值约为3000，以便在不减慢过多PFADD的情况下获得节省空间编码的好处，而PFADD的稀疏编码为O（N）。当不关心CPU但有空间时，该值可以提高到10000，并且数据集由基数在0-15000范围内的许多HyperLogLog组成</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">Streams macro node max size / items. The stream data structure is a radix</span><br><span class="line">tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="line">it is possible to configure how big a single node can be in bytes, and the</span><br><span class="line">maximum number of items it may contain before switching to a new node when</span><br><span class="line">appending new stream entries. If any of the following settings are set to</span><br><span class="line">zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="line">max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="line">value.</span><br><span class="line"><span class="comment"># 流宏节点最大大小的项目。流数据结构是一个大节点的基数树，它对内部的多个项目进行编码。使用此配置，可以配置单个节点的大小（以字节为单位），以及在添加新的流条目时切换到新节点之前它可能包含的最大项目数。如果以下任何设置被设置为零，则该限制将被忽略，例如，可以通过将max-bytes设置为0并将max-entries设置为所需的值来仅设置最大整数限制</span></span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line">Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line">order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line">keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line">performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line">that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="line">server is idle the rehashing is never complete and some more memory is used</span><br><span class="line">by the hash table.</span><br><span class="line"><span class="comment"># 活动重新哈希处理每100毫秒CPU时间使用1毫秒，以帮助重新哈希主Redis哈希表（将顶级键映射到值的一个哈希表）。 Redis使用的哈希表实现（请参阅dict.c）执行一次懒惰的重新哈希处理：您在要进行哈希处理的哈希表中运行的操作越多，执行的哈希处理“步骤”就越多，因此，如果服务器空闲，则哈希处理将永远不会完成哈希表使用了更多的内存</span></span><br><span class="line">The default is to use this millisecond 10 times every second in order to</span><br><span class="line">actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line"><span class="comment"># 默认值是每秒使用10毫秒的毫秒数来主动重新哈希主字典，并在可能的情况下释放内存</span></span><br><span class="line">If unsure:</span><br><span class="line">use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="line">not a good thing in your environment that Redis can reply from time to time</span><br><span class="line">to queries with 2 milliseconds delay.</span><br><span class="line"><span class="comment"># 如果不确定：如果您有严格的延迟要求，则使用“ activehashing no”，并且在您的环境中，Redis可以不时地以2毫秒的延迟答复查询不是一件好事</span></span><br><span class="line"></span><br><span class="line">use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="line">want to free memory asap when possible.</span><br><span class="line"><span class="comment"># 如果您没有如此严格的要求，但想在可能的情况下尽快释放内存，请使用“ activerehashing yes”</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">The client output buffer limits can be used to force disconnection of clients</span><br><span class="line">that are not reading data from the server fast enough for some reason (a</span><br><span class="line">common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="line">publisher can produce them).</span><br><span class="line"><span class="comment"># 客户端输出缓冲区限制可用于出于某些原因强制断开那些没有足够快地从服务器读取数据的客户端（常见原因是PubSub客户端不能像发布者产生消息那样快地消耗消息）</span></span><br><span class="line">The limit can be set differently for the three different classes of clients:</span><br><span class="line"><span class="comment"># 可以为三种不同类别的客户设置不同的限制</span></span><br><span class="line">normal -&gt; normal clients including MONITOR clients  # 普通客户，包括MONITOR客户</span><br><span class="line">replica  -&gt; replica clients                         # 复制客户端</span><br><span class="line">pubsub -&gt; clients subscribed to at least one pubsub channel or pattern  # 客户订阅了至少一个pubsub频道或模式</span><br><span class="line"></span><br><span class="line">The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line"><span class="comment"># 每个client-output-buffer-limit指令的语法如下</span></span><br><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line"></span><br><span class="line">A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line">the soft limit is reached and remains reached for the specified number of</span><br><span class="line">seconds (continuously).</span><br><span class="line">So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line">16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line">if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line">disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line">the limit for 10 seconds.</span><br><span class="line"><span class="comment"># 一旦达到硬限制，或者达到软限制并在指定的秒数内（连续）保持达到此限制，客户端将立即断开连接。因此，例如，如果硬限制为32兆字节，软限制为16兆字节10秒，则如果输出缓冲区的大小达到32兆字节，客户端将立即断开连接，但是如果客户端达到16兆字节并连续不断，连接也会断开连接超过极限10秒</span></span><br><span class="line">By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="line">without asking (in a push way), but just after a request, so only</span><br><span class="line">asynchronous clients may create a scenario where data is requested faster</span><br><span class="line">than it can read.</span><br><span class="line"><span class="comment"># 默认情况下，普通客户端不受限制，因为它们不会在不询问的情况下（以推送方式）接收数据，而是在请求之后才接收数据，因此，只有异步客户端才可能创建这样的场景：请求数据的速度比读取数据的速度快</span></span><br><span class="line">Instead there is a default limit for pubsub and replica clients, since</span><br><span class="line">subscribers and replicas receive data in a push fashion.</span><br><span class="line"><span class="comment"># 而是对pubsub和副本客户端有默认限制，因为订阅者和副本以推送方式接收数据</span></span><br><span class="line">Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line"><span class="comment"># 硬限制或软限制都可以通过将其设置为零来禁用</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line">amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line">instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line">the query buffer. However you can configure it here if you have very special</span><br><span class="line">needs, such us huge multi/exec requests or alike.</span><br><span class="line"><span class="comment"># 客户端查询缓冲区会累积新命令。默认情况下，它们被限制为固定数量，以避免协议不同步（例如，由于客户端中的错误）将导致查询缓冲区中的未绑定内存使用。但是，如果您有非常特殊的需求（例如我们巨大的multiexec请求等），则可以在此处进行配置。</span></span><br><span class="line">client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line">In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line">strings, are normally limited to 512 mb. However you can change this limit</span><br><span class="line">here, but must be 1mb or greater</span><br><span class="line"><span class="comment"># 在Redis协议中，批量请求（即表示单个字符串的元素）通常限制为512 mb。但是，您可以在此处更改此限制，但必须为1mb或更大</span></span><br><span class="line">proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line">Redis calls an internal function to perform many background tasks, like</span><br><span class="line">closing connections of clients in timeout, purging expired keys that are</span><br><span class="line">never requested, and so forth.</span><br><span class="line"><span class="comment"># Redis调用内部函数来执行许多后台任务，例如在超时时关闭客户端连接，清除从未请求的过期密钥等</span></span><br><span class="line">Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line">tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="line"><span class="comment"># 并非所有任务都以相同的频率执行，但是Redis会根据指定的“ hz”值检查要执行的任务</span></span><br><span class="line">By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="line">Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line">there are many keys expiring at the same time, and timeouts may be</span><br><span class="line">handled with more precision.</span><br><span class="line"><span class="comment"># 默认情况下，“ hz”设置为10。提高该值将在Redis空闲时使用更多的CPU，但是同时当有多个键同时到期时，它将使Redis的响应速度更快，并且可以使用更多的超时来处理精确</span></span><br><span class="line">The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line">a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line">100 only in environments where very low latency is required.</span><br><span class="line"><span class="comment"># 范围在1到500之间，但是值通常不超过100。大多数用户应该使用默认值10，并且仅在要求非常低延迟的环境中才将其提高到100</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">Normally it is useful to have an HZ value which is proportional to the</span><br><span class="line">number of clients connected. This is useful in order, for instance, to</span><br><span class="line">avoid too many clients are processed for each background task invocation</span><br><span class="line">in order to avoid latency spikes.</span><br><span class="line"><span class="comment"># 通常，具有与连接的客户端数量成比例的HZ值很有用。例如，这有助于避免每次后台任务调用处理过多的客户端，从而避免延迟高峰</span></span><br><span class="line">Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="line">offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="line">which will temporarily raise when there are many connected clients.</span><br><span class="line"><span class="comment"># 由于默认的默认HZ值保守地设置为10，因此Redis提供并默认启用了使用自适应HZ值的能力，当有许多连接的客户端时，该值会暂时升高</span></span><br><span class="line">When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="line">as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="line">used as needed once more clients are connected. In this way an idle</span><br><span class="line">instance will use very little CPU time while a busy instance will be</span><br><span class="line">more responsive.</span><br><span class="line"><span class="comment"># 启用动态HZ后，实际配置的HZ将用作基准，但是一旦连接了更多客户端，实际将使用配置的HZ值的倍数。这样，空闲实例将占用很少的CPU时间，而忙碌的实例将具有更快的响应能力</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line">When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line">the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line">in order to commit the file to the disk more incrementally and avoid</span><br><span class="line">big latency spikes.</span><br><span class="line"><span class="comment"># 当孩子重写AOF文件时，如果启用了以下选项，则每生成32 MB的数据，文件就会进行同步处理。这对于将文件更多地提交到磁盘并避免大的延迟峰值很有用。</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">When redis saves RDB file, if the following option is enabled</span><br><span class="line">the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line">in order to commit the file to the disk more incrementally and avoid</span><br><span class="line">big latency spikes.</span><br><span class="line"><span class="comment"># 当redis保存RDB文件时，如果启用以下选项，则每生成32 MB数据将对文件进行fsync处理。这对于将文件更多地提交到磁盘并避免大的延迟峰值很有用。</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line">idea to start with the default settings and only change them after investigating</span><br><span class="line">how to improve the performances and how the keys LFU change over time, which</span><br><span class="line">is possible to inspect via the OBJECT FREQ command.</span><br><span class="line"><span class="comment"># 可以调整Redis LFU逐出（请参阅maxmemory设置）。但是，最好从默认设置开始，仅在研究了如何提高性能以及LFU密钥随时间变化后才进行更改，可以通过OBJECT FREQ命令进行检查。</span></span><br><span class="line">There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="line">counter logarithm factor and the counter decay time. It is important to</span><br><span class="line">understand what the two parameters mean before changing them.</span><br><span class="line"><span class="comment"># Redis LFU实现中有两个可调参数：计数器对数因子和计数器衰减时间。重要的是在更改它们之前了解两个参数的含义</span></span><br><span class="line">The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="line">uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line">of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line">this way:</span><br><span class="line"><span class="comment"># LFU计数器每个密钥只有8位，最大值是255，因此Redis使用具有对数行为的概率增量。给定旧计数器的值，当访问键时，计数器以这种方式递增</span></span><br><span class="line">1. A random number R between 0 and 1 is extracted.</span><br><span class="line">2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="line">3. The counter is incremented only if R &lt; P.</span><br><span class="line"></span><br><span class="line">The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line">counter changes with a different number of accesses with different</span><br><span class="line">logarithmic factors:</span><br><span class="line"></span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line"></span><br><span class="line">NOTE: The above table was obtained by running the following commands:</span><br><span class="line"></span><br><span class="line">redis-benchmark -n 1000000 incr foo</span><br><span class="line">redis-cli object freq foo</span><br><span class="line"></span><br><span class="line">NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line">to accumulate hits.</span><br><span class="line"></span><br><span class="line">The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line">for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line">less &lt;= 10).</span><br><span class="line"></span><br><span class="line">The default value for the lfu-decay-time is 1. A special value of 0 means to</span><br><span class="line">decay the counter every time it happens to be scanned.</span><br><span class="line"></span><br><span class="line">lfu-log-factor 10</span><br><span class="line">lfu-decay-time 1</span><br></pre></td></tr></table></figure>
<h2 id="ACTIVE-DEFRAGMENTATION"><a href="#ACTIVE-DEFRAGMENTATION" class="headerlink" title="ACTIVE DEFRAGMENTATION"></a>ACTIVE DEFRAGMENTATION</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ACTIVE DEFRAGMENTATION </span><br><span class="line"></span><br><span class="line">What is active defragmentation?</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line">spaces left between small allocations and deallocations of data in memory,</span><br><span class="line">thus allowing to reclaim back memory.</span><br><span class="line"><span class="comment"># 通过主动（在线）碎片整理，Redis服务器可以压缩内存中小量分配和释放数据之间剩余的空间，从而允许回收内存</span></span><br><span class="line">Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line">less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line">restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line">away all the data and create it again. However thanks to this feature</span><br><span class="line">implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line">in a &quot;hot&quot; way, while the server is running.</span><br><span class="line"><span class="comment"># 碎片是每个分配器（幸运的是，Jemalloc发生的情况）和某些工作负载都会发生的自然过程。通常，需要重新启动服务器以减少碎片，或者至少清除所有数据并重新创建。但是，由于Oran Agra为Redis 4.0实现了此功能，因此在服务器运行时，此过程可以在运行时以“热”方式进行</span></span><br><span class="line">Basically when the fragmentation is over a certain level (see the</span><br><span class="line">configuration options below) Redis will start to create new copies of the</span><br><span class="line">values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line">features (in order to understand if an allocation is causing fragmentation</span><br><span class="line">and to allocate it in a better place), and at the same time, will release the</span><br><span class="line">old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line">will cause the fragmentation to drop back to normal values.</span><br><span class="line"><span class="comment"># 基本上，当碎片超过一定级别时（请参阅下面的配置选项），Redis将开始通过利用某些特定的Jemalloc功能在连续的内存区域中创建值的新副本（以便了解分配是否导致碎片并进行分配更好的位置），同时将释放数据的旧副本。对于所有键，以增量方式重复此过程将导致碎片恢复到正常值</span></span><br><span class="line">Important things to understand:</span><br><span class="line"></span><br><span class="line">1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line">to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line">This is the default with Linux builds.</span><br><span class="line"><span class="comment"># 默认情况下，此功能是禁用的，并且仅当您编译Redis以使用我们随Redis的源代码提供的Jemalloc副本时才可用。这是Linux构建的默认设置</span></span><br><span class="line">2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="line">issues.</span><br><span class="line"><span class="comment"># 如果没有碎片问题，则无需启用此功能</span></span><br><span class="line">3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line">needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="line"><span class="comment"># 遇到碎片之后，可以在需要时使用命令“ CONFIG SET activedefrag yes”启用此功能。</span></span><br><span class="line">The configuration parameters are able to fine tune the behavior of the</span><br><span class="line">defragmentation process. If you are not sure about what they mean it is</span><br><span class="line">a good idea to leave the defaults untouched.</span><br><span class="line"><span class="comment"># 配置参数能够微调碎片整理过程的行为。如果您不确定它们的含义，最好不要更改默认值</span></span><br><span class="line">Enabled active defragmentation</span><br><span class="line">activedefrag no</span><br><span class="line"></span><br><span class="line">Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"><span class="comment"># 启动主动碎片整理的最小碎片废物量</span></span><br><span class="line">active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line">Minimum percentage of fragmentation to start active defrag</span><br><span class="line"><span class="comment"># 启动主动碎片整理的最小碎片百分比</span></span><br><span class="line">active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line">Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"><span class="comment"># 我们在最大程度地使用碎片的最大百分比</span></span><br><span class="line">active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line">Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="line">threshold is reached</span><br><span class="line"><span class="comment"># 达到下限阈值时使用的最小的CPU碎片整理工作</span></span><br><span class="line">active-defrag-cycle-min 1</span><br><span class="line"></span><br><span class="line">Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="line">threshold is reached</span><br><span class="line"><span class="comment"># 达到上限时使用的最大的CPU碎片整理工作</span></span><br><span class="line">active-defrag-cycle-max 25</span><br><span class="line"></span><br><span class="line">Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="line">the main dictionary scan</span><br><span class="line"><span class="comment"># 主字典扫描将处理的sethashzsetlist字段的最大数目</span></span><br><span class="line">active-defrag-max-scan-fields 1000</span><br><span class="line"></span><br><span class="line">Jemalloc background thread for purging will be enabled by default</span><br><span class="line"><span class="comment"># 默认情况下，将启用用于清除的Jemalloc后台线程</span></span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line">It is possible to pin different threads and processes of Redis to specific</span><br><span class="line">CPUs in your system, in order to maximize the performances of the server.</span><br><span class="line">This is useful both in order to pin different Redis threads in different</span><br><span class="line">CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="line">in the same host will be pinned to different CPUs.</span><br><span class="line"><span class="comment"># 可以将Redis的不同线程和进程固定到系统中的特定CPU，以最大化服务器的性能。这不仅有助于将不同的Redis线程固定在不同的CPU中，而且还可以确保将在同一主机中运行的多个Redis实例固定到不同的CPU。</span></span><br><span class="line"></span><br><span class="line">Normally you can do this using the &quot;taskset&quot; command, however it is also</span><br><span class="line">possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="line"><span class="comment"># 通常，您可以使用“ taskset”命令来执行此操作，但是在Linux和FreeBSD中，也可以直接通过Redis配置来执行此操作</span></span><br><span class="line">You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="line">the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="line">the taskset command:</span><br><span class="line"><span class="comment"># 您可以固定serverIO线程，bio线程，aof重写子进程和bgsave子进程。指定cpu列表的语法与taskset命令相同</span></span><br><span class="line">Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="line">server_cpulist 0-7:2</span><br><span class="line"></span><br><span class="line">Set bio threads to cpu affinity 1,3:</span><br><span class="line"><span class="comment"># 将生物线程设置为cpu亲和力1,3</span></span><br><span class="line">bio_cpulist 1,3</span><br><span class="line"></span><br><span class="line">Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="line"><span class="comment"># 将aof重写子进程设置为cpu亲和力8,9,10,11</span></span><br><span class="line">aof_rewrite_cpulist 8-11</span><br><span class="line"></span><br><span class="line">Set bgsave child process to cpu affinity 1,10,11</span><br><span class="line"><span class="comment"># 将bgsave子进程设置为cpu亲和力1,10,11</span></span><br><span class="line">bgsave_cpulist 1,10-11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本上，当碎片超过一定级别时（请参阅下面的配置选项），Redis将开始通过利用某些特定的Jemalloc功能在连续的内存区域中创建值的新副本（以便了解分配是否导致碎片并进行分配更好的位置），同时将释放数据的旧副本。对于所有键，以增量方式重复此过程将导致碎片恢复到正常值，默认情况下，此功能是禁用的，并且仅当您编译Redis以使用我们随Redis的源代码提供的Jemalloc副本时才可用。这是Linux构建的默认设置。如果没有碎片问题，则无需启用此功能</p>
<p>遇到碎片之后，可以在需要时使用命令“ CONFIG SET activedefrag yes”启用此功能。</p>
<p>Activedefrag 配置参数能够微调碎片整理过程的行为，默认为No<br>active-defrag-ignore-bytes 启动主动碎片整理的最小碎片废物量默认100mb<br>active-defrag-threshold-lower: 启动主动碎片整理的最小碎片百分比，默认10<br>active-defrag-cycle-min：达到下限阈值时使用的最小的CPU碎片整理工作，默认1<br>active-defrag-cycle-max：达到上限时使用的最大的CPU碎片整理工作，默认25<br>active-defrag-max-scan-fields 主字典扫描将处理的sethashzsetlist字段的最大数目，默认1000<br>active-defrag-cycle-min：达到下限阈值时使用的最小的CPU碎片整理工作，默认1x</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>NoSQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
